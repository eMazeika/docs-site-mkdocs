{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Dynamic-Property/","text":"Introduction Made changes in working with the Dynamic Properties, namely, have divided values and meta-info. It means, each model(which has dynamic properties) collect dynamic property values in separate table from meta-info. This allowed to improved performance and to separate the logic on working with the properties. Allowed to reduce the size of models/data-transfer-objects. look at https://github.com/VirtoCommerce/vc-module-customer/tree/release/3.0.0/src/VirtoCommerce.CustomerModule.Data/Model/MemberDynamicPropertyObjectValueEntity.cs How to make changes for extension models E.g. There is a extension class ShoppingCart2.cs and ShoppingCart2Entity.cs Working with ShoppingCart2 Then need to add a class, it has to be called ShoppingCart2DynamicPropertyObjectValueEntity.cs, which inherit from abstract class DynamicPropertyObjectValueEntity public class ShoppingCart2DynamicPropertyObjectValueEntity : DynamicPropertyObjectValueEntity { public virtual ShoppingCart2Entity ShoppingCart { get; set; } } And then to add collection DynamicPropertyObjectValues to ShoppingCart2Entity public virtual ObservableCollection<ShoppingCart2DynamicPropertyObjectValueEntity> DynamicPropertyObjectValues { get; set; } = new NullCollection<ShoppingCart2DynamicPropertyObjectValueEntity>(); Then make changes in ShoppingCart2Entity: add the code to method ToModel cart.DynamicProperties = DynamicPropertyObjectValues.GroupBy(g => g.PropertyId).Select(x => { var property = AbstractTypeFactory<DynamicObjectProperty>.TryCreateInstance(); property.Id = x.Key; property.Name = x.FirstOrDefault()?.PropertyName; property.Values = x.Select(v => v.ToModel(AbstractTypeFactory<DynamicPropertyObjectValue>.TryCreateInstance())).ToArray(); return property; }).ToArray(); add the code to method FromModel if (cart.DynamicProperties != null) { DynamicPropertyObjectValues = new ObservableCollection<ShoppingCart2DynamicPropertyObjectValueEntity>(cart.DynamicProperties.SelectMany(p => p.Values .Select(v => AbstractTypeFactory<ShoppingCart2DynamicPropertyObjectValueEntity>.TryCreateInstance().FromModel(v, cart, p))).OfType<Shopping2CartDynamicPropertyObjectValueEntity>()); } add the code to method Patch if (!DynamicPropertyObjectValues.IsNullCollection()) { DynamicPropertyObjectValues.Patch(target.DynamicPropertyObjectValues, (sourceDynamicPropertyObjectValues, targetDynamicPropertyObjectValues) => sourceDynamicPropertyObjectValues.Patch(targetDynamicPropertyObjectValues)); } Working with Cart2DbContext Need to make mapping with ShoppingCart2DynamicPropertyObjectValueEntity modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().ToTable(\"Cart2DynamicPropertyObjectValue\").HasKey(x => x.Id); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().Property(x => x.Id).HasMaxLength(128); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().Property(x => x.DecimalValue).HasColumnType(\"decimal(18,5)\"); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().HasOne(p => p.ShoppingCart) .WithMany(s => s.DynamicPropertyObjectValues).HasForeignKey(k => k.ObjectId) .OnDelete(DeleteBehavior.Cascade); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().HasIndex(x => new { x.ObjectType, x.ObjectId }) .IsUnique(false) .HasName(\"IX_ObjectType_ObjectId\"); Working with Cart2Repository Need to add IQueryable protected IQueryable<ShoppingCartDynamicPropertyObjectValueEntity> DynamicPropertyObjectValues => DbContext.Set<ShoppingCartDynamicPropertyObjectValueEntity>(); Then need to add a logic to GetShoppingCartsByIdsAsync which will collect values from database await DynamicPropertyObjectValues.Where(x => ids.Contains(x.ObjectId)).ToArrayAsync() and if need to add a logic of working with ResponseGroup. Migration Then need to add migration which will create a table Cart2DynamicPropertyObjectValue and collect values to the table. use the command in the Package Manage Console Add-Migration AddCart2DynamicPropertyObjectValue -Context VirtoCommerce.CartModule.Data.Repositories.CartDbContext -StartupProject VirtoCommerce.CartModule.Data -Verbose -OutputDir Migrations look at https://github.com/VirtoCommerce/vc-module-customer/tree/release/3.0.0/src/VirtoCommerce.CustomerModule.Data/Migrations/20190628091513_AddCustomerDynamicPropertyObjectValue.cs. There's custom SQL script added to the migration. It's recommended to combine this script in a single migration: https://github.com/VirtoCommerce/vc-module-customer/blob/release/3.0.0/src/VirtoCommerce.CustomerModule.Data/Migrations/20000000000000_UpdateCustomerV2.cs#L61-L71","title":"Introduction"},{"location":"Dynamic-Property/#introduction","text":"Made changes in working with the Dynamic Properties, namely, have divided values and meta-info. It means, each model(which has dynamic properties) collect dynamic property values in separate table from meta-info. This allowed to improved performance and to separate the logic on working with the properties. Allowed to reduce the size of models/data-transfer-objects. look at https://github.com/VirtoCommerce/vc-module-customer/tree/release/3.0.0/src/VirtoCommerce.CustomerModule.Data/Model/MemberDynamicPropertyObjectValueEntity.cs","title":"Introduction"},{"location":"Dynamic-Property/#how-to-make-changes-for-extension-models","text":"E.g. There is a extension class ShoppingCart2.cs and ShoppingCart2Entity.cs","title":"How to make changes for extension models"},{"location":"Dynamic-Property/#working-with-shoppingcart2","text":"Then need to add a class, it has to be called ShoppingCart2DynamicPropertyObjectValueEntity.cs, which inherit from abstract class DynamicPropertyObjectValueEntity public class ShoppingCart2DynamicPropertyObjectValueEntity : DynamicPropertyObjectValueEntity { public virtual ShoppingCart2Entity ShoppingCart { get; set; } } And then to add collection DynamicPropertyObjectValues to ShoppingCart2Entity public virtual ObservableCollection<ShoppingCart2DynamicPropertyObjectValueEntity> DynamicPropertyObjectValues { get; set; } = new NullCollection<ShoppingCart2DynamicPropertyObjectValueEntity>(); Then make changes in ShoppingCart2Entity: add the code to method ToModel cart.DynamicProperties = DynamicPropertyObjectValues.GroupBy(g => g.PropertyId).Select(x => { var property = AbstractTypeFactory<DynamicObjectProperty>.TryCreateInstance(); property.Id = x.Key; property.Name = x.FirstOrDefault()?.PropertyName; property.Values = x.Select(v => v.ToModel(AbstractTypeFactory<DynamicPropertyObjectValue>.TryCreateInstance())).ToArray(); return property; }).ToArray(); add the code to method FromModel if (cart.DynamicProperties != null) { DynamicPropertyObjectValues = new ObservableCollection<ShoppingCart2DynamicPropertyObjectValueEntity>(cart.DynamicProperties.SelectMany(p => p.Values .Select(v => AbstractTypeFactory<ShoppingCart2DynamicPropertyObjectValueEntity>.TryCreateInstance().FromModel(v, cart, p))).OfType<Shopping2CartDynamicPropertyObjectValueEntity>()); } add the code to method Patch if (!DynamicPropertyObjectValues.IsNullCollection()) { DynamicPropertyObjectValues.Patch(target.DynamicPropertyObjectValues, (sourceDynamicPropertyObjectValues, targetDynamicPropertyObjectValues) => sourceDynamicPropertyObjectValues.Patch(targetDynamicPropertyObjectValues)); }","title":"Working with ShoppingCart2"},{"location":"Dynamic-Property/#working-with-cart2dbcontext","text":"Need to make mapping with ShoppingCart2DynamicPropertyObjectValueEntity modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().ToTable(\"Cart2DynamicPropertyObjectValue\").HasKey(x => x.Id); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().Property(x => x.Id).HasMaxLength(128); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().Property(x => x.DecimalValue).HasColumnType(\"decimal(18,5)\"); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().HasOne(p => p.ShoppingCart) .WithMany(s => s.DynamicPropertyObjectValues).HasForeignKey(k => k.ObjectId) .OnDelete(DeleteBehavior.Cascade); modelBuilder.Entity<ShoppingCart2DynamicPropertyObjectValueEntity>().HasIndex(x => new { x.ObjectType, x.ObjectId }) .IsUnique(false) .HasName(\"IX_ObjectType_ObjectId\");","title":"Working with Cart2DbContext"},{"location":"Dynamic-Property/#working-with-cart2repository","text":"Need to add IQueryable protected IQueryable<ShoppingCartDynamicPropertyObjectValueEntity> DynamicPropertyObjectValues => DbContext.Set<ShoppingCartDynamicPropertyObjectValueEntity>(); Then need to add a logic to GetShoppingCartsByIdsAsync which will collect values from database await DynamicPropertyObjectValues.Where(x => ids.Contains(x.ObjectId)).ToArrayAsync() and if need to add a logic of working with ResponseGroup.","title":"Working with Cart2Repository"},{"location":"Dynamic-Property/#migration","text":"Then need to add migration which will create a table Cart2DynamicPropertyObjectValue and collect values to the table. use the command in the Package Manage Console Add-Migration AddCart2DynamicPropertyObjectValue -Context VirtoCommerce.CartModule.Data.Repositories.CartDbContext -StartupProject VirtoCommerce.CartModule.Data -Verbose -OutputDir Migrations look at https://github.com/VirtoCommerce/vc-module-customer/tree/release/3.0.0/src/VirtoCommerce.CustomerModule.Data/Migrations/20190628091513_AddCustomerDynamicPropertyObjectValue.cs. There's custom SQL script added to the migration. It's recommended to combine this script in a single migration: https://github.com/VirtoCommerce/vc-module-customer/blob/release/3.0.0/src/VirtoCommerce.CustomerModule.Data/Migrations/20000000000000_UpdateCustomerV2.cs#L61-L71","title":"Migration"},{"location":"Email-sending-settings/","text":"Email sending settings documentation Introduction This article describes how to tune email sending in the Platform v.3 How to customize email sending via SMTP If use gmail.com then need to do: Turn on Allow less secure apps here: https://www.google.com/settings/security/lesssecureapps Set Gateway is Smtp in Notifications options in Appsettings.json or Notifications:Gateway in Azure Then customize Smtp options : Fill SmtpServer smtp.gmail.com and Port 587 Turn ON SSL: EnableSsl set true Set Login and Password like this in appsttings.json : json \"Smtp\": { \"SmtpServer\": \"smtp.gmail.com\", \"Port\": 587, \"EnableSsl\": true, \"Login\": \"test@test.com\", \"Password\": \"qwerty\" } or in Azure : Notifications:Smtp:SmtpServer set smtp.gmail.com Notifications:Smtp:Port set 587 Notifications:Smtp:EnableSsl set true Notifications:Smtp:Login set test@test.com Notifications:Smtp:Password set qwerty If use another SMTP server like sendgrid.net then need to do: Set Gateway is Smtp in Notifications options in Appsettings.json or Notifications:Gateway in Azure Then customize Smtp options : Fill SmtpServer smtp.gmail.com and Port 587 Turn OFF SSL: EnableSsl set false NOTE: should read prerequiments in the SMTP server site and read the article Set Login and Password like this in appsttings.json : json \"Smtp\": { \"SmtpServer\": \"smtp.sendgrid.net\", \"Port\": 25, \"EnableSsl\": false, \"Login\": \"test@sendgrid.net\", \"Password\": \"qwerty\" } How to customize email sending via SendGrid's API Set Gateway is SendGrid Notifications options in Appsettings.json or Azure Then fill apikey in SendGrid options looks like this in appsetting.json : json \"SendGrid\": { \"ApiKey\": \"testapikey\" } or in Azure : * Notifications:SendGrid:ApiKey set testapikey NOTE: Also you could check the emailing-services in IntegrationTests here","title":"Email sending settings documentation"},{"location":"Email-sending-settings/#email-sending-settings-documentation","text":"","title":"Email sending settings documentation"},{"location":"Email-sending-settings/#introduction","text":"This article describes how to tune email sending in the Platform v.3","title":"Introduction"},{"location":"Email-sending-settings/#how-to-customize-email-sending-via-smtp","text":"If use gmail.com then need to do: Turn on Allow less secure apps here: https://www.google.com/settings/security/lesssecureapps Set Gateway is Smtp in Notifications options in Appsettings.json or Notifications:Gateway in Azure Then customize Smtp options : Fill SmtpServer smtp.gmail.com and Port 587 Turn ON SSL: EnableSsl set true Set Login and Password like this in appsttings.json : json \"Smtp\": { \"SmtpServer\": \"smtp.gmail.com\", \"Port\": 587, \"EnableSsl\": true, \"Login\": \"test@test.com\", \"Password\": \"qwerty\" } or in Azure : Notifications:Smtp:SmtpServer set smtp.gmail.com Notifications:Smtp:Port set 587 Notifications:Smtp:EnableSsl set true Notifications:Smtp:Login set test@test.com Notifications:Smtp:Password set qwerty If use another SMTP server like sendgrid.net then need to do: Set Gateway is Smtp in Notifications options in Appsettings.json or Notifications:Gateway in Azure Then customize Smtp options : Fill SmtpServer smtp.gmail.com and Port 587 Turn OFF SSL: EnableSsl set false NOTE: should read prerequiments in the SMTP server site and read the article Set Login and Password like this in appsttings.json : json \"Smtp\": { \"SmtpServer\": \"smtp.sendgrid.net\", \"Port\": 25, \"EnableSsl\": false, \"Login\": \"test@sendgrid.net\", \"Password\": \"qwerty\" }","title":"How to customize email sending via SMTP"},{"location":"Email-sending-settings/#how-to-customize-email-sending-via-sendgrids-api","text":"Set Gateway is SendGrid Notifications options in Appsettings.json or Azure Then fill apikey in SendGrid options looks like this in appsetting.json : json \"SendGrid\": { \"ApiKey\": \"testapikey\" } or in Azure : * Notifications:SendGrid:ApiKey set testapikey NOTE: Also you could check the emailing-services in IntegrationTests here","title":"How to customize email sending via SendGrid's API"},{"location":"Generating%20pdf-file/","text":"Pdf-file creation support Steps to add support for pdf-file generation Download and install the recommended html to pdf conversion tool: WkHtmlToPdf from this Choose right package, depending on your operating system. Check process start settings, for example VirtoCommerce.OrdersModule.Tests.ProcessHelperIntegrationTests : WorkingDirectory Arguments Starting of the conversion tool process: like that: cmd \"c:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf\" --dpi 300 --page-size A4 --encoding \"utf-8\" --viewport-size \"1920x1080\" input.html output.pdf for details, look at manual Working with the Azure coming soon..","title":"Pdf-file creation support"},{"location":"Generating%20pdf-file/#pdf-file-creation-support","text":"","title":"Pdf-file creation support"},{"location":"Generating%20pdf-file/#steps-to-add-support-for-pdf-file-generation","text":"Download and install the recommended html to pdf conversion tool: WkHtmlToPdf from this Choose right package, depending on your operating system. Check process start settings, for example VirtoCommerce.OrdersModule.Tests.ProcessHelperIntegrationTests : WorkingDirectory Arguments Starting of the conversion tool process: like that: cmd \"c:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf\" --dpi 300 --page-size A4 --encoding \"utf-8\" --viewport-size \"1920x1080\" input.html output.pdf for details, look at manual Working with the Azure coming soon..","title":"Steps to add support for pdf-file generation"},{"location":"Implementing-authorization-mechanism-using-JWT/","text":"# Implementing authorization mechanism using Json Web Tokens In our platform we use JWT tokens mechanism by using OAuth2 protocol. Password, RefreshToken and ClientCredentials flow are supported. Tokens issued by platform are signed with the private key. For tokens validations it is possibile to use public certificate or Authority URL. Paths to certificates and Authority URL are specified in section Auth in appsetting.json file. Example of creation self-signed certificates for signature and validation of tokens using OpenSSL Generation of private key openssl.exe genpkey -outform PEM -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -pass file:certpass.txt -des3 -out virtocommerce.key - In certpass.txt file you should specify a password for the private key (the system will not work if the key file is not protected with password) Generation of certificate openssl.exe req -x509 -nodes -days 3650 -key virtocommerce.key -config certconfig.txt -extensions req_ext -passin file:certpass.txt -out virtocommerce.crt Example of certconfig.txt file [ req ] default_md = sha256 prompt = no req_extensions = req_ext distinguished_name = req_distinguished_name [ req_distinguished_name ] commonName = virtocommerce.com countryName = RU stateOrProvinceName = Kaliningrad organizationName = Virtocommerce [ req_ext ] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer keyUsage = critical,digitalSignature,keyEncipherment extendedKeyUsage = critical,serverAuth,clientAuth subjectAltName = @alt_names [ alt_names ] DNS.0 = virtocommerce.com Creation of pfx container for private key and certificate openssl.exe pkcs12 -export -out virtocommerce.pfx -inkey virtocommerce.key -in virtocommerce.crt - The system does not accept private keys smaller than 2048 Bits OAuth2 Authorization using Client credential flow How to add new client In order to authorize client applications (for example, Storefront), it is possible to use the Client credential flow mechanism of OAuth2 protocol. - Go to blade OAuth applications in Security menu and create new application using Add button. This will automatically generate Client Id and Client secret , which should be saved, as system will not allow you to view already saved Client secret . Once all fields are filled in you should click Ok and a new OAuth2 client will be created. Note: You can change Client Id and Client secret only in the process of creation of new application (you will not be able to change them in future). You can also specify Display Name for more information. Then the client application will be able to authorize requests to the Api using the previously created Client Id and Client secret . For example, in Storefront, all you need to do is specify the Client Id , Client secret created earlier, and also specify the authorization server in the Endpoint section of the appsettings.json file.","title":"Implementing authorization mechanism using Json Web Tokens"},{"location":"Implementing-authorization-mechanism-using-JWT/#example-of-creation-self-signed-certificates-for-signature-and-validation-of-tokens-using-openssl","text":"","title":"Example of creation self-signed certificates for signature and validation of tokens using OpenSSL"},{"location":"Implementing-authorization-mechanism-using-JWT/#generation-of-private-key","text":"openssl.exe genpkey -outform PEM -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -pass file:certpass.txt -des3 -out virtocommerce.key - In certpass.txt file you should specify a password for the private key (the system will not work if the key file is not protected with password)","title":"Generation of private key"},{"location":"Implementing-authorization-mechanism-using-JWT/#generation-of-certificate","text":"openssl.exe req -x509 -nodes -days 3650 -key virtocommerce.key -config certconfig.txt -extensions req_ext -passin file:certpass.txt -out virtocommerce.crt","title":"Generation of certificate"},{"location":"Implementing-authorization-mechanism-using-JWT/#example-of-certconfigtxt-file","text":"[ req ] default_md = sha256 prompt = no req_extensions = req_ext distinguished_name = req_distinguished_name [ req_distinguished_name ] commonName = virtocommerce.com countryName = RU stateOrProvinceName = Kaliningrad organizationName = Virtocommerce [ req_ext ] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer keyUsage = critical,digitalSignature,keyEncipherment extendedKeyUsage = critical,serverAuth,clientAuth subjectAltName = @alt_names [ alt_names ] DNS.0 = virtocommerce.com","title":"Example of certconfig.txt file"},{"location":"Implementing-authorization-mechanism-using-JWT/#creation-of-pfx-container-for-private-key-and-certificate","text":"openssl.exe pkcs12 -export -out virtocommerce.pfx -inkey virtocommerce.key -in virtocommerce.crt - The system does not accept private keys smaller than 2048 Bits","title":"Creation of pfx container for private key and certificate"},{"location":"Implementing-authorization-mechanism-using-JWT/#oauth2-authorization-using-client-credential-flow","text":"","title":"OAuth2 Authorization using Client credential flow"},{"location":"Implementing-authorization-mechanism-using-JWT/#how-to-add-new-client","text":"In order to authorize client applications (for example, Storefront), it is possible to use the Client credential flow mechanism of OAuth2 protocol. - Go to blade OAuth applications in Security menu and create new application using Add button. This will automatically generate Client Id and Client secret , which should be saved, as system will not allow you to view already saved Client secret . Once all fields are filled in you should click Ok and a new OAuth2 client will be created. Note: You can change Client Id and Client secret only in the process of creation of new application (you will not be able to change them in future). You can also specify Display Name for more information. Then the client application will be able to authorize requests to the Api using the previously created Client Id and Client secret . For example, in Storefront, all you need to do is specify the Client Id , Client secret created earlier, and also specify the authorization server in the Endpoint section of the appsettings.json file.","title":"How to add new client"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/","text":"Update VC Platform Module from version 2.x to version 3 Introduction This article describes how to update an existing CustomerReviews sample module from VC Platform version 2.x to 3.0. NOTE: A sample module source code can be found here: https://github.com/VirtoCommerce/vc-samples/tree/release/3.0.0/CustomerReviews. 0. Before the update Only update from the latest VC v2.x versions is supported. Ensure that the latest v2 versions of the Platform and all modules are installed. Usually, you have more than one custom VC module. Create a dependency map between your and the VC modules before the update . That helps to update the modules smoothly. Ensure that all your unit tests are current and passing In case of any question or issue, submit a new topic to Virto Commerce Community Please read the The list of code breaking changes included in 3.0 1. Prerequisites Visual Studio 2019 (v16.4 or later) 2. Make correct structure in solution and projects Open the folder of selected v2 module in file manager (e.g., Windows Explorer). If exists, delete packages folder. Delete Properties folder from each of the projects' folder. Convert the projects from ASP.NET to ASP.NET Core: Open *.csproj file of CustomerReviews.Web project in text editor (e.g., Notepad), clear whole file content and set it to this: ```xml <Project Sdk= \"Microsoft.NET.Sdk.Web\" > <PropertyGroup> <TargetFramework> netcoreapp3.1 </TargetFramework> <OutputType> Library </OutputType> </PropertyGroup> <ItemGroup> <Compile Remove= \"dist\\**\" /> <EmbeddedResource Remove= \"dist\\**\" /> <None Remove= \"dist\\**\" /> </ItemGroup> </Project> ``` Replace all other *.csproj files' content with this: ```xml <Project Sdk= \"Microsoft.NET.Sdk\" > <PropertyGroup> <TargetFramework> netcoreapp3.1 </TargetFramework> </PropertyGroup> </Project> ``` Read this article for more info. Create src and tests subfolders in module's root folder (Windows Explorer) Move CustomerReviews.Core , CustomerReviews.Data , CustomerReviews.Web projects to src Move CustomerReviews.Test project to tests Open CustomerReviews.sln solution in Visual Studio Remove all projects from the solution Add src and tests Solution Folders Add the existing CustomerReviews.Core , CustomerReviews.Data , CustomerReviews.Web projects to src folder Add the existing CustomerReviews.Test project to tests folder Remove all files related to .NET Framework 4.x in every project : App.config packages.config Web.config , Web.Debug.config , Web.Release.config , module.ignore if exists, delete CommonAssemblyInfo.cs Add references to projects: CustomerReviews.Data : add reference to CustomerReviews.Core project CustomerReviews.Web : add references to CustomerReviews.Core, CustomerReviews.Data projects CustomerReviews.Tests : add references to CustomerReviews.Core, CustomerReviews.Data, CustomerReviews.Web projects References to NuGet packages: CustomerReviews.Core : add reference to the latest version VirtoCommerce.Platform.Core package. CustomerReviews.Data : add reference to the latest version VirtoCommerce.Platform.Data package. Add other NuGet dependency packages, if any exists in module.manifest . 3. Make changes in CustomerReviews.Core project If missing, add class ModuleConstants.cs for module constants: Inside ModuleConstants add sub-classes Security and Permissions Add sub-classes Settings and General containing settings' definitions of type SettingDescriptor . Move settings definitions from module.manifest to this class > Follow the structure as defined in ModuleConstants.cs in CustomerModule . Other constants. Update ICustomerReviewService.cs : Refactor all methods to be asynchronous : return Task<> Rename all methods to have suffix Async If there is a search service defined: Move CustomerReviewSearchCriteria class to Search sub-folder; Ensure, that CustomerReviewSearchCriteria inherits from SearchCriteriaBase ; Create CustomerReviewSearchResult class in Search sub-folder; Ensure, that CustomerReviewSearchResult inherits from GenericSearchResult<CustomerReview> . Refactor ICustomerReviewSearchService to use CustomerReviewSearchResult, all methods be asynchronous, and end with Async : cs public interface ICustomerReviewSearchService { Task<CustomerReviewSearchResult> SearchCustomerReviewsAsync(CustomerReviewSearchCriteria criteria); } If any model-related changing/changed events were defined in Events folder, ensure that each of them derive from the base GenericChangedEntryEvent class. If any custom Notifications were added to Notifications folder: Add reference to NuGet VirtoCommerce.NotificationsModule.Core package; Ensure that each defined Notification class inherits from EmailNotification / SmsNotification or own class, based on Notification . 4. Make changes in CustomerReviews.Data project Repositories folder Create CustomerReviewsDbContext.cs Add new class CustomerReviewsDbContext Make it public and derive from DbContextWithTriggers Add 2 constructors, using CustomerDbContext as an example. NOTE: 1 constructor is public and another is protected . Override OnModelCreating method, add CustomerReviewEntity mapping to modelBuilder and set max length to Id: cs modelBuilder.Entity<CustomerReviewEntity>().ToTable(\"CustomerReview\").HasKey(x => x.Id); modelBuilder.Entity<CustomerReviewEntity>().Property(x => x.Id).HasMaxLength(128).ValueGeneratedOnAdd(); Create DesignTimeDbContextFactory.cs > NOTE: a factory for creating derived Microsoft.EntityFrameworkCore.DbContext instances. Add new class DesignTimeDbContextFactory Make it public and derive from IDesignTimeDbContextFactory<CustomerReviewsDbContext> Implement CreateDbContext method, using CustomerModule.Data/Repositories/DesignTimeDbContextFactory.cs as an example Ensure that connection string to your development SQL Server in UseSqlServer method is correct. It would be used while generating code-first migrations. Update ICustomerReviewsRepository.cs If the module is an extension then derive from derived module's interface repository. Refactor all methods to be asynchronous : return Task<> Rename all methods to have suffix Async Update CustomerReviewsRepository.cs Refactor CustomerReviewsRepository class to derive from DbContextRepositoryBase<CustomerReviewsDbContext> or if the module is an extension then derive from derived module's repository. Refactor the constructors to leave only one, taking the only CustomerReviewsDbContext parameter: cs public CustomerReviewRepository(CustomerReviewsDbContext dbContext) : base(dbContext) { } Refactor CustomerReviews property to access data using DbSet like this: cs public IQueryable<CustomerReviewEntity> CustomerReviews => DbContext.Set<CustomerReviewEntity>(); Remove OnModelCreating method Caching folder If missing, create Caching folder. This folder is for the cache region classes. Typically, each model should have its own region. Derive CacheRegion from generic CancellableCacheRegion<T> class: cs public class CustomerReviewCacheRegion : CancellableCacheRegion<CustomerReviewCacheRegion> { } Services folder All services: remove inheritance from ServiceBase Ensure that the signatures of the methods matches the ones defined in the corresponding interfaces Change response to Task<CustomerReviewSearchResult> in CustomerReviewSearchService service Refactor all methods to be asynchronous Add working with cache to all methods check this example for more details VirtoCommerce.CustomerModule.Data.Services . Migrations folder Create InitialCustomerReviews migration Delete everything (all migrations and Configuration.cs) from Migrations folder Execute \" Set as Startup Project \" on CustomerReviews. Data project in Solution Explorer Open NuGet Package Manager Console Select \"src\\CustomerReviews. Data \" as \" Default project \" Run command: console Add-Migration InitialCustomerReviews -Verbose In case of any existing module's extension is developed, study and follow the steps from How to extend the DB model of VC module guide. Create Migration for backward compatibility with v2.x Add new migration with name UpdateCustomerReviewsV2 and rename the migration filename to 20000000000000_UpdateCustomerReviewsV2 Add SQL command to the migration: cs migrationBuilder.Sql(@\"IF (EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '__MigrationHistory')) IF (EXISTS (SELECT * FROM __MigrationHistory WHERE ContextKey = 'CustomerReviews.Data.Migrations.Configuration')) BEGIN INSERT INTO [dbo].[__EFMigrationsHistory] ([MigrationId],[ProductVersion]) VALUES ('20191129134041_InitialCustomerReviews', '2.2.3-servicing-35854') END\"); Note: the ContextKey value has to be constructed as \"{ModuleId}.Data.Migrations.Configuration\". Note2: the value for MigrationId has to be the name of your new migration, added in previous step. ('20191129134041_InitialCustomerReviews' in our case). Check 20000000000000_UpdateCoreV2.cs migration as another example. Note3: value for ProductVersion should be taken from 20000000000000_UpdateCustomerReviewsV2.Designer line 19: cs .HasAnnotation(\"ProductVersion\", \"2.2.3-servicing-35854\") Open 20000000000000_UpdateCustomerReviewsV2.Designer and change Migration attribute parameter value to the current migration ID (\"20000000000000_UpdateCustomerReviewsV2\" in this case). Check 20000000000000_UpdateCoreV2.Designer.cs as another example. If Dynamic Properties are used in the module, follow the steps in Dynamic Property guide . 5. Make changes in CustomerReviews.Web project Changes in module.manifest Versioning - increase module version and add prerelease tag (empty value for a release version): xml <version>3.0.0</version> <version-tag></version-tag> Required minimal version of VC Platform: xml <platformVersion>3.0.0</platformVersion> Module dependencies - change to actual versions: xml <dependencies> <dependency id=\"VirtoCommerce.Core\" version=\"3.0.0\" /> </dependencies> Remove styles , scripts sections from the manifest file Add localizations for permissions/settings to Localizations/en.CustomerReviews.json file as this . Sample resulting keys: \"permissions.customerReview:read\" , \"settings.CustomerReviews.CustomerReviewsEnabled.title\" . Remove permissions , settings definitions sections from the manifest file Changes in Module.cs Change the class inheritance to interface IModule , then add implementation methods: Initialize, PostInitialize, Uninstall and property ModuleInfo . Check VirtoCommerce.CustomerModule.Web/Module.cs for another implementation example. Read the Dependency injection in ASP.NET Core article for additional info. Register all the needed classes for dependency injection inside Initialize method, like CustomerReviewDbContext, CustomerReviewRepository , etc. Register settings using interface ISettingsRegistrar in PostInitialize method: cs var settingsRegistrar = appBuilder.ApplicationServices.GetRequiredService<ISettingsRegistrar>(); settingsRegistrar.RegisterSettings(ModuleConstants.Settings.AllSettings, ModuleInfo.Id); Register permissions using interface IPermissionsRegistrar in PostInitialize method: cs var permissionsProvider = appBuilder.ApplicationServices.GetRequiredService<IPermissionsRegistrar>(); permissionsProvider.RegisterPermissions(ModuleConstants.Security.Permissions.AllPermissions.Select(x => new Permission() { GroupName = \"CustomerReview\", Name = x }).ToArray()); Add this code into PostInitialize method, needed to ensure that the migrations would be applied: cs using (var serviceScope = appBuilder.ApplicationServices.CreateScope()) { var dbContext = serviceScope.ServiceProvider.GetRequiredService<CustomerReviewsDbContext>(); dbContext.Database.MigrateIfNotApplied(MigrationName.GetUpdateV2MigrationNameByOwnerName(ModuleInfo.Id, <<your company prefix in moduleId>>)); dbContext.Database.EnsureCreated(); dbContext.Database.Migrate(); } NOTE: The MigrateIfNotApplied extension method is needed for the database backward compatibility with version 2.x. This extension enables to skip generating the initial migration, as there are changes (tables, indexes) in the database already. Changes to all API Controller(s) in Controllers/Api folder: Refactor controllers to derive from Microsoft.AspNetCore.Mvc. Controller . Change RoutePrefix attribute to Route for all endpoints Remove ResponseType attribute from all endpoints Change CheckPermission attribute to Authorize for all endpoints If the endpoint should have a restricted access, an Authorize attribute with the required permission should be added. Use the ModuleConstants class, which was previously defined in CustomerReviews.Core project. Review the exposed endpoints and refactor to be asynchronous (return async Task<> ), if needed Mark each complex type parameter with [FromBody] attribute for all endpoints. The attribute for Delete endpoint should be [FromQuery] . E.g., SearchCustomerReviews method converted to ASP.NET Core MVC: cs [HttpPost] [Route(\"search\")] [Authorize(ModuleConstants.Security.Permissions.Read)] public async Task<ActionResult<CustomerReviewSearchResult>> SearchCustomerReviews([FromBody]CustomerReviewSearchCriteria criteria) Read Controller action return types in ASP.NET Core web API for more info. 4. If there are any JavaScript or stylesheet files in the project: 1. Copy package.json from sample package.json ; 2. Copy webpack.config.js from sample webpack.config.js ; 3. Change the namespace on line 36 in webpack.config.js to be equal to module's identifier: js namespace: 'CustomerReviews' Open Command prompt and navigate to CustomerReviews.Web folder: Run npm install Run npm run webpack:dev Note: fix any css errors, of the previous command would fail. For CustomerReviews sample also change line 12 in webpack.config.js to: js ...glob.sync('./Content/css/*.css', { nosort: true }) Add dist/ line to .gitignore file Add node_modules/ line to .gitignore file. 6. Make changes in CustomerReviews.Tests project Reference the required NuGet packages by adding this ItemGroup to project file: xml <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"16.4.0\" /> <PackageReference Include=\"Moq\" Version=\"4.13.1\" /> <PackageReference Include=\"MSTest.TestAdapter\" Version=\"2.0.0\" /> <PackageReference Include=\"MSTest.TestFramework\" Version=\"2.0.0\" /> <PackageReference Include=\"xunit\" Version=\"2.4.1\" /> <PackageReference Include=\"xunit.runner.console\" Version=\"2.4.1\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets> </PackageReference> <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.1\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets> </PackageReference> <DotNetCliToolReference Include=\"dotnet-xunit\" Version=\"2.3.1\" /> </ItemGroup> Add TestAsyncQueryProvider class under Common folder. Paste the class implementation from here . Remove inheritance from FunctionalTestBase for each tests class. Add the integration tests under IntegrationTests folder. Ensure, that each integration tests class is marked with this Trait attribute: cs [Trait(\"Category\", \"IntegrationTest\")] 7. Create module package Please, read the article about VirtoCommerce.GlobalTool .","title":"Update VC Platform Module from version 2.x to version 3"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#update-vc-platform-module-from-version-2x-to-version-3","text":"","title":"Update VC Platform Module from version 2.x to version 3"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#introduction","text":"This article describes how to update an existing CustomerReviews sample module from VC Platform version 2.x to 3.0. NOTE: A sample module source code can be found here: https://github.com/VirtoCommerce/vc-samples/tree/release/3.0.0/CustomerReviews.","title":"Introduction"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#0-before-the-update","text":"Only update from the latest VC v2.x versions is supported. Ensure that the latest v2 versions of the Platform and all modules are installed. Usually, you have more than one custom VC module. Create a dependency map between your and the VC modules before the update . That helps to update the modules smoothly. Ensure that all your unit tests are current and passing In case of any question or issue, submit a new topic to Virto Commerce Community Please read the The list of code breaking changes included in 3.0","title":"0. Before the update"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#1-prerequisites","text":"Visual Studio 2019 (v16.4 or later)","title":"1. Prerequisites"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#2-make-correct-structure-in-solution-and-projects","text":"Open the folder of selected v2 module in file manager (e.g., Windows Explorer). If exists, delete packages folder. Delete Properties folder from each of the projects' folder. Convert the projects from ASP.NET to ASP.NET Core: Open *.csproj file of CustomerReviews.Web project in text editor (e.g., Notepad), clear whole file content and set it to this: ```xml <Project Sdk= \"Microsoft.NET.Sdk.Web\" > <PropertyGroup> <TargetFramework> netcoreapp3.1 </TargetFramework> <OutputType> Library </OutputType> </PropertyGroup> <ItemGroup> <Compile Remove= \"dist\\**\" /> <EmbeddedResource Remove= \"dist\\**\" /> <None Remove= \"dist\\**\" /> </ItemGroup> </Project> ``` Replace all other *.csproj files' content with this: ```xml <Project Sdk= \"Microsoft.NET.Sdk\" > <PropertyGroup> <TargetFramework> netcoreapp3.1 </TargetFramework> </PropertyGroup> </Project> ``` Read this article for more info. Create src and tests subfolders in module's root folder (Windows Explorer) Move CustomerReviews.Core , CustomerReviews.Data , CustomerReviews.Web projects to src Move CustomerReviews.Test project to tests Open CustomerReviews.sln solution in Visual Studio Remove all projects from the solution Add src and tests Solution Folders Add the existing CustomerReviews.Core , CustomerReviews.Data , CustomerReviews.Web projects to src folder Add the existing CustomerReviews.Test project to tests folder Remove all files related to .NET Framework 4.x in every project : App.config packages.config Web.config , Web.Debug.config , Web.Release.config , module.ignore if exists, delete CommonAssemblyInfo.cs Add references to projects: CustomerReviews.Data : add reference to CustomerReviews.Core project CustomerReviews.Web : add references to CustomerReviews.Core, CustomerReviews.Data projects CustomerReviews.Tests : add references to CustomerReviews.Core, CustomerReviews.Data, CustomerReviews.Web projects References to NuGet packages: CustomerReviews.Core : add reference to the latest version VirtoCommerce.Platform.Core package. CustomerReviews.Data : add reference to the latest version VirtoCommerce.Platform.Data package. Add other NuGet dependency packages, if any exists in module.manifest .","title":"2. Make correct structure in solution and projects"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#3-make-changes-in-customerreviewscore-project","text":"If missing, add class ModuleConstants.cs for module constants: Inside ModuleConstants add sub-classes Security and Permissions Add sub-classes Settings and General containing settings' definitions of type SettingDescriptor . Move settings definitions from module.manifest to this class > Follow the structure as defined in ModuleConstants.cs in CustomerModule . Other constants. Update ICustomerReviewService.cs : Refactor all methods to be asynchronous : return Task<> Rename all methods to have suffix Async If there is a search service defined: Move CustomerReviewSearchCriteria class to Search sub-folder; Ensure, that CustomerReviewSearchCriteria inherits from SearchCriteriaBase ; Create CustomerReviewSearchResult class in Search sub-folder; Ensure, that CustomerReviewSearchResult inherits from GenericSearchResult<CustomerReview> . Refactor ICustomerReviewSearchService to use CustomerReviewSearchResult, all methods be asynchronous, and end with Async : cs public interface ICustomerReviewSearchService { Task<CustomerReviewSearchResult> SearchCustomerReviewsAsync(CustomerReviewSearchCriteria criteria); } If any model-related changing/changed events were defined in Events folder, ensure that each of them derive from the base GenericChangedEntryEvent class. If any custom Notifications were added to Notifications folder: Add reference to NuGet VirtoCommerce.NotificationsModule.Core package; Ensure that each defined Notification class inherits from EmailNotification / SmsNotification or own class, based on Notification .","title":"3. Make changes in CustomerReviews.Core project"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#4-make-changes-in-customerreviewsdata-project","text":"Repositories folder Create CustomerReviewsDbContext.cs Add new class CustomerReviewsDbContext Make it public and derive from DbContextWithTriggers Add 2 constructors, using CustomerDbContext as an example. NOTE: 1 constructor is public and another is protected . Override OnModelCreating method, add CustomerReviewEntity mapping to modelBuilder and set max length to Id: cs modelBuilder.Entity<CustomerReviewEntity>().ToTable(\"CustomerReview\").HasKey(x => x.Id); modelBuilder.Entity<CustomerReviewEntity>().Property(x => x.Id).HasMaxLength(128).ValueGeneratedOnAdd(); Create DesignTimeDbContextFactory.cs > NOTE: a factory for creating derived Microsoft.EntityFrameworkCore.DbContext instances. Add new class DesignTimeDbContextFactory Make it public and derive from IDesignTimeDbContextFactory<CustomerReviewsDbContext> Implement CreateDbContext method, using CustomerModule.Data/Repositories/DesignTimeDbContextFactory.cs as an example Ensure that connection string to your development SQL Server in UseSqlServer method is correct. It would be used while generating code-first migrations. Update ICustomerReviewsRepository.cs If the module is an extension then derive from derived module's interface repository. Refactor all methods to be asynchronous : return Task<> Rename all methods to have suffix Async Update CustomerReviewsRepository.cs Refactor CustomerReviewsRepository class to derive from DbContextRepositoryBase<CustomerReviewsDbContext> or if the module is an extension then derive from derived module's repository. Refactor the constructors to leave only one, taking the only CustomerReviewsDbContext parameter: cs public CustomerReviewRepository(CustomerReviewsDbContext dbContext) : base(dbContext) { } Refactor CustomerReviews property to access data using DbSet like this: cs public IQueryable<CustomerReviewEntity> CustomerReviews => DbContext.Set<CustomerReviewEntity>(); Remove OnModelCreating method Caching folder If missing, create Caching folder. This folder is for the cache region classes. Typically, each model should have its own region. Derive CacheRegion from generic CancellableCacheRegion<T> class: cs public class CustomerReviewCacheRegion : CancellableCacheRegion<CustomerReviewCacheRegion> { } Services folder All services: remove inheritance from ServiceBase Ensure that the signatures of the methods matches the ones defined in the corresponding interfaces Change response to Task<CustomerReviewSearchResult> in CustomerReviewSearchService service Refactor all methods to be asynchronous Add working with cache to all methods check this example for more details VirtoCommerce.CustomerModule.Data.Services . Migrations folder Create InitialCustomerReviews migration Delete everything (all migrations and Configuration.cs) from Migrations folder Execute \" Set as Startup Project \" on CustomerReviews. Data project in Solution Explorer Open NuGet Package Manager Console Select \"src\\CustomerReviews. Data \" as \" Default project \" Run command: console Add-Migration InitialCustomerReviews -Verbose In case of any existing module's extension is developed, study and follow the steps from How to extend the DB model of VC module guide. Create Migration for backward compatibility with v2.x Add new migration with name UpdateCustomerReviewsV2 and rename the migration filename to 20000000000000_UpdateCustomerReviewsV2 Add SQL command to the migration: cs migrationBuilder.Sql(@\"IF (EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '__MigrationHistory')) IF (EXISTS (SELECT * FROM __MigrationHistory WHERE ContextKey = 'CustomerReviews.Data.Migrations.Configuration')) BEGIN INSERT INTO [dbo].[__EFMigrationsHistory] ([MigrationId],[ProductVersion]) VALUES ('20191129134041_InitialCustomerReviews', '2.2.3-servicing-35854') END\"); Note: the ContextKey value has to be constructed as \"{ModuleId}.Data.Migrations.Configuration\". Note2: the value for MigrationId has to be the name of your new migration, added in previous step. ('20191129134041_InitialCustomerReviews' in our case). Check 20000000000000_UpdateCoreV2.cs migration as another example. Note3: value for ProductVersion should be taken from 20000000000000_UpdateCustomerReviewsV2.Designer line 19: cs .HasAnnotation(\"ProductVersion\", \"2.2.3-servicing-35854\") Open 20000000000000_UpdateCustomerReviewsV2.Designer and change Migration attribute parameter value to the current migration ID (\"20000000000000_UpdateCustomerReviewsV2\" in this case). Check 20000000000000_UpdateCoreV2.Designer.cs as another example. If Dynamic Properties are used in the module, follow the steps in Dynamic Property guide .","title":"4. Make changes in CustomerReviews.Data project"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#5-make-changes-in-customerreviewsweb-project","text":"Changes in module.manifest Versioning - increase module version and add prerelease tag (empty value for a release version): xml <version>3.0.0</version> <version-tag></version-tag> Required minimal version of VC Platform: xml <platformVersion>3.0.0</platformVersion> Module dependencies - change to actual versions: xml <dependencies> <dependency id=\"VirtoCommerce.Core\" version=\"3.0.0\" /> </dependencies> Remove styles , scripts sections from the manifest file Add localizations for permissions/settings to Localizations/en.CustomerReviews.json file as this . Sample resulting keys: \"permissions.customerReview:read\" , \"settings.CustomerReviews.CustomerReviewsEnabled.title\" . Remove permissions , settings definitions sections from the manifest file Changes in Module.cs Change the class inheritance to interface IModule , then add implementation methods: Initialize, PostInitialize, Uninstall and property ModuleInfo . Check VirtoCommerce.CustomerModule.Web/Module.cs for another implementation example. Read the Dependency injection in ASP.NET Core article for additional info. Register all the needed classes for dependency injection inside Initialize method, like CustomerReviewDbContext, CustomerReviewRepository , etc. Register settings using interface ISettingsRegistrar in PostInitialize method: cs var settingsRegistrar = appBuilder.ApplicationServices.GetRequiredService<ISettingsRegistrar>(); settingsRegistrar.RegisterSettings(ModuleConstants.Settings.AllSettings, ModuleInfo.Id); Register permissions using interface IPermissionsRegistrar in PostInitialize method: cs var permissionsProvider = appBuilder.ApplicationServices.GetRequiredService<IPermissionsRegistrar>(); permissionsProvider.RegisterPermissions(ModuleConstants.Security.Permissions.AllPermissions.Select(x => new Permission() { GroupName = \"CustomerReview\", Name = x }).ToArray()); Add this code into PostInitialize method, needed to ensure that the migrations would be applied: cs using (var serviceScope = appBuilder.ApplicationServices.CreateScope()) { var dbContext = serviceScope.ServiceProvider.GetRequiredService<CustomerReviewsDbContext>(); dbContext.Database.MigrateIfNotApplied(MigrationName.GetUpdateV2MigrationNameByOwnerName(ModuleInfo.Id, <<your company prefix in moduleId>>)); dbContext.Database.EnsureCreated(); dbContext.Database.Migrate(); } NOTE: The MigrateIfNotApplied extension method is needed for the database backward compatibility with version 2.x. This extension enables to skip generating the initial migration, as there are changes (tables, indexes) in the database already. Changes to all API Controller(s) in Controllers/Api folder: Refactor controllers to derive from Microsoft.AspNetCore.Mvc. Controller . Change RoutePrefix attribute to Route for all endpoints Remove ResponseType attribute from all endpoints Change CheckPermission attribute to Authorize for all endpoints If the endpoint should have a restricted access, an Authorize attribute with the required permission should be added. Use the ModuleConstants class, which was previously defined in CustomerReviews.Core project. Review the exposed endpoints and refactor to be asynchronous (return async Task<> ), if needed Mark each complex type parameter with [FromBody] attribute for all endpoints. The attribute for Delete endpoint should be [FromQuery] . E.g., SearchCustomerReviews method converted to ASP.NET Core MVC: cs [HttpPost] [Route(\"search\")] [Authorize(ModuleConstants.Security.Permissions.Read)] public async Task<ActionResult<CustomerReviewSearchResult>> SearchCustomerReviews([FromBody]CustomerReviewSearchCriteria criteria) Read Controller action return types in ASP.NET Core web API for more info. 4. If there are any JavaScript or stylesheet files in the project: 1. Copy package.json from sample package.json ; 2. Copy webpack.config.js from sample webpack.config.js ; 3. Change the namespace on line 36 in webpack.config.js to be equal to module's identifier: js namespace: 'CustomerReviews' Open Command prompt and navigate to CustomerReviews.Web folder: Run npm install Run npm run webpack:dev Note: fix any css errors, of the previous command would fail. For CustomerReviews sample also change line 12 in webpack.config.js to: js ...glob.sync('./Content/css/*.css', { nosort: true }) Add dist/ line to .gitignore file Add node_modules/ line to .gitignore file.","title":"5. Make changes in CustomerReviews&#46;Web project"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#6-make-changes-in-customerreviewstests-project","text":"Reference the required NuGet packages by adding this ItemGroup to project file: xml <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"16.4.0\" /> <PackageReference Include=\"Moq\" Version=\"4.13.1\" /> <PackageReference Include=\"MSTest.TestAdapter\" Version=\"2.0.0\" /> <PackageReference Include=\"MSTest.TestFramework\" Version=\"2.0.0\" /> <PackageReference Include=\"xunit\" Version=\"2.4.1\" /> <PackageReference Include=\"xunit.runner.console\" Version=\"2.4.1\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets> </PackageReference> <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.1\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets> </PackageReference> <DotNetCliToolReference Include=\"dotnet-xunit\" Version=\"2.3.1\" /> </ItemGroup> Add TestAsyncQueryProvider class under Common folder. Paste the class implementation from here . Remove inheritance from FunctionalTestBase for each tests class. Add the integration tests under IntegrationTests folder. Ensure, that each integration tests class is marked with this Trait attribute: cs [Trait(\"Category\", \"IntegrationTest\")]","title":"6. Make changes in CustomerReviews.Tests project"},{"location":"Migrate-module-from-the-Platform-2.0-to-3.0-version/#7-create-module-package","text":"Please, read the article about VirtoCommerce.GlobalTool .","title":"7. Create module package"},{"location":"about/","text":"Wefwe dfvdv this is about page - Lesson 2 - How to import new products into Virto Commerce catalog : lessons / lesson1 . md - Lesson 3 - How to create Virto commerce module ( API ): lessons / lesson1 . md - Lesson 4 - How to build and customize platform manager Web UI ( AngularJS ): lessons / lesson1 . md","title":"Wefwe dfvdv"},{"location":"about/#wefwe-dfvdv","text":"this is about page - Lesson 2 - How to import new products into Virto Commerce catalog : lessons / lesson1 . md - Lesson 3 - How to create Virto commerce module ( API ): lessons / lesson1 . md - Lesson 4 - How to build and customize platform manager Web UI ( AngularJS ): lessons / lesson1 . md","title":"Wefwe dfvdv"},{"location":"code-breaking-changes-included-in-v3/","text":"Breaking changes included in VirtoCommerce 3.0 There were major refactorings made in VirtoCommerce version 3.0. The changes mapping below should help you finding the right class, API or behavior in the updated codebase. V2 V3 Impact vc-platform ISecurityService Removed. Need to use UserManager<> from ASP.NET Core Identity instead. Link to code example Low IRoleManagementService Removed. Need to use RoleManager<> from ASP.NET Core Identity instead. Link to code example Low ConfigurationHelper Removed. Now, for all env configuration need to use ASP .NET Core Configuration Link to code example Low ISettingsManager.GetValue GetValue method moved to SettingsExtension and now load setting values only from db Link to code example , before it tried to load a setting value from env configuration first High EFRepositoryBase Renamed to DbContextRepositoryBase and now not derived from DbContext and received DbContext as an argument of ctor. Link to code example Low RepositoryExtension.DisableChangesTracking Has no effect. Need to use AsNoTracking(). Tracking vs. No-Tracking Queries and Link to code example High AuditableInterceptor Removed. All types inherited from AuditableEntity are automatically update their audit fields when save. You have to inherit your DbContext from DbContextWithTriggers . The magic happens here ApplicationBuilderExtensions.cs and Link to code example Medium EntityPrimaryKeyGeneratorInterceptor Removed. Now is using EF Core - Value generated on add or update and Link to code example High ChangeLogInterceptor Removed. Need to use domain event handlers for explicit log changes. Link to code example High ICacheManager<object> Removed. Need to use IPlatformMemoryCache instead. Link to code example High IDynamicPropertyService Reworked. Divided into these abstractions IDynamicPropertyService , IDynamicPropertyRegistrar , IDynamicPropertyDictionaryItemsService , IDynamicPropertyDictionaryItemsSearchService .Also, have made the significant changes with persistent infrastructure Link to docs and code sample Medium Implicit dynamic properties declaration Changed to explicit registration by IDynamicPropertyRegistrar . See code example High IChangeLogService Divided into two IChangeLogService.cs and IChangeLogSearchService.cs High IExpressionSerializer Removed. The XML serialized expressions no longer used and are replaced with serialized as json and run as managed code predicates. Link to code sample Low INotificationManager Moved into separate module. vc-module-notification . (TODO: documentation) Medium IModule The all methods signatures were changed. IModule.cs High module.manifest The settings and permissions declarations were removed from module.manifest and are now declared in the code PlatformConstants High Implicit settings declaration Changed to explicit registration by ISettingsRegistrar . See code example High Implicit permissions declaration Changed to explicit registration by IPermissionsRegistrar . See code example High vc-module-core VirtoCommerce.Domain.Cart namespace Moved to vc-module-cart module Medium VirtoCommerce.Domain.Catalog namespace Moved to vc-module-catalog Medium VirtoCommerce.Domain.Customer namespace Moved to vc-module-customer module Medium VirtoCommerce.Domain.Inventory namespace Moved to vc-module-inventory module Medium VirtoCommerce.Domain.Marketing namespace Moved to vc-module-marketing module Medium VirtoCommerce.Domain.Order namespace Moved to vc-module-order module Medium VirtoCommerce.Domain.Payment namespace Moved to vc-module-payment module Medium VirtoCommerce.Domain.Pricing namespace Moved to vc-module-pricing module Medium VirtoCommerce.Domain.Search namespace Moved to vc-module-search module Medium VirtoCommerce.Domain.Shipping namespace Moved to vc-module-shipping module Medium VirtoCommerce.Domain.Store namespace Moved to vc-module-store module Medium VirtoCommerce.Domain.Tax namespace Moved to vc-module-tax module Medium VirtoCommerce.Domain.Commerce.Model.Search.GenericSearchResult<> Moved to VirtoCommerce.Platform.Core GenericSearchResult.cs High VirtoCommerce.Domain.Commerce.Model.Search.SearchCriteriaBase Moved to VirtoCommerce.Platform.Core SearchCriteriaBase.cs High VirtoCommerce.Domain.Commerce.Model.Currency Moved to VirtoCommerce.CoreModule.Core.Currency namespace Medium VirtoCommerce.Domain.Commerce.Model.PackageType Moved to VirtoCommerce.CoreModule.Core.Package namespace Medium VirtoCommerce.Domain.Commerce.Model.ISeoSupport Moved to VirtoCommerce.CoreModule.Core.Seo namespace Medium VirtoCommerce.Domain.Commerce.Model.ITaxable Moved to VirtoCommerce.CoreModule.Core.Tax namespace Medium VirtoCommerce.Domain.Commerce.Services.ICommerceService Removed. Distributed responsibility between these services ICurrencyService.cs vc-module-core. Work with Seo data moved into each module level vc-catalog module SeoInfoEntity.cs , vc-store-module SeoInfoEntity.cs , etc Packages moved into IPackageTypesService.cs vc-module-core Medium vc-module-catalog VirtoCommerce.Domain.Catalog.ICatalogSearchService Removed. For database search need to use the following services: IListEntrySearchService for search products and categories. IProductSearchService for products search. ICategorySearchService for categories search Medium VirtoCommerce.CatalogModule.Data.Search.ICategorySearchService Removed. For categories indexed search need to use ICategoryIndexedSearchService Medium VirtoCommerce.CatalogModule.Data.Search.IProductSearchService Removed. For products indexed search need to use IProductIndexedSearchService Medium vc-store-module Store.PaymentMethods Removed. To search payment methods need to use IPaymentMethodsSearchService and IPaymentMethodsService for CRUD operations. See DefaultManualPaymentMethod as example Medium Store.ShippingMethods Removed. To search shipping methods need to use IShippingMethodsSearchService and IShippingMethodsService for CRUD operations. See FixedRateShippingMethod as example Medium Store.TaxProviders Removed. To search tax providers need to use ITaxProviderSearchService and ITaxProviderService for CRUD operations. See FixedRateTaxProvider as example Medium IStoreService.SearchStores Moved to IStoreSearchService Low vc-module-cache Module removed. Now all cache functionality is implemented in each module level. See code example Low vc-module-dynamic-expressions Module removed. dynamic expressions and templates All dynamic expression templates expressions are moved into vc-module-core/Scripts/dynamicConditions/all-templates.html and vc-module-marketing/Scripts/dynamicConditions/all-templates.html . All dynamic expressions logic are moved into VirtoCommerce.MarketingModule.Core/Model/Promotions/Conditions Low IMarketingExtensionManager Replaced with PromotionConditionAndRewardTreePrototype (TODO: Docs how to extend expression tree) Low IPricingExtensionManager Replaced with PriceConditionTreePrototype (TODO: Docs how to extend expression tree) Low","title":"Breaking changes included in VirtoCommerce 3.0"},{"location":"code-breaking-changes-included-in-v3/#breaking-changes-included-in-virtocommerce-30","text":"There were major refactorings made in VirtoCommerce version 3.0. The changes mapping below should help you finding the right class, API or behavior in the updated codebase. V2 V3 Impact vc-platform ISecurityService Removed. Need to use UserManager<> from ASP.NET Core Identity instead. Link to code example Low IRoleManagementService Removed. Need to use RoleManager<> from ASP.NET Core Identity instead. Link to code example Low ConfigurationHelper Removed. Now, for all env configuration need to use ASP .NET Core Configuration Link to code example Low ISettingsManager.GetValue GetValue method moved to SettingsExtension and now load setting values only from db Link to code example , before it tried to load a setting value from env configuration first High EFRepositoryBase Renamed to DbContextRepositoryBase and now not derived from DbContext and received DbContext as an argument of ctor. Link to code example Low RepositoryExtension.DisableChangesTracking Has no effect. Need to use AsNoTracking(). Tracking vs. No-Tracking Queries and Link to code example High AuditableInterceptor Removed. All types inherited from AuditableEntity are automatically update their audit fields when save. You have to inherit your DbContext from DbContextWithTriggers . The magic happens here ApplicationBuilderExtensions.cs and Link to code example Medium EntityPrimaryKeyGeneratorInterceptor Removed. Now is using EF Core - Value generated on add or update and Link to code example High ChangeLogInterceptor Removed. Need to use domain event handlers for explicit log changes. Link to code example High ICacheManager<object> Removed. Need to use IPlatformMemoryCache instead. Link to code example High IDynamicPropertyService Reworked. Divided into these abstractions IDynamicPropertyService , IDynamicPropertyRegistrar , IDynamicPropertyDictionaryItemsService , IDynamicPropertyDictionaryItemsSearchService .Also, have made the significant changes with persistent infrastructure Link to docs and code sample Medium Implicit dynamic properties declaration Changed to explicit registration by IDynamicPropertyRegistrar . See code example High IChangeLogService Divided into two IChangeLogService.cs and IChangeLogSearchService.cs High IExpressionSerializer Removed. The XML serialized expressions no longer used and are replaced with serialized as json and run as managed code predicates. Link to code sample Low INotificationManager Moved into separate module. vc-module-notification . (TODO: documentation) Medium IModule The all methods signatures were changed. IModule.cs High module.manifest The settings and permissions declarations were removed from module.manifest and are now declared in the code PlatformConstants High Implicit settings declaration Changed to explicit registration by ISettingsRegistrar . See code example High Implicit permissions declaration Changed to explicit registration by IPermissionsRegistrar . See code example High vc-module-core VirtoCommerce.Domain.Cart namespace Moved to vc-module-cart module Medium VirtoCommerce.Domain.Catalog namespace Moved to vc-module-catalog Medium VirtoCommerce.Domain.Customer namespace Moved to vc-module-customer module Medium VirtoCommerce.Domain.Inventory namespace Moved to vc-module-inventory module Medium VirtoCommerce.Domain.Marketing namespace Moved to vc-module-marketing module Medium VirtoCommerce.Domain.Order namespace Moved to vc-module-order module Medium VirtoCommerce.Domain.Payment namespace Moved to vc-module-payment module Medium VirtoCommerce.Domain.Pricing namespace Moved to vc-module-pricing module Medium VirtoCommerce.Domain.Search namespace Moved to vc-module-search module Medium VirtoCommerce.Domain.Shipping namespace Moved to vc-module-shipping module Medium VirtoCommerce.Domain.Store namespace Moved to vc-module-store module Medium VirtoCommerce.Domain.Tax namespace Moved to vc-module-tax module Medium VirtoCommerce.Domain.Commerce.Model.Search.GenericSearchResult<> Moved to VirtoCommerce.Platform.Core GenericSearchResult.cs High VirtoCommerce.Domain.Commerce.Model.Search.SearchCriteriaBase Moved to VirtoCommerce.Platform.Core SearchCriteriaBase.cs High VirtoCommerce.Domain.Commerce.Model.Currency Moved to VirtoCommerce.CoreModule.Core.Currency namespace Medium VirtoCommerce.Domain.Commerce.Model.PackageType Moved to VirtoCommerce.CoreModule.Core.Package namespace Medium VirtoCommerce.Domain.Commerce.Model.ISeoSupport Moved to VirtoCommerce.CoreModule.Core.Seo namespace Medium VirtoCommerce.Domain.Commerce.Model.ITaxable Moved to VirtoCommerce.CoreModule.Core.Tax namespace Medium VirtoCommerce.Domain.Commerce.Services.ICommerceService Removed. Distributed responsibility between these services ICurrencyService.cs vc-module-core. Work with Seo data moved into each module level vc-catalog module SeoInfoEntity.cs , vc-store-module SeoInfoEntity.cs , etc Packages moved into IPackageTypesService.cs vc-module-core Medium vc-module-catalog VirtoCommerce.Domain.Catalog.ICatalogSearchService Removed. For database search need to use the following services: IListEntrySearchService for search products and categories. IProductSearchService for products search. ICategorySearchService for categories search Medium VirtoCommerce.CatalogModule.Data.Search.ICategorySearchService Removed. For categories indexed search need to use ICategoryIndexedSearchService Medium VirtoCommerce.CatalogModule.Data.Search.IProductSearchService Removed. For products indexed search need to use IProductIndexedSearchService Medium vc-store-module Store.PaymentMethods Removed. To search payment methods need to use IPaymentMethodsSearchService and IPaymentMethodsService for CRUD operations. See DefaultManualPaymentMethod as example Medium Store.ShippingMethods Removed. To search shipping methods need to use IShippingMethodsSearchService and IShippingMethodsService for CRUD operations. See FixedRateShippingMethod as example Medium Store.TaxProviders Removed. To search tax providers need to use ITaxProviderSearchService and ITaxProviderService for CRUD operations. See FixedRateTaxProvider as example Medium IStoreService.SearchStores Moved to IStoreSearchService Low vc-module-cache Module removed. Now all cache functionality is implemented in each module level. See code example Low vc-module-dynamic-expressions Module removed. dynamic expressions and templates All dynamic expression templates expressions are moved into vc-module-core/Scripts/dynamicConditions/all-templates.html and vc-module-marketing/Scripts/dynamicConditions/all-templates.html . All dynamic expressions logic are moved into VirtoCommerce.MarketingModule.Core/Model/Promotions/Conditions Low IMarketingExtensionManager Replaced with PromotionConditionAndRewardTreePrototype (TODO: Docs how to extend expression tree) Low IPricingExtensionManager Replaced with PriceConditionTreePrototype (TODO: Docs how to extend expression tree) Low","title":"Breaking changes included in VirtoCommerce 3.0"},{"location":"connect-storefront-to-platform-v3/","text":"Connect Storefront to Platform Deploy the latest storefront version as described here Note, if Platform and Storefront are deployed in the same on-premises environment, Storefront should be deployed on different port then Platform. You can do it by dotnet run CLI dotnet VirtoCommerce.Storefront.dll --urls=http://localhost:5002/ or host Storefront in IIS. Make changes in appsettings.json ... \"Endpoint\" : { //Specify platform url \"Url\" : \"https://localhost:5001\" , //Comment the follow settings // \"AppId\" : \"...\" , // \"SecretKey\" : \"...\" , //Uncomment the follow settings \"UserName\" : \"admin\" , \"Password\" : \"store\" , \"RequestTimeout\" : \"0:0:30\" } , Trust the .Net Core Development Self-Signed Certificate. More details on trusting the self-signed certificate can be found here License Copyright (c) Virto Solutions LTD. All rights reserved. Licensed under the Virto Commerce Open Software License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://virtocommerce.com/opensourcelicense Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","title":"Connect Storefront to Platform"},{"location":"connect-storefront-to-platform-v3/#connect-storefront-to-platform","text":"Deploy the latest storefront version as described here Note, if Platform and Storefront are deployed in the same on-premises environment, Storefront should be deployed on different port then Platform. You can do it by dotnet run CLI dotnet VirtoCommerce.Storefront.dll --urls=http://localhost:5002/ or host Storefront in IIS. Make changes in appsettings.json ... \"Endpoint\" : { //Specify platform url \"Url\" : \"https://localhost:5001\" , //Comment the follow settings // \"AppId\" : \"...\" , // \"SecretKey\" : \"...\" , //Uncomment the follow settings \"UserName\" : \"admin\" , \"Password\" : \"store\" , \"RequestTimeout\" : \"0:0:30\" } , Trust the .Net Core Development Self-Signed Certificate. More details on trusting the self-signed certificate can be found here","title":"Connect Storefront to Platform"},{"location":"connect-storefront-to-platform-v3/#license","text":"Copyright (c) Virto Solutions LTD. All rights reserved. Licensed under the Virto Commerce Open Software License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://virtocommerce.com/opensourcelicense Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","title":"License"},{"location":"create-new-module/","text":"How to create a new Dummy module How to create a new module from scratch? Follow the Dummy module example. 1. Create solution and projects in correct structure Create empty DummyModule solution: https://docs.microsoft.com/en-us/visualstudio/get-started/tutorial-projects-solutions?view=vs-2019##create-a-solution Add src and tests Solution Folders (using Visual Studio) In src add project using \" Class library (.NET Core) \" template: Project name: DummyModule.Core Location: ...\\ DummyModule\\ src folder (create the missing src folder). Add DummyModule.Data project in the same way, ensure that it located under src folder. Add DummyModule.Web using \" ASP.NET Core Web Application \" Empty template, ensure that it located under src folder. Delete the auto-generated Class1.cs from all projects. In tests folder add a project using \" xUnit Test Project (.NET Core) \" template: Project name: DummyModule.Tests Location: ...\\ DummyModule\\ tests folder (create the missing tests folder). Set \"Target framework\" to \".NET Core 3.1\" for all 4 projects. References to projects: DummyModule.Data : add reference to DummyModule.Core project DummyModule.Web : add references to DummyModule.Core, DummyModule.Data projects DummyModule.Tests : add references to DummyModule.Core, DummyModule.Data, DummyModule.Web projects References to NuGet packages: DummyModule.Core : add reference to the latest version VirtoCommerce.Platform.Core package. DummyModule.Data : add reference to the latest version VirtoCommerce.Platform.Data package. (Outdated) References to NuGet packages in VirtoCommerce.Platform.Web : (Double click in Visual Studio to) open DummyModule.Web.csproj file for editing; Add new ItemGroup: xml <ItemGroup> <PackageReference Include=\"Microsoft.AspNetCore.App\" /> </ItemGroup> Compile the solution (there should be no warnings). 2. Fill DummyModule.Core project Add class ModuleConstants.cs for module constants: Inside ModuleConstants add sub-classes Security and Permissions like this: ```cs public static class Security { public static class Permissions { public const string Access = \"dummy:access\"; public const string Read = \"dummy:read\"; public const string Create = \"dummy:create\"; public const string Update = \"dummy:update\"; public const string Delete = \"dummy:delete\"; public static string[] AllPermissions = { Access, Read, Create, Update, Delete }; } } ``` Add sub-classes Settings and General containing settings' definitions of type SettingDescriptor , e.g., cs public static SettingDescriptor DummyInteger = new SettingDescriptor { Name = \"Dummy.Integer\", GroupName = \"Dummy|General\", ValueType = SettingValueType.Integer, DefaultValue = 50 }; Check sample ModuleConstants.cs for complete code. Other constants. If there is any domain models in your module, add Models folder. All domain models should be defined in Models folder. If there is any need for search services, add Search sub-folder. Add all SearchCriteria and SearchResult classes there. Services folder: in order to use the created models, create interfaces of the required services. Typically, interfaces containing CRUD and search operations are defined. Events folder: add model-related changing/changed events. Derive from the base GenericChangedEntryEvent class. Notifications folder: define new types of Notifications , that your module would expose. Each class should inherit from EmailNotification / SmsNotification or own class, based on Notification . 3. Fill DummyModule.Data project If there is any (domain) data to be persisted, add Models folder. All persistency related models should be defined in Models folder. Typically, each of the classes under this folder would have a corresponding class in DummyModule. Core /Models. The class should: define the DB table structure and restrictions; be able to convert from/to the corresponding Core model class. Add Repositories folder. Under it: Add class DummyDbContext , deriving from DbContextWithTriggers . Check and copy class contents from sample DummyDbContext.cs . Add class DesignTimeDbContextFactory . Check and copy class contents from sample DesignTimeDbContextFactory.cs . Double-check that connection to your development SQL server is correct. Add data repository abstraction (interface), deriving from IRepository for the defined persistency model. Add the repository implementation class for the previously defined interface and deriving from DbContextRepositoryBase<DummyDbContext> . Generate code-first migration: Execute \" Set as Startup Project \" on CustomerReviews. Data project in Solution Explorer Open NuGet Package Manager Console Select \"src\\DummyModule. Data \" as \" Default project \" Run command: Add-Migration Initial -Verbose A new EF migration gets generated. Read more details on extending an existing module's model: How to extend the DB model of VC module . Caching folder: add it, if data caching should be used. This folder is for the cache region classes. Typically, each model should have its own region. Derive CacheRegion from generic CancellableCacheRegion<T> class e.g., public class StoreCacheRegion : CancellableCacheRegion<StoreCacheRegion> . Services folder: add implementations of the interfaces that were defined in the .Core project. ExportImport folder: add class for data export/import. It should be called from Module.cs and contain implementation for module data export and import. Handlers folder: add handlers for the domain events , which were defined under .Core/Events . 4. Fill DummyModule.Web project Typical structure of .Web project is: Controllers/Api - API controllers; Localizations - translation resources for UI; Scripts - AngularJS module for extending Platform Manager UI; Module.cs - the entry point for module managed code; module.manifest - the main file of a module, the module definition. Project items to add: module.manifest (xml file) Identifier - a module identifier, each modules' identifier should be unique: xml <id>VirtoCommerce.Dummy</id> Versioning - actual version and (optional) prerelease version tag of a module: xml <version>1.0.0</version> <version-tag>v1</version-tag> Required minimal version of VC Platform: xml <platformVersion>3.0.0</platformVersion> Module dependencies - list of modules (with versions), functions of which will be used in the new module: xml <dependencies> <dependency id=\"VirtoCommerce.Core\" version=\"3.0.0\" /> </dependencies> Title and description - name and description of a new module that will be displayed in the Platform Manager and Swagger UI: xml <title>Dummy module</title> <description>Sample module for training purposes.</description> Authors - list of the developers, who wrote the module: xml <authors> <author>Andrei Kostyrin</author> <author>Egidijus Mazeika</author> </authors> Owners - list of the module owners: xml <owners> <owner>Virto Commerce</owner> </owners> Module groups - optional, logical grouping of the modules: ```xml samples ``` ProjectUrl - optional URL to get more details on the module: xml <projectUrl>https://github.com/VirtoCommerce/vc-samples</projectUrl> IconUrl - optional icon for the module to display in Platform's module management UI: xml <iconUrl></iconUrl> ReleaseNotes, copyright, tags - optional, additional information for the module: xml <releaseNotes>First version.</releaseNotes> <copyright>Copyright &copy; 2011-2020 Virto Commerce. All rights reserved</copyright> <tags>sample</tags> AssemblyFile and ModuleType - information for the module's managed code library loading into VC Platform: xml <assemblyFile>DummyModule.Web.dll</assemblyFile> <moduleType>DummyModule.Web.Module, DummyModule.Web</moduleType> JsonConverters folder: add it, if polymorphic data should be accepted by the API methods and deserialized correctly. This folder should contain converter(s) for populating the JSON values onto the target object. Module.cs class: the main entry point for module managed code, containing database initialization, registration of new repositories, services, model types and overrides: Implement VirtoCommerce.Platform.Core.Modularity.IModule interface like this: ```cs public class Module : IModule { public ManifestModuleInfo ModuleInfo { get; set; } public void Initialize ( IServiceCollection serviceCollection ) { // database initialization var configuration = serviceCollection . BuildServiceProvider (). GetRequiredService < IConfiguration > (); var connectionString = configuration . GetConnectionString ( \"VirtoCommerce.Dummy\" ) ?? configuration . GetConnectionString ( \"VirtoCommerce\" ); serviceCollection . AddDbContext < DummyDbContext > ( options => options . UseSqlServer ( connectionString )); } public void PostInitialize ( IApplicationBuilder appBuilder ) { // register settings var settingsRegistrar = appBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar > (); settingsRegistrar . RegisterSettings ( ModuleConstants . Settings . AllSettings , ModuleInfo . Id ); // register permissions var permissionsProvider = appBuilder . ApplicationServices . GetRequiredService < IPermissionsRegistrar > (); permissionsProvider . RegisterPermissions ( ModuleConstants . Security . Permissions . AllPermissions . Select ( x => new Permission () { GroupName = \"Dummy\" , Name = x } ). ToArray ()); // Ensure that any pending migrations are applied using ( var serviceScope = appBuilder . ApplicationServices . CreateScope ()) { using ( var dbContext = serviceScope . ServiceProvider . GetRequiredService < DummyDbContext > ()) { dbContext . Database . EnsureCreated (); dbContext . Database . Migrate (); } } } public void Uninstall () { // do nothing in here } } ``` If the module should support data export/import, implement IExportSupport and IImportSupport interfaces accordingly. Call the methods of the class(es), that were defined in .Data/ExportImport folder. Add Controllers/Api folder, if any API endpoints need to be exposed. Add API Controller(s), derived from Microsoft.AspNetCore.Mvc.Controller . Sample ASP.NET MVC endpoint: cs [HttpGet] [Route(\"getnew\")] [Authorize(ModuleConstants.Security.Permissions.Create)] public ActionResult<DummyModel> GetNewDummyModel() If the endpoint should have a restricted access, an Authorize attribute with the required permission should be provided. Use the ModuleConstants class, which was previously defined in Dummy.Core project. Optional Content folder: add module icon, stylesheets or any other optional content. Optional Scripts folder: add module.js and any required subfolders: blades, resources, widgets, etc. Sample module.js file: ```js //Call this to register our module to main application var moduleName = \"virtoCommerce.dummy\"; if (AppDependencies !== undefined) { AppDependencies.push(moduleName); } angular.module(moduleName, []) ; ``` If there are any JavaScript or stylesheet files in the project: Copy package.json from sample package.json ; Copy webpack.config.js from sample webpack.config.js ; Change the namespace on line 36 in webpack.config.js to be equal to module's identifier: js namespace: 'VirtoCommerce.Dummy' Open command prompt and navigate to DummyModule.Web folder: Run npm install Run npm run webpack:dev Localizations folder. Add en.VirtoCommerce.Dummy.json file: json { \"permissions\": { \"dummy:access\": \"Open Dummy menu\", \"dummy:create\": \"Create Dummy related data\", \"dummy:read\": \"View Dummy related data\", \"dummy:update\": \"Update Dummy related data\", \"dummy:delete\": \"Delete Dummy related data\" }, \"settings\": { \"Dummy\": { \"ShortText\": { \"title\": \"Dummy dictionary\", \"description\": \"ShortText dummy dictionary setting\" }, \"Integer\": { \"title\": \"Dummy integer\", \"description\": \"Dummy integer setting\" }, \"DateTime\": { \"title\": \"Dummy DateTime\", \"description\": \"Dummy DateTime setting\" } } } } 5. Fill DummyModule.Tests project UnitTests folder: add unit tests here. IntegrationTests folder: add integration tests here. Ensure, that each integration tests class is marked with Trait attribute: cs [Trait(\"Category\", \"IntegrationTest\")] 6. Create module package please read the article","title":"How to create a new Dummy module"},{"location":"create-new-module/#how-to-create-a-new-dummy-module","text":"How to create a new module from scratch? Follow the Dummy module example.","title":"How to create a new Dummy module"},{"location":"create-new-module/#1-create-solution-and-projects-in-correct-structure","text":"Create empty DummyModule solution: https://docs.microsoft.com/en-us/visualstudio/get-started/tutorial-projects-solutions?view=vs-2019##create-a-solution Add src and tests Solution Folders (using Visual Studio) In src add project using \" Class library (.NET Core) \" template: Project name: DummyModule.Core Location: ...\\ DummyModule\\ src folder (create the missing src folder). Add DummyModule.Data project in the same way, ensure that it located under src folder. Add DummyModule.Web using \" ASP.NET Core Web Application \" Empty template, ensure that it located under src folder. Delete the auto-generated Class1.cs from all projects. In tests folder add a project using \" xUnit Test Project (.NET Core) \" template: Project name: DummyModule.Tests Location: ...\\ DummyModule\\ tests folder (create the missing tests folder). Set \"Target framework\" to \".NET Core 3.1\" for all 4 projects. References to projects: DummyModule.Data : add reference to DummyModule.Core project DummyModule.Web : add references to DummyModule.Core, DummyModule.Data projects DummyModule.Tests : add references to DummyModule.Core, DummyModule.Data, DummyModule.Web projects References to NuGet packages: DummyModule.Core : add reference to the latest version VirtoCommerce.Platform.Core package. DummyModule.Data : add reference to the latest version VirtoCommerce.Platform.Data package. (Outdated) References to NuGet packages in VirtoCommerce.Platform.Web : (Double click in Visual Studio to) open DummyModule.Web.csproj file for editing; Add new ItemGroup: xml <ItemGroup> <PackageReference Include=\"Microsoft.AspNetCore.App\" /> </ItemGroup> Compile the solution (there should be no warnings).","title":"1. Create solution and projects in correct structure"},{"location":"create-new-module/#2-fill-dummymodulecore-project","text":"Add class ModuleConstants.cs for module constants: Inside ModuleConstants add sub-classes Security and Permissions like this: ```cs public static class Security { public static class Permissions { public const string Access = \"dummy:access\"; public const string Read = \"dummy:read\"; public const string Create = \"dummy:create\"; public const string Update = \"dummy:update\"; public const string Delete = \"dummy:delete\"; public static string[] AllPermissions = { Access, Read, Create, Update, Delete }; } } ``` Add sub-classes Settings and General containing settings' definitions of type SettingDescriptor , e.g., cs public static SettingDescriptor DummyInteger = new SettingDescriptor { Name = \"Dummy.Integer\", GroupName = \"Dummy|General\", ValueType = SettingValueType.Integer, DefaultValue = 50 }; Check sample ModuleConstants.cs for complete code. Other constants. If there is any domain models in your module, add Models folder. All domain models should be defined in Models folder. If there is any need for search services, add Search sub-folder. Add all SearchCriteria and SearchResult classes there. Services folder: in order to use the created models, create interfaces of the required services. Typically, interfaces containing CRUD and search operations are defined. Events folder: add model-related changing/changed events. Derive from the base GenericChangedEntryEvent class. Notifications folder: define new types of Notifications , that your module would expose. Each class should inherit from EmailNotification / SmsNotification or own class, based on Notification .","title":"2. Fill DummyModule.Core project"},{"location":"create-new-module/#3-fill-dummymoduledata-project","text":"If there is any (domain) data to be persisted, add Models folder. All persistency related models should be defined in Models folder. Typically, each of the classes under this folder would have a corresponding class in DummyModule. Core /Models. The class should: define the DB table structure and restrictions; be able to convert from/to the corresponding Core model class. Add Repositories folder. Under it: Add class DummyDbContext , deriving from DbContextWithTriggers . Check and copy class contents from sample DummyDbContext.cs . Add class DesignTimeDbContextFactory . Check and copy class contents from sample DesignTimeDbContextFactory.cs . Double-check that connection to your development SQL server is correct. Add data repository abstraction (interface), deriving from IRepository for the defined persistency model. Add the repository implementation class for the previously defined interface and deriving from DbContextRepositoryBase<DummyDbContext> . Generate code-first migration: Execute \" Set as Startup Project \" on CustomerReviews. Data project in Solution Explorer Open NuGet Package Manager Console Select \"src\\DummyModule. Data \" as \" Default project \" Run command: Add-Migration Initial -Verbose A new EF migration gets generated. Read more details on extending an existing module's model: How to extend the DB model of VC module . Caching folder: add it, if data caching should be used. This folder is for the cache region classes. Typically, each model should have its own region. Derive CacheRegion from generic CancellableCacheRegion<T> class e.g., public class StoreCacheRegion : CancellableCacheRegion<StoreCacheRegion> . Services folder: add implementations of the interfaces that were defined in the .Core project. ExportImport folder: add class for data export/import. It should be called from Module.cs and contain implementation for module data export and import. Handlers folder: add handlers for the domain events , which were defined under .Core/Events .","title":"3. Fill DummyModule.Data project"},{"location":"create-new-module/#4-fill-dummymoduleweb-project","text":"Typical structure of .Web project is: Controllers/Api - API controllers; Localizations - translation resources for UI; Scripts - AngularJS module for extending Platform Manager UI; Module.cs - the entry point for module managed code; module.manifest - the main file of a module, the module definition. Project items to add: module.manifest (xml file) Identifier - a module identifier, each modules' identifier should be unique: xml <id>VirtoCommerce.Dummy</id> Versioning - actual version and (optional) prerelease version tag of a module: xml <version>1.0.0</version> <version-tag>v1</version-tag> Required minimal version of VC Platform: xml <platformVersion>3.0.0</platformVersion> Module dependencies - list of modules (with versions), functions of which will be used in the new module: xml <dependencies> <dependency id=\"VirtoCommerce.Core\" version=\"3.0.0\" /> </dependencies> Title and description - name and description of a new module that will be displayed in the Platform Manager and Swagger UI: xml <title>Dummy module</title> <description>Sample module for training purposes.</description> Authors - list of the developers, who wrote the module: xml <authors> <author>Andrei Kostyrin</author> <author>Egidijus Mazeika</author> </authors> Owners - list of the module owners: xml <owners> <owner>Virto Commerce</owner> </owners> Module groups - optional, logical grouping of the modules: ```xml samples ``` ProjectUrl - optional URL to get more details on the module: xml <projectUrl>https://github.com/VirtoCommerce/vc-samples</projectUrl> IconUrl - optional icon for the module to display in Platform's module management UI: xml <iconUrl></iconUrl> ReleaseNotes, copyright, tags - optional, additional information for the module: xml <releaseNotes>First version.</releaseNotes> <copyright>Copyright &copy; 2011-2020 Virto Commerce. All rights reserved</copyright> <tags>sample</tags> AssemblyFile and ModuleType - information for the module's managed code library loading into VC Platform: xml <assemblyFile>DummyModule.Web.dll</assemblyFile> <moduleType>DummyModule.Web.Module, DummyModule.Web</moduleType> JsonConverters folder: add it, if polymorphic data should be accepted by the API methods and deserialized correctly. This folder should contain converter(s) for populating the JSON values onto the target object. Module.cs class: the main entry point for module managed code, containing database initialization, registration of new repositories, services, model types and overrides: Implement VirtoCommerce.Platform.Core.Modularity.IModule interface like this: ```cs public class Module : IModule { public ManifestModuleInfo ModuleInfo { get; set; } public void Initialize ( IServiceCollection serviceCollection ) { // database initialization var configuration = serviceCollection . BuildServiceProvider (). GetRequiredService < IConfiguration > (); var connectionString = configuration . GetConnectionString ( \"VirtoCommerce.Dummy\" ) ?? configuration . GetConnectionString ( \"VirtoCommerce\" ); serviceCollection . AddDbContext < DummyDbContext > ( options => options . UseSqlServer ( connectionString )); } public void PostInitialize ( IApplicationBuilder appBuilder ) { // register settings var settingsRegistrar = appBuilder . ApplicationServices . GetRequiredService < ISettingsRegistrar > (); settingsRegistrar . RegisterSettings ( ModuleConstants . Settings . AllSettings , ModuleInfo . Id ); // register permissions var permissionsProvider = appBuilder . ApplicationServices . GetRequiredService < IPermissionsRegistrar > (); permissionsProvider . RegisterPermissions ( ModuleConstants . Security . Permissions . AllPermissions . Select ( x => new Permission () { GroupName = \"Dummy\" , Name = x } ). ToArray ()); // Ensure that any pending migrations are applied using ( var serviceScope = appBuilder . ApplicationServices . CreateScope ()) { using ( var dbContext = serviceScope . ServiceProvider . GetRequiredService < DummyDbContext > ()) { dbContext . Database . EnsureCreated (); dbContext . Database . Migrate (); } } } public void Uninstall () { // do nothing in here } } ``` If the module should support data export/import, implement IExportSupport and IImportSupport interfaces accordingly. Call the methods of the class(es), that were defined in .Data/ExportImport folder. Add Controllers/Api folder, if any API endpoints need to be exposed. Add API Controller(s), derived from Microsoft.AspNetCore.Mvc.Controller . Sample ASP.NET MVC endpoint: cs [HttpGet] [Route(\"getnew\")] [Authorize(ModuleConstants.Security.Permissions.Create)] public ActionResult<DummyModel> GetNewDummyModel() If the endpoint should have a restricted access, an Authorize attribute with the required permission should be provided. Use the ModuleConstants class, which was previously defined in Dummy.Core project. Optional Content folder: add module icon, stylesheets or any other optional content. Optional Scripts folder: add module.js and any required subfolders: blades, resources, widgets, etc. Sample module.js file: ```js //Call this to register our module to main application var moduleName = \"virtoCommerce.dummy\"; if (AppDependencies !== undefined) { AppDependencies.push(moduleName); } angular.module(moduleName, []) ; ``` If there are any JavaScript or stylesheet files in the project: Copy package.json from sample package.json ; Copy webpack.config.js from sample webpack.config.js ; Change the namespace on line 36 in webpack.config.js to be equal to module's identifier: js namespace: 'VirtoCommerce.Dummy' Open command prompt and navigate to DummyModule.Web folder: Run npm install Run npm run webpack:dev Localizations folder. Add en.VirtoCommerce.Dummy.json file: json { \"permissions\": { \"dummy:access\": \"Open Dummy menu\", \"dummy:create\": \"Create Dummy related data\", \"dummy:read\": \"View Dummy related data\", \"dummy:update\": \"Update Dummy related data\", \"dummy:delete\": \"Delete Dummy related data\" }, \"settings\": { \"Dummy\": { \"ShortText\": { \"title\": \"Dummy dictionary\", \"description\": \"ShortText dummy dictionary setting\" }, \"Integer\": { \"title\": \"Dummy integer\", \"description\": \"Dummy integer setting\" }, \"DateTime\": { \"title\": \"Dummy DateTime\", \"description\": \"Dummy DateTime setting\" } } } }","title":"4. Fill DummyModule&#46;Web project"},{"location":"create-new-module/#5-fill-dummymoduletests-project","text":"UnitTests folder: add unit tests here. IntegrationTests folder: add integration tests here. Ensure, that each integration tests class is marked with Trait attribute: cs [Trait(\"Category\", \"IntegrationTest\")]","title":"5. Fill DummyModule.Tests project"},{"location":"create-new-module/#6-create-module-package","text":"please read the article","title":"6. Create module package"},{"location":"deploy-from-precompiled-binaries-linux/","text":"Summary Use this guide to deploy and configure precompiled Virto Commerce Platform V3. Prerequisites Prerequisites for .NET Core on Linux .NET Core SDK on Linux Microsoft SQL Server Downloading the precomplied binaries Navigate to the Releases section of Virto Commerce Platform in GitHub. You will find VirtoCommerce.Platform.3.x.x.zip file. In this file the site has already been built and can be run without additional compilation. The source code is not included. Run command to download binaries: wget \"https://github.com/VirtoCommerce/vc-platform/releases/download/3.x.x/VirtoCommerce.Platform.3.x.x.zip\" Unpack this zip to a local directory /vc-platform-3 . After that you will have the directory with Platform precompiled files. unzip VirtoCommerce.Platform.3.x.x.zip -d vc-platform-3 Setup Configure application strings Open the appsettings.json file in a text editor. In the ConnectionStrings section change VirtoCommerce node (provided user should have permission to create new database): \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" } , In the Assets section set public url for assets Assets:FileSystem:PublicUrl with url of your application, this step is needed in order to display images \"Assets\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"https://localhost:5001/assets/\" <-- Set your platform application url with port localhost : 5001 }, } , In the Content section set public url for content Content:FileSystem:PublicUrl with url of your application, this step is needed in order for configure CMS content storage \"Content*\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"https://localhost:5001/cms-content/\" <-- Set your platform application url with port localhost : 5001 }, } , Running the Platform by CLI \"dotnet\" Install and trust HTTPS certificate Run steps described in this article to trust the .NET Core SDK HTTPS development certificate on Linux. Read more about enforcing HTTPS in ASP.NET Core Run the Platform by following command: export ASPNETCORE_URLS=\"http://+:5000;https://+:5001\" cd vc-platform-3 dotnet VirtoCommerce.Platform.Web.dll The output in the console will say something like: Now listening on: http://[::]:5000 Now listening on: https://[::]:5001 First run and sign in Open https://localhost:5001 url in your browser. \"Your connection is not private\" might appear. Click \"Advanced\" and \"Proceed to ...\". Read more on removing this error and using a self-signed certificate: Trust the ASP.NET Core HTTPS development certificate The application will create and initialize database on the first request. After that you should see the sign in page. Use the following credentials: Login: admin Password: store License Copyright (c) Virto Solutions LTD. All rights reserved. Licensed under the Virto Commerce Open Software License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://virtocommerce.com/opensourcelicense Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","title":"Deploy Platform V3 from precompiled binaries on Linux"},{"location":"deploy-from-precompiled-binaries-linux/#summary","text":"Use this guide to deploy and configure precompiled Virto Commerce Platform V3.","title":"Summary"},{"location":"deploy-from-precompiled-binaries-linux/#prerequisites","text":"Prerequisites for .NET Core on Linux .NET Core SDK on Linux Microsoft SQL Server","title":"Prerequisites"},{"location":"deploy-from-precompiled-binaries-linux/#downloading-the-precomplied-binaries","text":"Navigate to the Releases section of Virto Commerce Platform in GitHub. You will find VirtoCommerce.Platform.3.x.x.zip file. In this file the site has already been built and can be run without additional compilation. The source code is not included. Run command to download binaries: wget \"https://github.com/VirtoCommerce/vc-platform/releases/download/3.x.x/VirtoCommerce.Platform.3.x.x.zip\" Unpack this zip to a local directory /vc-platform-3 . After that you will have the directory with Platform precompiled files. unzip VirtoCommerce.Platform.3.x.x.zip -d vc-platform-3","title":"Downloading the precomplied binaries"},{"location":"deploy-from-precompiled-binaries-linux/#setup","text":"","title":"Setup"},{"location":"deploy-from-precompiled-binaries-linux/#configure-application-strings","text":"Open the appsettings.json file in a text editor. In the ConnectionStrings section change VirtoCommerce node (provided user should have permission to create new database): \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" } , In the Assets section set public url for assets Assets:FileSystem:PublicUrl with url of your application, this step is needed in order to display images \"Assets\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"https://localhost:5001/assets/\" <-- Set your platform application url with port localhost : 5001 }, } , In the Content section set public url for content Content:FileSystem:PublicUrl with url of your application, this step is needed in order for configure CMS content storage \"Content*\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"https://localhost:5001/cms-content/\" <-- Set your platform application url with port localhost : 5001 }, } ,","title":"Configure application strings"},{"location":"deploy-from-precompiled-binaries-linux/#running-the-platform-by-cli-dotnet","text":"Install and trust HTTPS certificate Run steps described in this article to trust the .NET Core SDK HTTPS development certificate on Linux. Read more about enforcing HTTPS in ASP.NET Core Run the Platform by following command: export ASPNETCORE_URLS=\"http://+:5000;https://+:5001\" cd vc-platform-3 dotnet VirtoCommerce.Platform.Web.dll The output in the console will say something like: Now listening on: http://[::]:5000 Now listening on: https://[::]:5001","title":"Running the Platform by CLI \"dotnet\""},{"location":"deploy-from-precompiled-binaries-linux/#first-run-and-sign-in","text":"Open https://localhost:5001 url in your browser. \"Your connection is not private\" might appear. Click \"Advanced\" and \"Proceed to ...\". Read more on removing this error and using a self-signed certificate: Trust the ASP.NET Core HTTPS development certificate The application will create and initialize database on the first request. After that you should see the sign in page. Use the following credentials: Login: admin Password: store","title":"First run and sign in"},{"location":"deploy-from-precompiled-binaries-linux/#license","text":"Copyright (c) Virto Solutions LTD. All rights reserved. Licensed under the Virto Commerce Open Software License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://virtocommerce.com/opensourcelicense Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","title":"License"},{"location":"deploy-from-precompiled-binaries-windows/","text":"Summary Use this guide to deploy and configure precompiled Virto Commerce Platform V3. Prerequisites Prerequisites for .NET Core on Windows .NET Core SDK Microsoft SQL Server Downloading the precomplied binaries Navigate to the Releases section of Virto Commerce Platform in GitHub. You will find VirtoCommerce.Platform.3.x.x.zip file. In this file the site has already been built and can be run without additional compilation. The source code is not included. Unpack this zip to a local directory C:\\vc-platform-3 . After that you will have the directory with Platform precompiled files. Setup Configure application strings Open the appsettings.json file in a text editor. In the ConnectionStrings section change VirtoCommerce node (provided user should have permission to create new database): \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" } , In the Assets section set public url for assets Assets:FileSystem:PublicUrl with url of your application, this step is needed in order for display images \"Assets\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"https://localhost:5001/assets/\" <-- Set your platform application url with port localhost : 5001 }, } , In the Content section set public url for content Content:FileSystem:PublicUrl with url of your application, this step is needed in order for configure CMS content storage \"Content\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"https://localhost:5001/cms-content/\" <-- Set your platform application url with port localhost : 5001 }, } , Running the Platform only on HTTP schema In order to run the platform only at HTTP schema in production mode, it's enough to pass only HTTP URLs in --urls argument of the dotnet command. dotnet VirtoCommerce.Platform.Web.dll --urls=http://localhost:5000 Running the Platform on HTTPS schema Install and trust HTTPS certificate Run to trust the .NET Core SDK HTTPS development certificate: dotnet.exe dev-certs https --trust Read more about enforcing HTTPS in ASP.NET Core Run the Platform: You can start platform by run exe file cd C:\\vc-platform-3\\ VirtoCommerce.Platform.Web.exe or by CLI \"dotnet\" cd C:\\vc-platform-3\\ dotnet.exe VirtoCommerce.Platform.Web.dll The output in the console will say something like: Now listening on: http://localhost:5000 Now listening on: https://localhost:5001 First run sign in Open https://localhost:5001 url in your browser. \"Your connection is not private\" might appear. Click \"Advanced\" and \"Proceed to ...\". Read more on removing this error and using a self-signed certificate: Trust the ASP.NET Core HTTPS development certificate The application will create and initialize database on the first request. After that you should see the sign in page. Use the following credentials: Login: admin Password: store Host on Windows with IIS The required web.config file was already included in the release package. It contains all the necessary settings for running in IIS. Read more in the official Microsoft ASP.NET Core documentation: Host ASP.NET Core on Windows with IIS Open the VirtoCommerce Platform application in the browser. License Copyright (c) Virto Solutions LTD. All rights reserved. Licensed under the Virto Commerce Open Software License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://virtocommerce.com/opensourcelicense Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","title":"Deploy Platform V3 from precompiled binaries on Windows"},{"location":"deploy-from-precompiled-binaries-windows/#summary","text":"Use this guide to deploy and configure precompiled Virto Commerce Platform V3.","title":"Summary"},{"location":"deploy-from-precompiled-binaries-windows/#prerequisites","text":"Prerequisites for .NET Core on Windows .NET Core SDK Microsoft SQL Server","title":"Prerequisites"},{"location":"deploy-from-precompiled-binaries-windows/#downloading-the-precomplied-binaries","text":"Navigate to the Releases section of Virto Commerce Platform in GitHub. You will find VirtoCommerce.Platform.3.x.x.zip file. In this file the site has already been built and can be run without additional compilation. The source code is not included. Unpack this zip to a local directory C:\\vc-platform-3 . After that you will have the directory with Platform precompiled files.","title":"Downloading the precomplied binaries"},{"location":"deploy-from-precompiled-binaries-windows/#setup","text":"","title":"Setup"},{"location":"deploy-from-precompiled-binaries-windows/#configure-application-strings","text":"Open the appsettings.json file in a text editor. In the ConnectionStrings section change VirtoCommerce node (provided user should have permission to create new database): \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" } , In the Assets section set public url for assets Assets:FileSystem:PublicUrl with url of your application, this step is needed in order for display images \"Assets\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"https://localhost:5001/assets/\" <-- Set your platform application url with port localhost : 5001 }, } , In the Content section set public url for content Content:FileSystem:PublicUrl with url of your application, this step is needed in order for configure CMS content storage \"Content\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"https://localhost:5001/cms-content/\" <-- Set your platform application url with port localhost : 5001 }, } ,","title":"Configure application strings"},{"location":"deploy-from-precompiled-binaries-windows/#running-the-platform-only-on-http-schema","text":"In order to run the platform only at HTTP schema in production mode, it's enough to pass only HTTP URLs in --urls argument of the dotnet command. dotnet VirtoCommerce.Platform.Web.dll --urls=http://localhost:5000","title":"Running the Platform only on HTTP schema"},{"location":"deploy-from-precompiled-binaries-windows/#running-the-platform-on-https-schema","text":"Install and trust HTTPS certificate Run to trust the .NET Core SDK HTTPS development certificate: dotnet.exe dev-certs https --trust Read more about enforcing HTTPS in ASP.NET Core Run the Platform: You can start platform by run exe file cd C:\\vc-platform-3\\ VirtoCommerce.Platform.Web.exe or by CLI \"dotnet\" cd C:\\vc-platform-3\\ dotnet.exe VirtoCommerce.Platform.Web.dll The output in the console will say something like: Now listening on: http://localhost:5000 Now listening on: https://localhost:5001","title":"Running the Platform on HTTPS schema"},{"location":"deploy-from-precompiled-binaries-windows/#first-run-sign-in","text":"Open https://localhost:5001 url in your browser. \"Your connection is not private\" might appear. Click \"Advanced\" and \"Proceed to ...\". Read more on removing this error and using a self-signed certificate: Trust the ASP.NET Core HTTPS development certificate The application will create and initialize database on the first request. After that you should see the sign in page. Use the following credentials: Login: admin Password: store","title":"First run sign in"},{"location":"deploy-from-precompiled-binaries-windows/#host-on-windows-with-iis","text":"The required web.config file was already included in the release package. It contains all the necessary settings for running in IIS. Read more in the official Microsoft ASP.NET Core documentation: Host ASP.NET Core on Windows with IIS Open the VirtoCommerce Platform application in the browser.","title":"Host on Windows with IIS"},{"location":"deploy-from-precompiled-binaries-windows/#license","text":"Copyright (c) Virto Solutions LTD. All rights reserved. Licensed under the Virto Commerce Open Software License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://virtocommerce.com/opensourcelicense Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","title":"License"},{"location":"deploy-from-source-code/","text":"Deploy Platform from source code Deploy Module from source code Installation To get started locally, follow these instructions: Make sure that you have all Prerequisites installed Make fork from the latest platform source code from latest release Clone to your local computer using git and and switch to the release/3.0.0 branch git clone -b release/3.0.0 https://github.com/VirtoCommerce/vc-platform.git Building Platform Build Backend To make a local build: 1. Open console cd src/VirtoCommerce.Platform.Web Build dotnet build -c Development Or use Visual Studio: 1. Open VirtoCommerce.Platform.sln in Visual Studio 2. Build Solution Build Frontend Note While building the solution the first time from the Visual Studio, npm references should be installed and webpack should be built automatically. This would be done if Web project have this nuget package added - VirtoCommerce.BuildWebpack . It adds webpack build target to the project, which create frontend bundles on initial build. In case of changing frontend part, explicit local build would be required to pack style/script bundles. To make a local build: Open console cd src\\VirtoCommerce.Platform.Web Install the dependencies npm ci Build frontend application npm run webpack:build Watch changes npm run webpack:watch Initial Configuration Open the appsettings.json file in a text editor In the ConnectionStrings section change VirtoCommerce node (provided user should have permission to create new database): \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" } , In the Assets section set public url for assets Assets:FileSystem:PublicUrl with url of your application, this step is needed in order for display images \"Assets\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"http://localhost:10645/assets/\" <-- Set your platform application url with port localhost : 10645 }, } , In the Content section set public url for content Content:FileSystem:PublicUrl with url of your application, this step is needed in order for configure CMS content storage \"Content*\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"http://localhost:10645/cms-content/\" <-- Set your platform application url with port localhost : 10645 }, } , Running To run platform by dotnet CLI: 1. Open console cd src\\VirtoCommerce.Platform.Web Run dotnet run -c Development --no-launch-profile Note: you can add --no-build flag to speed the start, if you have compiled the solution already. Or run from Visual Studio * Open VirtoCommerce.Platform.sln * Set VirtoCommerce.Platform.Web as Startup Project * Go to Debug > Start Debugging (or Press F5) Usage Open http://localhost:10645 in the browser On the first request the application will create and initialize database. After that you should see the sign in page. Use the following credentials: admin/store to sign in Note: Don't forget to change them after the first sign in. Backend Debugging Install and run platform as described in steps above Open the module solution in Visual Studio and attach the debugger to the VirtoCommerce.Platform.Web.exe process Frontend Debugging Frontend supports debugging in Chrome. Open Chrome Developer Tools (Press F12) Open Sources tab Navigate to {module-name}/./Script/ Debug code Testing There is tests folder with suites which can be run locally. IDE Specific Usage Some additional tips for developing in specific IDEs. Visual Studio Recommend to install WebPack Task Runner and run webpack tasks from Visual Studio. Troubleshooting 'Could not load file or assembly GitVersionTask.MsBuild' when starting the platform through 'dotnet run' command","title":"Deploy Platform from source code"},{"location":"deploy-from-source-code/#deploy-platform-from-source-code","text":"Deploy Module from source code","title":"Deploy Platform from source code"},{"location":"deploy-from-source-code/#installation","text":"To get started locally, follow these instructions: Make sure that you have all Prerequisites installed Make fork from the latest platform source code from latest release Clone to your local computer using git and and switch to the release/3.0.0 branch git clone -b release/3.0.0 https://github.com/VirtoCommerce/vc-platform.git","title":"Installation"},{"location":"deploy-from-source-code/#building-platform","text":"","title":"Building Platform"},{"location":"deploy-from-source-code/#build-backend","text":"To make a local build: 1. Open console cd src/VirtoCommerce.Platform.Web Build dotnet build -c Development Or use Visual Studio: 1. Open VirtoCommerce.Platform.sln in Visual Studio 2. Build Solution","title":"Build Backend"},{"location":"deploy-from-source-code/#build-frontend","text":"","title":"Build Frontend"},{"location":"deploy-from-source-code/#note","text":"While building the solution the first time from the Visual Studio, npm references should be installed and webpack should be built automatically. This would be done if Web project have this nuget package added - VirtoCommerce.BuildWebpack . It adds webpack build target to the project, which create frontend bundles on initial build. In case of changing frontend part, explicit local build would be required to pack style/script bundles.","title":"Note"},{"location":"deploy-from-source-code/#to-make-a-local-build","text":"Open console cd src\\VirtoCommerce.Platform.Web Install the dependencies npm ci Build frontend application npm run webpack:build Watch changes npm run webpack:watch","title":"To make a local build:"},{"location":"deploy-from-source-code/#initial-configuration","text":"Open the appsettings.json file in a text editor In the ConnectionStrings section change VirtoCommerce node (provided user should have permission to create new database): \"ConnectionStrings\" : { \"VirtoCommerce\" : \"Data Source={SQL Server URL};Initial Catalog={Database name};Persist Security Info=True;User ID={User name};Password={User password};MultipleActiveResultSets=True;Connect Timeout=30\" } , In the Assets section set public url for assets Assets:FileSystem:PublicUrl with url of your application, this step is needed in order for display images \"Assets\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/assets\" , \"PublicUrl\" : \"http://localhost:10645/assets/\" <-- Set your platform application url with port localhost : 10645 }, } , In the Content section set public url for content Content:FileSystem:PublicUrl with url of your application, this step is needed in order for configure CMS content storage \"Content*\" : { \"Provider\" : \"FileSystem\" , \"FileSystem\" : { \"RootPath\" : \"~/cms-content\" , \"PublicUrl\" : \"http://localhost:10645/cms-content/\" <-- Set your platform application url with port localhost : 10645 }, } ,","title":"Initial Configuration"},{"location":"deploy-from-source-code/#running","text":"To run platform by dotnet CLI: 1. Open console cd src\\VirtoCommerce.Platform.Web Run dotnet run -c Development --no-launch-profile Note: you can add --no-build flag to speed the start, if you have compiled the solution already. Or run from Visual Studio * Open VirtoCommerce.Platform.sln * Set VirtoCommerce.Platform.Web as Startup Project * Go to Debug > Start Debugging (or Press F5)","title":"Running"},{"location":"deploy-from-source-code/#usage","text":"Open http://localhost:10645 in the browser On the first request the application will create and initialize database. After that you should see the sign in page. Use the following credentials: admin/store to sign in Note: Don't forget to change them after the first sign in.","title":"Usage"},{"location":"deploy-from-source-code/#backend-debugging","text":"Install and run platform as described in steps above Open the module solution in Visual Studio and attach the debugger to the VirtoCommerce.Platform.Web.exe process","title":"Backend Debugging"},{"location":"deploy-from-source-code/#frontend-debugging","text":"Frontend supports debugging in Chrome. Open Chrome Developer Tools (Press F12) Open Sources tab Navigate to {module-name}/./Script/ Debug code","title":"Frontend Debugging"},{"location":"deploy-from-source-code/#testing","text":"There is tests folder with suites which can be run locally.","title":"Testing"},{"location":"deploy-from-source-code/#ide-specific-usage","text":"Some additional tips for developing in specific IDEs.","title":"IDE Specific Usage"},{"location":"deploy-from-source-code/#visual-studio","text":"Recommend to install WebPack Task Runner and run webpack tasks from Visual Studio.","title":"Visual Studio"},{"location":"deploy-from-source-code/#troubleshooting","text":"'Could not load file or assembly GitVersionTask.MsBuild' when starting the platform through 'dotnet run' command","title":"Troubleshooting"},{"location":"deploy-module-from-source-code/","text":"Deploy Module from source code Deploy Platform from source code Installation To get started locally, follow these instructions: Make sure that you have Virto Commerce Platform installed Make fork from the latest module source code from https://github.com/VirtoCommerce/{module-name}.git Clone to your local computer using git and and switch to the release/3.0.0 branch git clone https://github.com/VirtoCommerce/{module-name}.git Building Module Build Backend Build Backend from CLI To make a local build: 1. Open console cd src/VirtoCommerce.{module-name}.Web Build dotnet build -c Development Build Backend from Visual Studio Open VirtoCommerce.{module-name}.sln in Visual Studio Build Solution Build Frontend Note While building the solution the first time from the Visual Studio, npm references should be installed and webpack should be built automatically. This would be done if Web project have this nuget package added - VirtoCommerce.BuildWebpack . It adds webpack build target to the project, which create frontend bundles on initial build. In case of changing frontend part, explicit local build would be required to pack style/script bundles. To make a local build: Open console cd src\\VirtoCommerce.{module-name}.Web Install the dependencies npm ci Build frontend application npm run webpack:build Watch changes npm run webpack:watch Initial Configuration Add directory link to VirtoCommerce.Platform.Web\\Modules, so the plarform can read module manifest and load it mklink /d VirtoCommerce.Platform.Web\\Modules src\\VirtoCommerce.{module-name}.Web Running Restart the Platform to load the new module assemblies into the Platform's application process. Backend Debugging Install and run platform as described in steps above. Open the module solution in Visual Studio and attach the debugger to the VirtoCommerce.Platform.Web.exe process. Frontend Debugging Frontend supports debugging in Chrome. Open Developer Console Open Source Tab Navigate to {module-name}/./Script/ Testing There is tests folder with suites which can be run locally.","title":"Deploy Module from source code"},{"location":"deploy-module-from-source-code/#deploy-module-from-source-code","text":"Deploy Platform from source code","title":"Deploy Module from source code"},{"location":"deploy-module-from-source-code/#installation","text":"To get started locally, follow these instructions: Make sure that you have Virto Commerce Platform installed Make fork from the latest module source code from https://github.com/VirtoCommerce/{module-name}.git Clone to your local computer using git and and switch to the release/3.0.0 branch git clone https://github.com/VirtoCommerce/{module-name}.git","title":"Installation"},{"location":"deploy-module-from-source-code/#building-module","text":"","title":"Building Module"},{"location":"deploy-module-from-source-code/#build-backend","text":"","title":"Build Backend"},{"location":"deploy-module-from-source-code/#build-backend-from-cli","text":"To make a local build: 1. Open console cd src/VirtoCommerce.{module-name}.Web Build dotnet build -c Development","title":"Build Backend from CLI"},{"location":"deploy-module-from-source-code/#build-backend-from-visual-studio","text":"Open VirtoCommerce.{module-name}.sln in Visual Studio Build Solution","title":"Build Backend from Visual Studio"},{"location":"deploy-module-from-source-code/#build-frontend","text":"","title":"Build Frontend"},{"location":"deploy-module-from-source-code/#note","text":"While building the solution the first time from the Visual Studio, npm references should be installed and webpack should be built automatically. This would be done if Web project have this nuget package added - VirtoCommerce.BuildWebpack . It adds webpack build target to the project, which create frontend bundles on initial build. In case of changing frontend part, explicit local build would be required to pack style/script bundles.","title":"Note"},{"location":"deploy-module-from-source-code/#to-make-a-local-build","text":"Open console cd src\\VirtoCommerce.{module-name}.Web Install the dependencies npm ci Build frontend application npm run webpack:build Watch changes npm run webpack:watch","title":"To make a local build:"},{"location":"deploy-module-from-source-code/#initial-configuration","text":"Add directory link to VirtoCommerce.Platform.Web\\Modules, so the plarform can read module manifest and load it mklink /d VirtoCommerce.Platform.Web\\Modules src\\VirtoCommerce.{module-name}.Web","title":"Initial Configuration"},{"location":"deploy-module-from-source-code/#running","text":"Restart the Platform to load the new module assemblies into the Platform's application process.","title":"Running"},{"location":"deploy-module-from-source-code/#backend-debugging","text":"Install and run platform as described in steps above. Open the module solution in Visual Studio and attach the debugger to the VirtoCommerce.Platform.Web.exe process.","title":"Backend Debugging"},{"location":"deploy-module-from-source-code/#frontend-debugging","text":"Frontend supports debugging in Chrome. Open Developer Console Open Source Tab Navigate to {module-name}/./Script/","title":"Frontend Debugging"},{"location":"deploy-module-from-source-code/#testing","text":"There is tests folder with suites which can be run locally.","title":"Testing"},{"location":"extend-DB-model/","text":"How to extend the DB model of VC module (v3) Model extension is evitable in VC modules development. This article provides the steps to take to extend any module's persistency model. VirtoCommerce.OrdersModule2.Web sample module is used as an example throughout the guide. Changes in \" .Core \" project Add reference to \" .Core \" NuGet package containing the base models, e.g., VirtoCommerce.OrdersModule.Core Define the new model class by extending the base model in Models folder: e.g., CustomerOrder2 : CustomerOrder Add the additional properties Changes in \" .Data \" project Add reference to \" .Data \" NuGet package containing the base models, e.g., VirtoCommerce.OrdersModule.Data Define the new model class by extending the base model in Models folder: e.g., CustomerOrder2Entity : CustomerOrderEntity Add the additional properties Override ToModel , FromModel , and Patch methods Changes in Repositories folder: Define a new DbContext class by extending the parent DbContext; add 1 public constructor; override OnModelCreating . Check the sample for details. Create DesignTimeDbContextFactory for the DbContext , just defined in previous step. Optional: Extend the parent repository interface: add IQueryable<T> property, add additional methods, if needed. Extend the parent repository by implementing the interface, just defined in previous step. If new interface wasn't defined, override the base methods as needed. Generate code-first DB migration: Execute \" Set as Startup Project \" on your \" .Data \" project in Solution Explorer Open NuGet Package Manager Console Select your \" .Data \" as \" Default project \" in the console Run command: console Add-Migration YourNewMigrationName where \" YourNewMigrationName \" is the name for the migration to add. The new migration files should be generated and opened. Explore the generated code and remove the commands, not reflecting your model changes or configurations defined in your DbContext.OnModelCreating() . These changes were applied already by migrations in base module. Ensure, that the Up() method defines: 1. the new column(s), if existing tables are being altered, like migrationBuilder.AddColumn<string>(name: \"NewField\", table: \"CustomerOrder\", maxLength: 128, nullable: true); 1. a Discriminator column (if new columns were defined in previous step AND it didn't exist in the original table already): ``` migrationBuilder.AddColumn<string>(name: \"Discriminator\", table: \"CustomerOrder\", nullable: false, maxLength: 128, defaultValue: \"CustomerOrder\"); ``` Read the [article about inheritance](https://docs.microsoft.com/en-us/ef/core/modeling/inheritance) for more details. new tables and indices, like ``` migrationBuilder.CreateTable( name: \"OrderInvoice\", ... ); migrationBuilder.CreateIndex( name: \"IX_OrderInvoice_CustomerOrder2Id\", table: \"OrderInvoice\", column: \"CustomerOrder2Id\"); `` 1. any custom SQL scripts, if data update is needed. 1. The _Down()_ method should do the opposite of what _Up()_ does. That way you can apply and un-apply your changes quickly by Update-Database` command in console. Changes in \" .Web \" project The changes regarding the model extension are required in Module.cs file only: Changes in Initialize() method: Register the new DbContext in DI: serviceCollection.AddDbContext<Order2DbContext>(options => options.UseSqlServer(configuration.GetConnectionString(\"VirtoCommerce\"))); Register the new Repository implementation in DI: serviceCollection.AddTransient<IOrderRepository, OrderRepository2>(); Changes in PostInitialize() method: Register type override(s) to AbstractTypeFactory Register new type(s) to AbstractTypeFactory (as in usual module) Add code to ensure that the migrations from new DbContext are applied: using (var serviceScope = appBuilder.ApplicationServices.CreateScope()) { var dbContext = serviceScope.ServiceProvider.GetRequiredService<Order2DbContext>(); dbContext.Database.EnsureCreated(); dbContext.Database.Migrate(); } Test your changes in Solution REST API documentation (Swagger) and DB. This tutorial provided the specific steps to take while extending any existing module's model and persistency layer. Also check the How to create a new module guide for common steps while creating a module.","title":"How to extend the DB model of VC module (v3)"},{"location":"extend-DB-model/#how-to-extend-the-db-model-of-vc-module-v3","text":"Model extension is evitable in VC modules development. This article provides the steps to take to extend any module's persistency model. VirtoCommerce.OrdersModule2.Web sample module is used as an example throughout the guide.","title":"How to extend the DB model of VC module (v3)"},{"location":"extend-DB-model/#changes-in-core-project","text":"Add reference to \" .Core \" NuGet package containing the base models, e.g., VirtoCommerce.OrdersModule.Core Define the new model class by extending the base model in Models folder: e.g., CustomerOrder2 : CustomerOrder Add the additional properties","title":"Changes in \".Core\" project"},{"location":"extend-DB-model/#changes-in-data-project","text":"Add reference to \" .Data \" NuGet package containing the base models, e.g., VirtoCommerce.OrdersModule.Data Define the new model class by extending the base model in Models folder: e.g., CustomerOrder2Entity : CustomerOrderEntity Add the additional properties Override ToModel , FromModel , and Patch methods Changes in Repositories folder: Define a new DbContext class by extending the parent DbContext; add 1 public constructor; override OnModelCreating . Check the sample for details. Create DesignTimeDbContextFactory for the DbContext , just defined in previous step. Optional: Extend the parent repository interface: add IQueryable<T> property, add additional methods, if needed. Extend the parent repository by implementing the interface, just defined in previous step. If new interface wasn't defined, override the base methods as needed. Generate code-first DB migration: Execute \" Set as Startup Project \" on your \" .Data \" project in Solution Explorer Open NuGet Package Manager Console Select your \" .Data \" as \" Default project \" in the console Run command: console Add-Migration YourNewMigrationName where \" YourNewMigrationName \" is the name for the migration to add. The new migration files should be generated and opened. Explore the generated code and remove the commands, not reflecting your model changes or configurations defined in your DbContext.OnModelCreating() . These changes were applied already by migrations in base module. Ensure, that the Up() method defines: 1. the new column(s), if existing tables are being altered, like migrationBuilder.AddColumn<string>(name: \"NewField\", table: \"CustomerOrder\", maxLength: 128, nullable: true); 1. a Discriminator column (if new columns were defined in previous step AND it didn't exist in the original table already): ``` migrationBuilder.AddColumn<string>(name: \"Discriminator\", table: \"CustomerOrder\", nullable: false, maxLength: 128, defaultValue: \"CustomerOrder\"); ``` Read the [article about inheritance](https://docs.microsoft.com/en-us/ef/core/modeling/inheritance) for more details. new tables and indices, like ``` migrationBuilder.CreateTable( name: \"OrderInvoice\", ... ); migrationBuilder.CreateIndex( name: \"IX_OrderInvoice_CustomerOrder2Id\", table: \"OrderInvoice\", column: \"CustomerOrder2Id\"); `` 1. any custom SQL scripts, if data update is needed. 1. The _Down()_ method should do the opposite of what _Up()_ does. That way you can apply and un-apply your changes quickly by Update-Database` command in console.","title":"Changes in \".Data\" project"},{"location":"extend-DB-model/#changes-in-web-project","text":"The changes regarding the model extension are required in Module.cs file only: Changes in Initialize() method: Register the new DbContext in DI: serviceCollection.AddDbContext<Order2DbContext>(options => options.UseSqlServer(configuration.GetConnectionString(\"VirtoCommerce\"))); Register the new Repository implementation in DI: serviceCollection.AddTransient<IOrderRepository, OrderRepository2>(); Changes in PostInitialize() method: Register type override(s) to AbstractTypeFactory Register new type(s) to AbstractTypeFactory (as in usual module) Add code to ensure that the migrations from new DbContext are applied: using (var serviceScope = appBuilder.ApplicationServices.CreateScope()) { var dbContext = serviceScope.ServiceProvider.GetRequiredService<Order2DbContext>(); dbContext.Database.EnsureCreated(); dbContext.Database.Migrate(); } Test your changes in Solution REST API documentation (Swagger) and DB. This tutorial provided the specific steps to take while extending any existing module's model and persistency layer. Also check the How to create a new module guide for common steps while creating a module.","title":"Changes in \".Web\" project"},{"location":"getting-started/","text":"Getting started If you are new to Virto Commerce, follow these steps to set up and launch your store. Step 1. Create a catalog The catalog is what your customers are constantly working with. It is very important that the catalog is easy to browse and find the right products. Typically, to start working with the new catalog you should follow several steps: Create a new catalogue Create categories Create a product Create a product with variants Additionally you can read Working with Products catalog article. It describes how to work with products catalog , categories , items , product properties , product variations and virtual catalogs Step 2. Configure your store Virto Commerce platform is 4-MULTI: multi-language, multi-currency, multi-theme and multi-store by design. This gives the ability to have and run multiple stores on the same system. To configure your store you must accomplish a set of actions: Create first store (enter store code and name) Select your catalog Select available currency, languages Configure advanced properties: Store description, emails and URLs Fulfillment centers Operational timezone Setup theme Open your first store in a browser. The Managing stores article helps you to configure your first store. Also at this step you should configure Users, Roles and Role Assignment Step 3. Configure prices and inventory In the Virto Commerce, a pricelist is a set of pricing details that can be assigned to items. All prices are stored in a pricelist(s), which have specific currency set. When a pricelist is created, you define which products will be included into this pricelist and what prices will be defined for them. The way to apply the prices to products on Storefront is creating a Pricelist Assignment. It binds a catalog with pricelist and can add optional conditions for this binding. Pricelist assignment identifies the pricelist from which a product price is shown for customers. Moreover, pricelist assignments can do much more than simply provide default list and sale prices for products. This feature allows you to provide custom prices to targeted customers according to customer's characteristics such as age, gender, geographic location and searched terms. Thus, price configuring consists of the following actions: Create pricelist Add items to the pricelist Create pricelist assignment Manage inventory After this step completed, you can Open new products in Virto Commerce Storefront , browse the catalog, add product to shopping cart and create order. You can view customer order via admin UI. Step 4. Configure payments, shipments, taxes By default, you see demo payment and shipment methods. Virto Commerce provides the ready to use module which you can set your own configurations: Install Payment module (For example: PayPal ) Install and configure Shipments method Install and configure Taxes method Step 5. Launch Marketing & promotional tools Marketing your store is essential to gain your customers loyalty and raise awareness among potential customers. There are several marketing tools in Virto Commerce: you can publish content, create personalized shopping experiences for customers, manage promotions. Start with creation of three simple promotions: Each customer would receive a 5% off if cart subtotal exceeded $100 Add Gift product for a first time buyer Add 10% discount if product is in-stock You can find more details about how to create first promotions here: Managing promotions Create a content publishing Dynamic content Combine active promotions Step 6. Configure User Experience To enhance User Experience Virto Commerce contains a set of tools: Menu item in Virto Commerce Storefront Catalog filters in Virto Commerce Storefront Currencies, languages Link lists Theme settings file Login on behalf Social login Step 7. Go to live with MVP and review additional cases in Virto Commerce Now you are ready to launch your MVP store.","title":"Getting started (title from metadata)"},{"location":"getting-started/#getting-started","text":"If you are new to Virto Commerce, follow these steps to set up and launch your store.","title":"Getting started"},{"location":"getting-started/#step-1-create-a-catalog","text":"The catalog is what your customers are constantly working with. It is very important that the catalog is easy to browse and find the right products. Typically, to start working with the new catalog you should follow several steps: Create a new catalogue Create categories Create a product Create a product with variants Additionally you can read Working with Products catalog article. It describes how to work with products catalog , categories , items , product properties , product variations and virtual catalogs","title":"Step 1. Create a catalog"},{"location":"getting-started/#step-2-configure-your-store","text":"Virto Commerce platform is 4-MULTI: multi-language, multi-currency, multi-theme and multi-store by design. This gives the ability to have and run multiple stores on the same system. To configure your store you must accomplish a set of actions: Create first store (enter store code and name) Select your catalog Select available currency, languages Configure advanced properties: Store description, emails and URLs Fulfillment centers Operational timezone Setup theme Open your first store in a browser. The Managing stores article helps you to configure your first store. Also at this step you should configure Users, Roles and Role Assignment","title":"Step 2. Configure your store"},{"location":"getting-started/#step-3-configure-prices-and-inventory","text":"In the Virto Commerce, a pricelist is a set of pricing details that can be assigned to items. All prices are stored in a pricelist(s), which have specific currency set. When a pricelist is created, you define which products will be included into this pricelist and what prices will be defined for them. The way to apply the prices to products on Storefront is creating a Pricelist Assignment. It binds a catalog with pricelist and can add optional conditions for this binding. Pricelist assignment identifies the pricelist from which a product price is shown for customers. Moreover, pricelist assignments can do much more than simply provide default list and sale prices for products. This feature allows you to provide custom prices to targeted customers according to customer's characteristics such as age, gender, geographic location and searched terms. Thus, price configuring consists of the following actions: Create pricelist Add items to the pricelist Create pricelist assignment Manage inventory After this step completed, you can Open new products in Virto Commerce Storefront , browse the catalog, add product to shopping cart and create order. You can view customer order via admin UI.","title":"Step 3. Configure prices and inventory"},{"location":"getting-started/#step-4-configure-payments-shipments-taxes","text":"By default, you see demo payment and shipment methods. Virto Commerce provides the ready to use module which you can set your own configurations: Install Payment module (For example: PayPal ) Install and configure Shipments method Install and configure Taxes method","title":"Step 4. Configure payments, shipments, taxes"},{"location":"getting-started/#step-5-launch-marketing-promotional-tools","text":"Marketing your store is essential to gain your customers loyalty and raise awareness among potential customers. There are several marketing tools in Virto Commerce: you can publish content, create personalized shopping experiences for customers, manage promotions. Start with creation of three simple promotions: Each customer would receive a 5% off if cart subtotal exceeded $100 Add Gift product for a first time buyer Add 10% discount if product is in-stock You can find more details about how to create first promotions here: Managing promotions Create a content publishing Dynamic content Combine active promotions","title":"Step 5. Launch Marketing &amp; promotional tools"},{"location":"getting-started/#step-6-configure-user-experience","text":"To enhance User Experience Virto Commerce contains a set of tools: Menu item in Virto Commerce Storefront Catalog filters in Virto Commerce Storefront Currencies, languages Link lists Theme settings file Login on behalf Social login","title":"Step 6. Configure User Experience"},{"location":"getting-started/#step-7-go-to-live-with-mvp-and-review-additional-cases-in-virto-commerce","text":"Now you are ready to launch your MVP store.","title":"Step 7. Go to live with MVP and review additional cases in Virto Commerce"},{"location":"sharing-bearer-tokens-across-platform-instances/","text":"How to sharing bearer tokens across platform instances In some deployment scenarios when are running multiple platform instances one of them usually play authentication server role and has access to user accounts storages. Other platform instances are play role as resource servers that simply needs to limit access to those users who have valid security tokens that were provided by an authentication server . Once the token is issued and signed by the authentication server, no database communication is required to verify the token. Any service that accepts the token will just validate the digital signature of the token. For that scenario, authentication middleware that handles JWT tokens is available in the Microsoft.AspNetCore.Authentication.JwtBearer package. JWT stands for \"JSON Web Token\" and is a common security token format (defined by RFC 7519) for communicating security claims The Virto platform has some settings that can used to configure resource server to consume such tokens appsettings.json - For resource server ... \"Auth\" : { // Is the address of the token - issuing authentication server . // The JWT bearer authentication middleware uses this URI to get the public key that can be used to validate the token 's signature. //The middleware also confirms that the iss parameter in the token matches this URI. \"Authority\": \"https://authentication-server-url\", //represents the receiver of the incoming token or the resource that the token grants access to. //If the value specified in this parameter does not match the parameter in the token, //the token will be rejected. //the ' resource_server ' value can be left unchanged \"Audience\" : \"resource_server\" , \"PublicCertPath\" : \"./Certificates/virtocommerce.crt\" , \"PrivateKeyPath\" : \"./Certificates/virtocommerce.pfx\" , \"PrivateKeyPassword\" : \"virto\" } ...","title":"How to sharing bearer tokens across platform instances"},{"location":"sharing-bearer-tokens-across-platform-instances/#how-to-sharing-bearer-tokens-across-platform-instances","text":"In some deployment scenarios when are running multiple platform instances one of them usually play authentication server role and has access to user accounts storages. Other platform instances are play role as resource servers that simply needs to limit access to those users who have valid security tokens that were provided by an authentication server . Once the token is issued and signed by the authentication server, no database communication is required to verify the token. Any service that accepts the token will just validate the digital signature of the token. For that scenario, authentication middleware that handles JWT tokens is available in the Microsoft.AspNetCore.Authentication.JwtBearer package. JWT stands for \"JSON Web Token\" and is a common security token format (defined by RFC 7519) for communicating security claims The Virto platform has some settings that can used to configure resource server to consume such tokens appsettings.json - For resource server ... \"Auth\" : { // Is the address of the token - issuing authentication server . // The JWT bearer authentication middleware uses this URI to get the public key that can be used to validate the token 's signature. //The middleware also confirms that the iss parameter in the token matches this URI. \"Authority\": \"https://authentication-server-url\", //represents the receiver of the incoming token or the resource that the token grants access to. //If the value specified in this parameter does not match the parameter in the token, //the token will be rejected. //the ' resource_server ' value can be left unchanged \"Audience\" : \"resource_server\" , \"PublicCertPath\" : \"./Certificates/virtocommerce.crt\" , \"PrivateKeyPath\" : \"./Certificates/virtocommerce.pfx\" , \"PrivateKeyPassword\" : \"virto\" } ...","title":"How to sharing bearer tokens across platform instances"},{"location":"swagger-endpoints/","text":"Swagger/OpenApi-presented platform and modules endpoints Swagger UI Swagger UI available at URL */Docs Platform endpoints Swagger/OpenApi endpoints for platform available there: * /docs/PlatformUI/swagger.json Modules endpoints Swagger/OpenApi endpoints for modules resides at urls like /docs/[module]]/swagger.json*, as example: /docs/VirtoCommerce.Orders/swagger.json*","title":"Swagger endpoints"},{"location":"swagger-endpoints/#swaggeropenapi-presented-platform-and-modules-endpoints","text":"","title":"Swagger/OpenApi-presented platform and modules endpoints"},{"location":"swagger-endpoints/#swagger-ui","text":"Swagger UI available at URL */Docs","title":"Swagger UI"},{"location":"swagger-endpoints/#platform-endpoints","text":"Swagger/OpenApi endpoints for platform available there: * /docs/PlatformUI/swagger.json","title":"Platform endpoints"},{"location":"swagger-endpoints/#modules-endpoints","text":"Swagger/OpenApi endpoints for modules resides at urls like /docs/[module]]/swagger.json*, as example: /docs/VirtoCommerce.Orders/swagger.json*","title":"Modules endpoints"},{"location":"upgrade-storefront-autorest-cli-to-v3/","text":"How to upgrade AutoRest-generated clients to VirtoCommerce v3 in the Storefront Summary Currently, storefront is compatible to both major versions of the Platform (v2, v3). This document describes how to upgrade Storefront AutoRest-generated clients (for platform and modules) to the latest v3 interfaces. This action allow you to modernize storefront but break compatibility with v2. An example of upgraded storefront (made during creation of this document) resides there: Upgraded storefront branch . Contents Preconditions Upgrading AutoRest-generated clients Platform Catalog module Cart module Content module Core and Tax modules Customer module Inventory module Marketing module Orders module Pricing module Shipping module Payment module Sitemaps module Store module Subscription module Preconditions Open solution with storefront source code; Learn how to install and use Autorest with v3 . Upgrading AutoRest-generated clients Platform Run Autorest for $modules = @('Platform','Notifications') . Wait while Autorest finishes. 'Notifications' passed because in v3 notifications module was extracted from platform to separate module. Try to compile solution. Look at the errors. Resolve errors and update code with recommendations below. file: \\Domain\\Common\\NotificationConverter.cs Error Recommendation 'TestNotificationRequest' could not be found Notifications were extracted to a separate module, therefore: add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi.Models; remove using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; rewrite TestNotificationRequest to NotificationRequest (typename was changed). file: \\Controllers\\AccountController.cs Error Recommendation The type or namespace name 'INotifications' could not be found add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi; remove using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi; The type or namespace name 'SendNotificationResult' could not be found SendNotificationResult was renamed to NotificationSendResult : add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi.Models; change names SendNotificationResult to NotificationSendResult Errors with parameter type in call _platformNotificationApi.SendNotificationAsync Change this call to a backward compatible method _platformNotificationApi.SendNotificationByRequestAsync . 'IdentityResult' is an ambiguous reference between 'VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models.IdentityResult' and 'Microsoft.AspNetCore.Identity.IdentityResult' Remove: using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; file: \\Controllers\\Api\\ApiAccountController.cs Error Recommendation A lot of errors like: 'IdentityResult' is an ambiguous reference between 'VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models.IdentityResult' and 'Microsoft.AspNetCore.Identity.IdentityResult' Remove: using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi; using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; The type or namespace name 'INotifications' could not be found Add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi; Errors with parameter type in call _platformNotificationApi.SendNotificationAsync Change this call to a backward compatible method _platformNotificationApi.SendNotificationByRequestAsync . The type or namespace name 'ChangePasswordInfo' could not be found It was renamed to ChangePasswordRequest , replace ChangePasswordInfo with AutoRestClients.PlatformModuleApi.Models.ChangePasswordRequest file: \\Domain\\Common\\SettingConverter.cs Error Recommendation The type or namespace name 'Setting' does not exist... It was renamed to ObjectSettingEntry : remove using platformDto = VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; add using platformDto = VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; change type name Setting to ObjectSettingEntry . Check ObjectSettingEntry 's members for nulls before converting to string. Issues inside ToSettingEntry There is no Description and Title anymore. Not used, just remove assignments; Convert DefaultValue and Value to string; Set IsArray to false . It's not used; Remove ArrayValues assignment. It's not used; Convert each item of AllowedValues to string. As a result the method should look like: public static SettingEntry ToSettingEntry ( this platformDto . ObjectSettingEntry settingDto ) { var retVal = new SettingEntry (); retVal . DefaultValue = settingDto . DefaultValue . ToString (); retVal . IsArray = false ; retVal . Name = settingDto . Name ; retVal . Value = settingDto . Value . ToString (); retVal . ValueType = settingDto . ValueType ; if ( settingDto . AllowedValues != null ) { retVal . AllowedValues = settingDto . AllowedValues . Cast < string >(). ToList (); } return retVal ; } file: \\Domain\\Security\\SecurityConverter.cs Error Recommendation The type or namespace name 'SecurityResult' does not exist... Rewrite dto.SecurityResult as dto.IdentityResult , it was renamed. The type or namespace name 'ApplicationUserExtended' does not exist Rewrite dto.ApplicationUserExtended as dto.ApplicationUser , it was renamed. Cannot implicitly convert type 'VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models.IdentityError' to 'string' IdentityResult now contains errors as IdentityError . Use member Description (Rewrite Description = x as Description = x.Description ). file: \\Domain\\Security\\UserStoreStub.cs Error Recommendation The type or namespace name 'ApplicationUserExtended' does not exist Rewrite ApplicationUserExtended as ApplicationUser , it was renamed. 'ISecurity' does not contain a definition for 'CreateAsyncAsync'... CreateAsyncAsync was renamed to CreateAsync 'ISecurity' does not contain a definition for 'DeleteAsyncAsync'... DeleteAsyncAsync was renamed to DeleteAsync 'ISecurity' does not contain a definition for 'UpdateAsyncAsync'... UpdateAsyncAsync was renamed to UpdateAsync file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommercePlatformRESTAPIdocumentation' could not be found... Rewrite VirtoCommercePlatformRESTAPIdocumentation as PlatformModuleClient The type or namespace name 'INotifications' could not be found... add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi; Warning! Don't forget to register in DI AutoRestClient for newcoming Notifications module! Be sure to have in AddPlatformEndpoint following lines: services . AddAutoRestClient (( credentials , httpClient , disposeHttpClient , baseUri ) => new NotificationsModuleClient ( credentials , httpClient , disposeHttpClient ) { BaseUri = baseUri }); services . AddSingleton < INotifications >( sp => new Notifications ( sp . GetRequiredService < NotificationsModuleClient >())); file: \\Domain\\Security\\PermissionAuthorizationPolicyProvider.cs Error Recommendation 'ISecurity' does not contain a definition for 'GetPermissionsAsync'... Method was renamed to GetAllRegisteredPermissionsAsync file: \\Domain\\Security\\PollingApiUserChangeToken.cs Error Recommendation The type or namespace name 'UserSearchRequest' could not be found... UserSearchRequest was renamed to UserSearchCriteria . Also its fields SkipCount -> Skip , TakeCount -> Take . 'UserSearchResult' does not contain a definition for 'TotalCount' Search result was incapsulated into a Result property of UserSearchResult . Therefore replace result.TotalCount with result.Result.TotalCount . 'UserSearchResult' does not contain a definition for 'Users' Search result was incapsulated into a Result property of UserSearchResult . Therefore replace result.Users with result.Result.Users . file: \\Domain\\Cart\\CartConverter.cs Error Recommendation The type or namespace name 'Setting' does not exist... Setting was renamed to ObjectSettingEntry file: \\Domain\\Stores\\StoreConverter.cs Error Recommendation The type or namespace name 'Setting' does not exist... Setting was renamed to ObjectSettingEntry file: \\Domain\\Stores\\StoreService.cs Error Recommendation The type or namespace name 'Setting' does not exist... Setting was renamed to ObjectSettingEntry , rewrite as AutoRestClients.PlatformModuleApi.Models.ObjectSettingEntry file: \\Middleware\\CreateStorefrontRolesMiddleware.cs Error Recommendation The type or namespace name 'RoleSearchRequest' could not be found... RoleSearchRequest was renamed to RoleSearchCriteria . Also field TakeCount -> Take . ___ ### Catalog module Run Autorest for $modules = @('Catalog') . Wait while Autorest finishes. file: \\Domain\\Catalog\\CatalogConverter.cs Error Recommendation The type or namespace name 'ProductSearchCriteria' does not exist ProductSearchCriteria was renamed to ProductIndexedSearchCriteria The type or namespace name 'CategorySearchCriteria' does not exist CategorySearchCriteria was renamed to CategoryIndexedSearchCriteria file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCatalogRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCatalogRESTAPIdocumentation as PlatformModuleClient The type or namespace name 'ICatalogModuleSearch' could not be found... ICatalogModuleSearch was renamed to ICatalogModuleIndexedSearch The type or namespace name 'CatalogModuleSearch' could not be found... CatalogModuleSearch was renamed to CatalogModuleIndexedSearch file: \\Domain\\Catalog\\CatalogConverter.cs Error Recommendation The type or namespace name 'Product' does not exist Product was renamed to CatalogProduct Warning! Variations in platform v3 have new type Variation itstead of storefront code where variations is a products. Therefore we need to add in this file additional conversion method to convert AutoRest-generated Variation to the Product in storefront. Let's do it: public static Product ToProduct ( this catalogDto . Variation variationDto , Language currentLanguage , Currency currentCurrency , Store store ) { return variationDto . JsonConvert < catalogDto . CatalogProduct >(). ToProduct ( currentLanguage , currentCurrency , store ); } file: \\Domain\\Catalog\\CatalogService.cs Error Recommendation The type or namespace name 'ICatalogModuleSearch' could not be found... ICatalogModuleSearch was renamed to ICatalogModuleIndexedSearch The type or namespace name 'ProductSearchResult' could not be found... ProductSearchResult was renamed to ProductIndexedSearchResult ___ ### Cart module Run Autorest for $modules = @('Cart') . Wait while Autorest finishes. file: \\Domain\\Cart\\CartConverter.cs Error Recommendation The type or namespace name 'ShipmentItem' could not be found... ShipmentItem was renamed to CartShipmentItem The type or namespace name 'Shipment' could not be found... Shipment was renamed to CartShipment The type or namespace name 'Address' could not be found... Address was renamed to CartAddress The type or namespace name 'LineItem' could not be found... LineItem was renamed to CartLineItem 'ShippingRate' does not contain a definition for 'OptionDescription' OptionDescription obsolete. Just remove this assignment. 'PaymentMethod' does not contain a definition for 'Description' Description obsolete. Just remove this assignment. The property or indexer 'ShoppingCart.ObjectType' cannot be used in this context because the set accessor is inaccessible Just remove this assignment. It does not matter because it's equal to .NET type name on the server. The property or indexer 'CartLineItem.ObjectType' cannot be used in this context because the set accessor is inaccessible Just remove this assignment. It does not matter because it's equal to .NET type name on the server. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCartRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCartRESTAPIdocumentation as CartModuleClient file: \\Domain\\Cart\\CartService.cs Error Recommendation 'ICartModule' does not contain a definition for 'UpdateAsync'... UpdateAsync was renamed to UpdateShoppingCartAsync 'ICartModule' does not contain a definition for 'SearchAsync'... SearchAsync was renamed to SearchShoppingCartAsync ___ ### Content module Run Autorest for $modules = @('Content') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceContentRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceContentRESTAPIdocumentation as ContentModuleClient Core and Tax modules Run Autorest for $modules = @('Core','Tax') . Wait while Autorest finishes. We are running for both modules because a tax-linked part of Core module was moved to Tax module. file: \\Domain\\Common\\DynamicPropertyConverter.cs Error Recommendation A lot of errors like: The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty file: \\Domain\\Tax\\TaxConverter.cs Error Recommendation The type or namespace name 'TaxRate' could not be found... TaxRate was moved to Tax module: Add using taxDto = VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models; replace coreDto.TaxRate with taxDto.TaxRate ; Remove using coreDto = VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi.Models. The type or namespace name 'TaxEvaluationContext' could not be found... TaxEvaluationContext was moved to Tax module: replace coreDto.TaxEvaluationContext with taxDto.TaxEvaluationContext The type or namespace name 'TaxLine' could not be found... TaxLine was moved to Tax module: replace coreDto.TaxLine with taxDto.TaxLine The type or namespace name 'TaxDetail' could not be found... TaxDetail was moved to Tax module: replace coreDto.TaxDetail with taxDto.TaxDetail 'TaxCustomer' does not contain a definition for 'MemberType' MemberType was removed. Remove assignment. file: \\Domain\\Tax\\TaxEvaluator.cs Error Recommendation The type or namespace name 'TaxRate' does not exist... TaxRate was moved to Tax module: add using taxDto = VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models; replace coreService.TaxRate with taxDto.TaxRate ; Remove using coreService = VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi.Models. 'ICommerce' does not contain a definition for 'EvaluateTaxesAsync'... EvaluateTaxesAsync was moved to Tax module: add using VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi; replace ICommerce with ITaxModule to make tax module methods accessible; Rename member _commerceApi to _taxApi ; remove using VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi; file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCoreRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCoreRESTAPIdocumentation as CoreModuleClient 'TaxModule' does not contain a constructor that takes 3 arguments Rewrite TaxModule as CoreModuleClient . The type or namespace name 'IStorefrontSecurity' could not be found... The type or namespace name 'StorefrontSecurity' could not be found... It's obsolete. Just remove this registration in DI. file: \\Domain\\Stores\\StoreConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty file: \\Domain\\Marketing\\MarketingConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using. file: \\Domain\\Order\\OrderConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using. file: \\Domain\\Cart\\CartConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty Cannot implicitly convert type 'VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi.Models.Address' to 'VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models.TaxAddress' Add conversion to TaxAddress thru JsonConvert : retVal.Address = taxContext.Address.ToCoreAddressDto().JsonConvert<taxDto.TaxAddress>(); file: \\Domain\\Customer\\MemberConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using. The type or namespace name 'Contact' does not exist in the namespace Contact was moved to Customer module. Start with next topic: convert Customer module. ___ ### Customer module Run Autorest for $modules = @('Customer') . Wait while Autorest finishes. file: \\Domain\\Customer\\MemberConverter.cs Error Recommendation The type or namespace name 'Contact' does not exist in the namespace Contact was moved to Customer module. Replace coreDto.Contact with customerDto.Contact . The type or namespace name 'Address' could not be found... Address was renamed to CustomerAddress . file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCustomerRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCustomerRESTAPIdocumentation as CoreModuleClient file: \\Domain\\Customer\\MemberService.cs Error Recommendation 'ICustomerModule' does not contain a definition for 'SearchAsync' and no accessible extension method 'SearchAsync' ... SearchAsync was renamed to SearchMemberAsync . file: \\Domain\\Tax\\TaxConverter.cs Error Recommendation Cannot implicitly convert type 'VirtoCommerce.Storefront.AutoRestClients.CustomerModuleApi.Models.Contact' to 'VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models.TaxCustomer' Add conversion to TaxCustomer thru JsonConvert : retVal.Customer = taxContext?.Customer?.Contact?.ToCoreContactDto().JsonConvert<taxDto.TaxCustomer>(); file: \\Domain\\Quote\\QuoteConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' does not exist... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using of platform models: using platformDto = VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; ___ ### Inventory module Run Autorest for $modules = @('Inventory') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceInventoryRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceInventoryRESTAPIdocumentation as InventoryModuleClient ___ ### Marketing module Run Autorest for $modules = @('Marketing') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceMarketingRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceMarketingRESTAPIdocumentation as InventoryModuleClient Orders module Run Autorest for $modules = @('Orders') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceOrdersRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceOrdersRESTAPIdocumentation as OrdersModuleClient file: \\Controllers\\Api\\ApiCartController.cs Error Recommendation The type or namespace name 'ProcessPaymentResult' does not exist ProcessPaymentResult was renamed to ProcessPaymentRequestResult file: \\Domain\\Order\\OrderConverter.cs Error Recommendation The type or namespace name 'ProcessPaymentResult' does not exist ProcessPaymentResult was renamed to ProcessPaymentRequestResult The type or namespace name 'Address' does not exist Address was renamed to OrderAddress . The type or namespace name 'ShipmentItem' does not exist ShipmentItem was renamed to OrderShipmentItem . The type or namespace name 'Shipment' does not exist Shipment was renamed to OrderShipmentItem . The type or namespace name 'LineItem' does not exist LineItem was renamed to OrderLineItem . 'ProcessPaymentRequestResult' does not contain a definition for 'Error' Error was renamed to ErrorMessage file: \\Controllers\\Api\\ApiOrderController.cs Error Recommendation IOrderModule' does not contain a definition for 'SearchAsync' and no accessible extension method 'SearchAsync' SearchAsync was renamed to SearchCustomerOrderAsync IOrderModule' does not contain a definition for 'UpdateAsync' and no accessible extension method 'UpdateAsync' UpdateAsync was renamed to UpdateOrderAsync A lot of errors: There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByNumberAsync Write string.Empty to respGroup parameter. There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByIdAsync Write string.Empty to respGroup parameter. file: \\Domain\\Order\\CustomerOrderService.cs Error Recommendation There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByNumberAsync Write string.Empty to respGroup parameter. There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByIdAsync Write string.Empty to respGroup parameter. IOrderModule' does not contain a definition for 'SearchAsync' and no accessible extension method 'SearchAsync' SearchAsync was renamed to SearchCustomerOrderAsync ___ ### Pricing module Run Autorest for $modules = @('Pricing') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommercePricingRESTAPIdocumentation' could not be found... Rewrite VirtoCommercePricingRESTAPIdocumentation as PricingModuleClient ___ ### Shipping module Run Autorest for $modules = @('Shipping') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation 'ShippingModule' does not contain a constructor that takes 3 arguments Rewrite ShippingModule as ShippingModuleClient . ___ ### Payment module Run Autorest for $modules = @('Payment') . Wait while Autorest finishes. Error Recommendation 'PaymentModule' does not contain a constructor that takes 3 arguments Rewrite PaymentModule as PaymentModuleClient . ___ ### Sitemaps module Run Autorest for $modules = @('Sitemaps') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceSitemapsRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceSitemapsRESTAPIdocumentation as SitemapsModuleClient ___ ### Store module Run Autorest for $modules = @('Store') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceStoreRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceStoreRESTAPIdocumentation as SitemapsModuleClient file: \\Domain\\Stores\\StoreService.cs Error Recommendation The type or namespace name 'PaymentMethod' does not exist The type or namespace name 'TaxProvider' does not exist Just remove these usings 'Store' does not contain a definition for 'PaymentMethods'... 'Store' does not contain a definition for 'TaxProviders'... storeDto does not have such properties. We should always ask _paymentModule service for valid store payment methods and _taxModule for tax providers. Rewrite ConvertStoreAndLoadDependeciesAsync with this mean (look at the code after table). The type or namespace name 'StorePaymentMethod' could not be found Just remove JsonConvert\\ () it doesn't need anymore. protected virtual async Task < Store > ConvertStoreAndLoadDependeciesAsync ( StoreApi . Store storeDto , Currency currency = null ) { var result = storeDto . ToStore (); if ( currency != null ) { var paymentSearchCriteria = new PaymentMethodsSearchCriteria { StoreId = result . Id }; var paymentsSearchResult = await _paymentModule . SearchPaymentMethodsAsync ( paymentSearchCriteria ); result . PaymentMethods = paymentsSearchResult . Results . Where ( pm => pm . IsActive != null && pm . IsActive . Value ) . Select ( pm => { var paymentMethod = pm . ToStorePaymentMethod ( currency ); paymentMethod . Name = pm . TypeName ; return paymentMethod ; }). ToArray (); } var taxSearchCriteria = new TaxProviderSearchCriteria { StoreId = result . Id }; var taxProviderSearchResult = await _taxModule . SearchTaxProvidersAsync ( taxSearchCriteria ); result . FixedTaxRate = GetFixedTaxRate ( taxProviderSearchResult . Results . Select ( xp => xp . JsonConvert < TaxProvider >()). ToArray ()); //use url for stores from configuration file with hight priority than store url defined in manager result . Url = _storefrontOptions . StoreUrls [ result . Id ] ?? result . Url ; return result ; } file: \\Domain\\Stores\\StoreConverter.cs Error Recommendation The type or namespace name 'PaymentMethod' does not exist... The type or namespace name 'TaxDetail' does not exist... They both were moved to payment module. Therefore add appropriate using using paymentDto = VirtoCommerce.Storefront.AutoRestClients.PaymentModuleApi.Models; then rewrite storeDto.PaymentMethod as paymentDto.PaymentMethod , storeDto.TaxDetail , as paymentDto.TaxDetail file: \\Domain\\Order\\OrderConverter.cs Error Recommendation The type or namespace name 'PaymentMethod' does not exist... There meaning PaymentMethod from store module, that was moved in v3 to payment module. Therefore it is need to add appropriate using using paymentDto = VirtoCommerce.Storefront.AutoRestClients.PaymentModuleApi.Models; then rewrite storeDto.PaymentMethod as paymentDto.PaymentMethod Subscription module Run Autorest for $modules = @('Subscription') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceSubscriptionRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceSubscriptionRESTAPIdocumentation as SitemapsModuleClient","title":"How to upgrade AutoRest-generated clients to VirtoCommerce v3 in the Storefront"},{"location":"upgrade-storefront-autorest-cli-to-v3/#how-to-upgrade-autorest-generated-clients-to-virtocommerce-v3-in-the-storefront","text":"","title":"How to upgrade AutoRest-generated clients to VirtoCommerce v3 in the Storefront"},{"location":"upgrade-storefront-autorest-cli-to-v3/#summary","text":"Currently, storefront is compatible to both major versions of the Platform (v2, v3). This document describes how to upgrade Storefront AutoRest-generated clients (for platform and modules) to the latest v3 interfaces. This action allow you to modernize storefront but break compatibility with v2. An example of upgraded storefront (made during creation of this document) resides there: Upgraded storefront branch .","title":"Summary"},{"location":"upgrade-storefront-autorest-cli-to-v3/#contents","text":"Preconditions Upgrading AutoRest-generated clients Platform Catalog module Cart module Content module Core and Tax modules Customer module Inventory module Marketing module Orders module Pricing module Shipping module Payment module Sitemaps module Store module Subscription module","title":"Contents"},{"location":"upgrade-storefront-autorest-cli-to-v3/#preconditions","text":"Open solution with storefront source code; Learn how to install and use Autorest with v3 .","title":"Preconditions"},{"location":"upgrade-storefront-autorest-cli-to-v3/#upgrading-autorest-generated-clients","text":"","title":"Upgrading AutoRest-generated clients"},{"location":"upgrade-storefront-autorest-cli-to-v3/#platform","text":"Run Autorest for $modules = @('Platform','Notifications') . Wait while Autorest finishes. 'Notifications' passed because in v3 notifications module was extracted from platform to separate module. Try to compile solution. Look at the errors. Resolve errors and update code with recommendations below. file: \\Domain\\Common\\NotificationConverter.cs Error Recommendation 'TestNotificationRequest' could not be found Notifications were extracted to a separate module, therefore: add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi.Models; remove using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; rewrite TestNotificationRequest to NotificationRequest (typename was changed). file: \\Controllers\\AccountController.cs Error Recommendation The type or namespace name 'INotifications' could not be found add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi; remove using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi; The type or namespace name 'SendNotificationResult' could not be found SendNotificationResult was renamed to NotificationSendResult : add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi.Models; change names SendNotificationResult to NotificationSendResult Errors with parameter type in call _platformNotificationApi.SendNotificationAsync Change this call to a backward compatible method _platformNotificationApi.SendNotificationByRequestAsync . 'IdentityResult' is an ambiguous reference between 'VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models.IdentityResult' and 'Microsoft.AspNetCore.Identity.IdentityResult' Remove: using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; file: \\Controllers\\Api\\ApiAccountController.cs Error Recommendation A lot of errors like: 'IdentityResult' is an ambiguous reference between 'VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models.IdentityResult' and 'Microsoft.AspNetCore.Identity.IdentityResult' Remove: using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi; using VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; The type or namespace name 'INotifications' could not be found Add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi; Errors with parameter type in call _platformNotificationApi.SendNotificationAsync Change this call to a backward compatible method _platformNotificationApi.SendNotificationByRequestAsync . The type or namespace name 'ChangePasswordInfo' could not be found It was renamed to ChangePasswordRequest , replace ChangePasswordInfo with AutoRestClients.PlatformModuleApi.Models.ChangePasswordRequest file: \\Domain\\Common\\SettingConverter.cs Error Recommendation The type or namespace name 'Setting' does not exist... It was renamed to ObjectSettingEntry : remove using platformDto = VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; add using platformDto = VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; change type name Setting to ObjectSettingEntry . Check ObjectSettingEntry 's members for nulls before converting to string. Issues inside ToSettingEntry There is no Description and Title anymore. Not used, just remove assignments; Convert DefaultValue and Value to string; Set IsArray to false . It's not used; Remove ArrayValues assignment. It's not used; Convert each item of AllowedValues to string. As a result the method should look like: public static SettingEntry ToSettingEntry ( this platformDto . ObjectSettingEntry settingDto ) { var retVal = new SettingEntry (); retVal . DefaultValue = settingDto . DefaultValue . ToString (); retVal . IsArray = false ; retVal . Name = settingDto . Name ; retVal . Value = settingDto . Value . ToString (); retVal . ValueType = settingDto . ValueType ; if ( settingDto . AllowedValues != null ) { retVal . AllowedValues = settingDto . AllowedValues . Cast < string >(). ToList (); } return retVal ; } file: \\Domain\\Security\\SecurityConverter.cs Error Recommendation The type or namespace name 'SecurityResult' does not exist... Rewrite dto.SecurityResult as dto.IdentityResult , it was renamed. The type or namespace name 'ApplicationUserExtended' does not exist Rewrite dto.ApplicationUserExtended as dto.ApplicationUser , it was renamed. Cannot implicitly convert type 'VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models.IdentityError' to 'string' IdentityResult now contains errors as IdentityError . Use member Description (Rewrite Description = x as Description = x.Description ). file: \\Domain\\Security\\UserStoreStub.cs Error Recommendation The type or namespace name 'ApplicationUserExtended' does not exist Rewrite ApplicationUserExtended as ApplicationUser , it was renamed. 'ISecurity' does not contain a definition for 'CreateAsyncAsync'... CreateAsyncAsync was renamed to CreateAsync 'ISecurity' does not contain a definition for 'DeleteAsyncAsync'... DeleteAsyncAsync was renamed to DeleteAsync 'ISecurity' does not contain a definition for 'UpdateAsyncAsync'... UpdateAsyncAsync was renamed to UpdateAsync file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommercePlatformRESTAPIdocumentation' could not be found... Rewrite VirtoCommercePlatformRESTAPIdocumentation as PlatformModuleClient The type or namespace name 'INotifications' could not be found... add using VirtoCommerce.Storefront.AutoRestClients.NotificationsModuleApi; Warning! Don't forget to register in DI AutoRestClient for newcoming Notifications module! Be sure to have in AddPlatformEndpoint following lines: services . AddAutoRestClient (( credentials , httpClient , disposeHttpClient , baseUri ) => new NotificationsModuleClient ( credentials , httpClient , disposeHttpClient ) { BaseUri = baseUri }); services . AddSingleton < INotifications >( sp => new Notifications ( sp . GetRequiredService < NotificationsModuleClient >())); file: \\Domain\\Security\\PermissionAuthorizationPolicyProvider.cs Error Recommendation 'ISecurity' does not contain a definition for 'GetPermissionsAsync'... Method was renamed to GetAllRegisteredPermissionsAsync file: \\Domain\\Security\\PollingApiUserChangeToken.cs Error Recommendation The type or namespace name 'UserSearchRequest' could not be found... UserSearchRequest was renamed to UserSearchCriteria . Also its fields SkipCount -> Skip , TakeCount -> Take . 'UserSearchResult' does not contain a definition for 'TotalCount' Search result was incapsulated into a Result property of UserSearchResult . Therefore replace result.TotalCount with result.Result.TotalCount . 'UserSearchResult' does not contain a definition for 'Users' Search result was incapsulated into a Result property of UserSearchResult . Therefore replace result.Users with result.Result.Users . file: \\Domain\\Cart\\CartConverter.cs Error Recommendation The type or namespace name 'Setting' does not exist... Setting was renamed to ObjectSettingEntry file: \\Domain\\Stores\\StoreConverter.cs Error Recommendation The type or namespace name 'Setting' does not exist... Setting was renamed to ObjectSettingEntry file: \\Domain\\Stores\\StoreService.cs Error Recommendation The type or namespace name 'Setting' does not exist... Setting was renamed to ObjectSettingEntry , rewrite as AutoRestClients.PlatformModuleApi.Models.ObjectSettingEntry file: \\Middleware\\CreateStorefrontRolesMiddleware.cs Error Recommendation The type or namespace name 'RoleSearchRequest' could not be found... RoleSearchRequest was renamed to RoleSearchCriteria . Also field TakeCount -> Take . ___ ### Catalog module Run Autorest for $modules = @('Catalog') . Wait while Autorest finishes. file: \\Domain\\Catalog\\CatalogConverter.cs Error Recommendation The type or namespace name 'ProductSearchCriteria' does not exist ProductSearchCriteria was renamed to ProductIndexedSearchCriteria The type or namespace name 'CategorySearchCriteria' does not exist CategorySearchCriteria was renamed to CategoryIndexedSearchCriteria file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCatalogRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCatalogRESTAPIdocumentation as PlatformModuleClient The type or namespace name 'ICatalogModuleSearch' could not be found... ICatalogModuleSearch was renamed to ICatalogModuleIndexedSearch The type or namespace name 'CatalogModuleSearch' could not be found... CatalogModuleSearch was renamed to CatalogModuleIndexedSearch file: \\Domain\\Catalog\\CatalogConverter.cs Error Recommendation The type or namespace name 'Product' does not exist Product was renamed to CatalogProduct Warning! Variations in platform v3 have new type Variation itstead of storefront code where variations is a products. Therefore we need to add in this file additional conversion method to convert AutoRest-generated Variation to the Product in storefront. Let's do it: public static Product ToProduct ( this catalogDto . Variation variationDto , Language currentLanguage , Currency currentCurrency , Store store ) { return variationDto . JsonConvert < catalogDto . CatalogProduct >(). ToProduct ( currentLanguage , currentCurrency , store ); } file: \\Domain\\Catalog\\CatalogService.cs Error Recommendation The type or namespace name 'ICatalogModuleSearch' could not be found... ICatalogModuleSearch was renamed to ICatalogModuleIndexedSearch The type or namespace name 'ProductSearchResult' could not be found... ProductSearchResult was renamed to ProductIndexedSearchResult ___ ### Cart module Run Autorest for $modules = @('Cart') . Wait while Autorest finishes. file: \\Domain\\Cart\\CartConverter.cs Error Recommendation The type or namespace name 'ShipmentItem' could not be found... ShipmentItem was renamed to CartShipmentItem The type or namespace name 'Shipment' could not be found... Shipment was renamed to CartShipment The type or namespace name 'Address' could not be found... Address was renamed to CartAddress The type or namespace name 'LineItem' could not be found... LineItem was renamed to CartLineItem 'ShippingRate' does not contain a definition for 'OptionDescription' OptionDescription obsolete. Just remove this assignment. 'PaymentMethod' does not contain a definition for 'Description' Description obsolete. Just remove this assignment. The property or indexer 'ShoppingCart.ObjectType' cannot be used in this context because the set accessor is inaccessible Just remove this assignment. It does not matter because it's equal to .NET type name on the server. The property or indexer 'CartLineItem.ObjectType' cannot be used in this context because the set accessor is inaccessible Just remove this assignment. It does not matter because it's equal to .NET type name on the server. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCartRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCartRESTAPIdocumentation as CartModuleClient file: \\Domain\\Cart\\CartService.cs Error Recommendation 'ICartModule' does not contain a definition for 'UpdateAsync'... UpdateAsync was renamed to UpdateShoppingCartAsync 'ICartModule' does not contain a definition for 'SearchAsync'... SearchAsync was renamed to SearchShoppingCartAsync ___ ### Content module Run Autorest for $modules = @('Content') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceContentRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceContentRESTAPIdocumentation as ContentModuleClient","title":"Platform"},{"location":"upgrade-storefront-autorest-cli-to-v3/#core-and-tax-modules","text":"Run Autorest for $modules = @('Core','Tax') . Wait while Autorest finishes. We are running for both modules because a tax-linked part of Core module was moved to Tax module. file: \\Domain\\Common\\DynamicPropertyConverter.cs Error Recommendation A lot of errors like: The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty file: \\Domain\\Tax\\TaxConverter.cs Error Recommendation The type or namespace name 'TaxRate' could not be found... TaxRate was moved to Tax module: Add using taxDto = VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models; replace coreDto.TaxRate with taxDto.TaxRate ; Remove using coreDto = VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi.Models. The type or namespace name 'TaxEvaluationContext' could not be found... TaxEvaluationContext was moved to Tax module: replace coreDto.TaxEvaluationContext with taxDto.TaxEvaluationContext The type or namespace name 'TaxLine' could not be found... TaxLine was moved to Tax module: replace coreDto.TaxLine with taxDto.TaxLine The type or namespace name 'TaxDetail' could not be found... TaxDetail was moved to Tax module: replace coreDto.TaxDetail with taxDto.TaxDetail 'TaxCustomer' does not contain a definition for 'MemberType' MemberType was removed. Remove assignment. file: \\Domain\\Tax\\TaxEvaluator.cs Error Recommendation The type or namespace name 'TaxRate' does not exist... TaxRate was moved to Tax module: add using taxDto = VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models; replace coreService.TaxRate with taxDto.TaxRate ; Remove using coreService = VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi.Models. 'ICommerce' does not contain a definition for 'EvaluateTaxesAsync'... EvaluateTaxesAsync was moved to Tax module: add using VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi; replace ICommerce with ITaxModule to make tax module methods accessible; Rename member _commerceApi to _taxApi ; remove using VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi; file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCoreRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCoreRESTAPIdocumentation as CoreModuleClient 'TaxModule' does not contain a constructor that takes 3 arguments Rewrite TaxModule as CoreModuleClient . The type or namespace name 'IStorefrontSecurity' could not be found... The type or namespace name 'StorefrontSecurity' could not be found... It's obsolete. Just remove this registration in DI. file: \\Domain\\Stores\\StoreConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty file: \\Domain\\Marketing\\MarketingConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using. file: \\Domain\\Order\\OrderConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using. file: \\Domain\\Cart\\CartConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty Cannot implicitly convert type 'VirtoCommerce.Storefront.AutoRestClients.CoreModuleApi.Models.Address' to 'VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models.TaxAddress' Add conversion to TaxAddress thru JsonConvert : retVal.Address = taxContext.Address.ToCoreAddressDto().JsonConvert<taxDto.TaxAddress>(); file: \\Domain\\Customer\\MemberConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' could not be found... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using. The type or namespace name 'Contact' does not exist in the namespace Contact was moved to Customer module. Start with next topic: convert Customer module. ___ ### Customer module Run Autorest for $modules = @('Customer') . Wait while Autorest finishes. file: \\Domain\\Customer\\MemberConverter.cs Error Recommendation The type or namespace name 'Contact' does not exist in the namespace Contact was moved to Customer module. Replace coreDto.Contact with customerDto.Contact . The type or namespace name 'Address' could not be found... Address was renamed to CustomerAddress . file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceCustomerRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceCustomerRESTAPIdocumentation as CoreModuleClient file: \\Domain\\Customer\\MemberService.cs Error Recommendation 'ICustomerModule' does not contain a definition for 'SearchAsync' and no accessible extension method 'SearchAsync' ... SearchAsync was renamed to SearchMemberAsync . file: \\Domain\\Tax\\TaxConverter.cs Error Recommendation Cannot implicitly convert type 'VirtoCommerce.Storefront.AutoRestClients.CustomerModuleApi.Models.Contact' to 'VirtoCommerce.Storefront.AutoRestClients.TaxModuleApi.Models.TaxCustomer' Add conversion to TaxCustomer thru JsonConvert : retVal.Customer = taxContext?.Customer?.Contact?.ToCoreContactDto().JsonConvert<taxDto.TaxCustomer>(); file: \\Domain\\Quote\\QuoteConverter.cs Error Recommendation The type or namespace name 'DynamicObjectProperty' does not exist... DynamicObjectProperty was moved to platform API. Replace coreDto.DynamicObjectProperty with platformDto.DynamicObjectProperty . Add appropriate using of platform models: using platformDto = VirtoCommerce.Storefront.AutoRestClients.PlatformModuleApi.Models; ___ ### Inventory module Run Autorest for $modules = @('Inventory') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceInventoryRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceInventoryRESTAPIdocumentation as InventoryModuleClient ___ ### Marketing module Run Autorest for $modules = @('Marketing') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceMarketingRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceMarketingRESTAPIdocumentation as InventoryModuleClient","title":"Core and Tax modules"},{"location":"upgrade-storefront-autorest-cli-to-v3/#orders-module","text":"Run Autorest for $modules = @('Orders') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceOrdersRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceOrdersRESTAPIdocumentation as OrdersModuleClient file: \\Controllers\\Api\\ApiCartController.cs Error Recommendation The type or namespace name 'ProcessPaymentResult' does not exist ProcessPaymentResult was renamed to ProcessPaymentRequestResult file: \\Domain\\Order\\OrderConverter.cs Error Recommendation The type or namespace name 'ProcessPaymentResult' does not exist ProcessPaymentResult was renamed to ProcessPaymentRequestResult The type or namespace name 'Address' does not exist Address was renamed to OrderAddress . The type or namespace name 'ShipmentItem' does not exist ShipmentItem was renamed to OrderShipmentItem . The type or namespace name 'Shipment' does not exist Shipment was renamed to OrderShipmentItem . The type or namespace name 'LineItem' does not exist LineItem was renamed to OrderLineItem . 'ProcessPaymentRequestResult' does not contain a definition for 'Error' Error was renamed to ErrorMessage file: \\Controllers\\Api\\ApiOrderController.cs Error Recommendation IOrderModule' does not contain a definition for 'SearchAsync' and no accessible extension method 'SearchAsync' SearchAsync was renamed to SearchCustomerOrderAsync IOrderModule' does not contain a definition for 'UpdateAsync' and no accessible extension method 'UpdateAsync' UpdateAsync was renamed to UpdateOrderAsync A lot of errors: There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByNumberAsync Write string.Empty to respGroup parameter. There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByIdAsync Write string.Empty to respGroup parameter. file: \\Domain\\Order\\CustomerOrderService.cs Error Recommendation There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByNumberAsync Write string.Empty to respGroup parameter. There is no argument given that corresponds to the required formal parameter 'respGroup' of 'OrderModuleExtensions.GetByIdAsync Write string.Empty to respGroup parameter. IOrderModule' does not contain a definition for 'SearchAsync' and no accessible extension method 'SearchAsync' SearchAsync was renamed to SearchCustomerOrderAsync ___ ### Pricing module Run Autorest for $modules = @('Pricing') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommercePricingRESTAPIdocumentation' could not be found... Rewrite VirtoCommercePricingRESTAPIdocumentation as PricingModuleClient ___ ### Shipping module Run Autorest for $modules = @('Shipping') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation 'ShippingModule' does not contain a constructor that takes 3 arguments Rewrite ShippingModule as ShippingModuleClient . ___ ### Payment module Run Autorest for $modules = @('Payment') . Wait while Autorest finishes. Error Recommendation 'PaymentModule' does not contain a constructor that takes 3 arguments Rewrite PaymentModule as PaymentModuleClient . ___ ### Sitemaps module Run Autorest for $modules = @('Sitemaps') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceSitemapsRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceSitemapsRESTAPIdocumentation as SitemapsModuleClient ___ ### Store module Run Autorest for $modules = @('Store') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceStoreRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceStoreRESTAPIdocumentation as SitemapsModuleClient file: \\Domain\\Stores\\StoreService.cs Error Recommendation The type or namespace name 'PaymentMethod' does not exist The type or namespace name 'TaxProvider' does not exist Just remove these usings 'Store' does not contain a definition for 'PaymentMethods'... 'Store' does not contain a definition for 'TaxProviders'... storeDto does not have such properties. We should always ask _paymentModule service for valid store payment methods and _taxModule for tax providers. Rewrite ConvertStoreAndLoadDependeciesAsync with this mean (look at the code after table). The type or namespace name 'StorePaymentMethod' could not be found Just remove JsonConvert\\ () it doesn't need anymore. protected virtual async Task < Store > ConvertStoreAndLoadDependeciesAsync ( StoreApi . Store storeDto , Currency currency = null ) { var result = storeDto . ToStore (); if ( currency != null ) { var paymentSearchCriteria = new PaymentMethodsSearchCriteria { StoreId = result . Id }; var paymentsSearchResult = await _paymentModule . SearchPaymentMethodsAsync ( paymentSearchCriteria ); result . PaymentMethods = paymentsSearchResult . Results . Where ( pm => pm . IsActive != null && pm . IsActive . Value ) . Select ( pm => { var paymentMethod = pm . ToStorePaymentMethod ( currency ); paymentMethod . Name = pm . TypeName ; return paymentMethod ; }). ToArray (); } var taxSearchCriteria = new TaxProviderSearchCriteria { StoreId = result . Id }; var taxProviderSearchResult = await _taxModule . SearchTaxProvidersAsync ( taxSearchCriteria ); result . FixedTaxRate = GetFixedTaxRate ( taxProviderSearchResult . Results . Select ( xp => xp . JsonConvert < TaxProvider >()). ToArray ()); //use url for stores from configuration file with hight priority than store url defined in manager result . Url = _storefrontOptions . StoreUrls [ result . Id ] ?? result . Url ; return result ; } file: \\Domain\\Stores\\StoreConverter.cs Error Recommendation The type or namespace name 'PaymentMethod' does not exist... The type or namespace name 'TaxDetail' does not exist... They both were moved to payment module. Therefore add appropriate using using paymentDto = VirtoCommerce.Storefront.AutoRestClients.PaymentModuleApi.Models; then rewrite storeDto.PaymentMethod as paymentDto.PaymentMethod , storeDto.TaxDetail , as paymentDto.TaxDetail file: \\Domain\\Order\\OrderConverter.cs Error Recommendation The type or namespace name 'PaymentMethod' does not exist... There meaning PaymentMethod from store module, that was moved in v3 to payment module. Therefore it is need to add appropriate using using paymentDto = VirtoCommerce.Storefront.AutoRestClients.PaymentModuleApi.Models; then rewrite storeDto.PaymentMethod as paymentDto.PaymentMethod","title":"Orders module"},{"location":"upgrade-storefront-autorest-cli-to-v3/#subscription-module","text":"Run Autorest for $modules = @('Subscription') . Wait while Autorest finishes. file: \\DependencyInjection\\ServiceCollectionExtension.cs Error Recommendation The type or namespace name 'VirtoCommerceSubscriptionRESTAPIdocumentation' could not be found... Rewrite VirtoCommerceSubscriptionRESTAPIdocumentation as SitemapsModuleClient","title":"Subscription module"},{"location":"using-autorest-with-v3/","text":"How to generate AutoRest-generated clients with the Platform v.3 Installing the Autorest NOTE: look at the documentation: Installing AutoRest Install Node.js (10.15.x LTS preferred. May not function with Node < 10.x Be Wary of 11.x builds as they may introduce instability or breaking changes. ) Install AutoRest using npm, at the moment using version 3.0.x, because the Platform generate the api as OpenApi 3.0.x cmd npm install -g @autorest/core Generate autorest client on the Storefront 1. Open Tools > NuGet Package Manager > Package Manager Console 2. Run the following commands to generate API clients: $modules = @('Cache','Cart','Catalog','Content','Core','Customer','Inventory','Marketing','Orders','Platform','Pricing','Quote','Sitemaps','Store','Subscription') $modules.ForEach( { autorest-core --v3 --debug --input-file=http://localhost:10645/docs/VirtoCommerce.$_/swagger.json --output-folder=VirtoCommerce.Storefront\\AutoRestClients --output-file=$_`ModuleApi.cs --namespace=VirtoCommerce.Storefront.AutoRestClients.$_`ModuleApi --override-client-name=$_`ModuleApi --add-credentials --csharp }) Add the api client to the ServiceColection services.AddAutoRestClient((credentials, httpClient, disposeHttpClient, baseUri) => new TaxModuleApi(credentials, httpClient, disposeHttpClient) { BaseUri = baseUri }); services.AddSingleton<ITaxModule>(sp => new TaxModule(sp.GetRequiredService<TaxModuleApi>()));","title":"How to generate AutoRest-generated clients with the Platform v.3"},{"location":"using-autorest-with-v3/#how-to-generate-autorest-generated-clients-with-the-platform-v3","text":"","title":"How to generate AutoRest-generated clients with the Platform v.3"},{"location":"using-autorest-with-v3/#installing-the-autorest","text":"NOTE: look at the documentation: Installing AutoRest Install Node.js (10.15.x LTS preferred. May not function with Node < 10.x Be Wary of 11.x builds as they may introduce instability or breaking changes. ) Install AutoRest using npm, at the moment using version 3.0.x, because the Platform generate the api as OpenApi 3.0.x cmd npm install -g @autorest/core Generate autorest client on the Storefront 1. Open Tools > NuGet Package Manager > Package Manager Console 2. Run the following commands to generate API clients: $modules = @('Cache','Cart','Catalog','Content','Core','Customer','Inventory','Marketing','Orders','Platform','Pricing','Quote','Sitemaps','Store','Subscription') $modules.ForEach( { autorest-core --v3 --debug --input-file=http://localhost:10645/docs/VirtoCommerce.$_/swagger.json --output-folder=VirtoCommerce.Storefront\\AutoRestClients --output-file=$_`ModuleApi.cs --namespace=VirtoCommerce.Storefront.AutoRestClients.$_`ModuleApi --override-client-name=$_`ModuleApi --add-credentials --csharp }) Add the api client to the ServiceColection services.AddAutoRestClient((credentials, httpClient, disposeHttpClient, baseUri) => new TaxModuleApi(credentials, httpClient, disposeHttpClient) { BaseUri = baseUri }); services.AddSingleton<ITaxModule>(sp => new TaxModule(sp.GetRequiredService<TaxModuleApi>()));","title":"Installing the Autorest"},{"location":"whats-new/","text":"What's new Table of contents What's new Table of contents Welcome to v3.0 What's new Architectural and conceptual changes For developers and architects Technology stack Application & Data DevOps and Utilities Techniques Changes in VC Platform New modules Major changes in modules Removed modules Platform v2 and v3 versions compatibility The list of code breaking changes API Database Current v3 modules Performance benchmark Welcome to v3.0 Meet the new major version of Virto Commerce Platform. Our development efforts were focused on moving to ASP.NET Core, performance, architecture improvements and further enhancements. The changes below are a subset of the larger list of changes in update to ASP.NET Core. What's new Architectural and conceptual changes For developers and architects Improved extensibility and unification Increase in development speed and decrease in time to market Unified architecture and usage of good architecture practices leads to shorter learning curve for developers who are new to Virto Commerce Cross-Platform Support: run on Windows, Mac or Linux Technology stack Application & Data .NET Core 3.1.X ASP.NET Core 3.1.X ASP.NET Core Identity ASP.NET Core SignalR OpenIddict 2.0.X Entity Framework Core 3.1.X HangFire 1.7.X AngularJS 1.4 DevOps and Utilities Docker npm Webpack xUnit Jenkins Nuke -based utility VirtoCommerce.GlobalTool (aka vc-build ) Swagger UI Techniques Caching ASP.NET Core in-memory caching is used Strongly typed cache regions and change tokens for cache dependencies Ability to manage cached objects' expiration time and disabling the caching Hybrid caching policy for keeping cached data consistent in multiple Platform instances The dedicated \"VirtoCommerce.Cache\" module was removed; now caching is implemented in place where it is needed Dependency injection (DI) Unity DI replaced by built-in .NET Core DI ( Microsoft.Extensions.DependencyInjection ) Development Virto Commerce developmet switched to GitFlow Workflow model GitVersion tool to ease Semantic Versioning Both Platform and all modules repository structure unified to have build , docs , src , tests folders on the top. The recommended structure of a module solution was updated: Permissions , Settings and other constants should be defined in the .Core project Caching should be defined and done in the .Data project All v3 modules were refactored to follow the recommended structure All methods in search and CRUD services made asynchronous: Returning async Task or async Task<T> The methods renamed to end with \"Async\" All API controller methods made asynchronous: Returning async Task or async Task<T> The endpoint names left unchanged for backward compatibility ( not ending with \"Async\") DevOps Nuke - Build Automation System for C#/.NET aka VirtoCommerce.GlobalTool Dynamic properties Dynamic properties registration logic changed. Now manual registration used instead of reflection Export/Import Export/Import is now streamed for all modules Security Now permissions are defined only in design-time using a special fluent syntax Localization for permissions added Storefront switched to work using barrier token authentication Settings Settings are defined in design-time, using special fluent syntax Localization for settings added Now setting value can be changed using any .NET Core configuration provider Modularity Module.manifest file structure changed (scripts, styles, settings and permissions declarations removed) IModule abstraction changed to have only Initialize and PostInitialize methods; Module.cs structure simplified. Persistency infrastructure Object-relational mapper (ORM) switched to Entity Framework Core (EF Core) New EF Core migrations generated Only Table per Hierarchy (TPH, hierarchy mapping to a single table) inheritance model now supported DbContext defined separately from repository EntityFramework.Triggers for auditing and change logging Calls to DbContext methods refactored to be asynchronous Changes in VC Platform Solution code structure Functionality specific implementations were split into dedicated projects (Assets, Modules, etc.) Configuration and Options ASP.NET Core configuration providers used together with the options pattern . Modularity Assembly and dependency loading completely reworked into platform process Security Authentification and authorization fully updated to ASP.NET Core Identity without any extensions OpenIddict used as an OpenID Connect server to support all OAuth flows; it's also used for token based authentication OAuth2 Password and Client credentials flow for Machine to Machine (M2M) applications HMAC and simple key authorization support removed for API calls Logging Built-in .NET Core ILogger abstraction and logic instead of ICommonLogging and NLog Virto Commerce Manager app Webpack + npm instead of Gulp + Bower New make-up for Commerce Manager app UI New modules Notifications module (written from scratch) Functionality, which was spread across the system, now gathered into a dedicated module Unlimited channel types for notification sending (email, SMS, social networks, etc.): Notification availability management for each store Possibility to activate/deactivate each notification individually for each store New flexible extendibility model Notification template preview with data Support of LIQUID syntax for templates based on Scriban engine New notification messages feed enables to search and preview individual messages Enhanced notifications management UI Tax module Tax calculation functionality, which was spread across the system, now gathered into a dedicated module, responsible for tax settings and calculation The new module is a single integration point for third party software and custom extensions Shipping module Shipping costs calculation functionality, which was spread across the system, now gathered into a dedicated module, responsible for shipping methods, related settings and shipping costs calculation The new module is a single integration point for third party software and custom extensions Payment module Payment methods functionality and integrations, which were spread across the system, now gathered into a dedicated module, responsible for payment methods and related settings The new module is a single point for payment gateways integrations Search module Provides a generic UI and programming components for indexed search The new module is a single point for search engine integrations Major changes in modules Commerce core module VirtoCommerce.Domain project removed Now each module self-defines domain model and abstractions in corresponding .Core projects. Multiple packages from corresponding modules will be distributed instead. Nuget package VirtoCommerce.Domain was left unupdated from previous version. There won't be any update to v3, nor any replacement package in v3. Common functionality and model moved from Virto Commerce dynamic expression library module Catalog module support for model extending added VirtoCommerce.CatalogModule.Web.Core project removed. Model from .Core project used in API directly Marketing module \"Dynamic expression\" building refactored to \"compile time\" expressions New serialization logic for expressions. Serialized expression format changed to JSON (backwards compatible) Removed modules Smart caching module Now caching is implemented in place where it is needed (Platform and modules) Virto Commerce dynamic expression library module Common functionality and model moved to Commerce core module Module specific functionality was split to corresponding modules (Marketing, Pricing, etc.) Platform v2 and v3 versions compatibility The list of code breaking changes The following list of breaking changes have the potential to break existing solutions when upgrading them to 3.x API Both versions are compatible on API level. API clients should be able to switch between the versions only by changing the Platform endpoint URL and credentials v2 and v3 swagger API specifications comparison generated by swagger-diff tool: v2v3Changelog.html Database The v2 and v3 databases have structural differences; Special migrations were added to upgrade Platform and VC modules from v2 database to v3 automatically ; Any database related extensions made in custom modules, should be upgraded by adding special DB migrations in module code (no manual changes to DB) Any custom existing v2 database should be upgraded before using by Platform v3 Current v3 modules Id Title Version VirtoCommerce.Core Commerce core module 3.0.X VirtoCommerce.AzureSearch Azure Search module 3.0.X VirtoCommerce.Cart Shopping cart module 3.0.X VirtoCommerce.Catalog Catalog module 3.0.X VirtoCommerce.Content CMS Content module 3.0.X VirtoCommerce.Customer Customer management module 3.0.X VirtoCommerce.ElasticSearch Elastic Search module 3.0.X VirtoCommerce.Export Export module 3.0.X VirtoCommerce.ImageTools Image tools module 3.0.X VirtoCommerce.Inventory Inventory module 3.0.X VirtoCommerce.LuceneSearch Lucene Search module 3.0.X VirtoCommerce.Marketing Marketing module 3.0.X VirtoCommerce.Notifications Notifications module 3.0.X VirtoCommerce.Orders Orders module 3.0.X VirtoCommerce.Payment Payment module 3.0.X VirtoCommerce.Pricing Pricing module 3.0.X VirtoCommerce.Search Search module 3.0.X VirtoCommerce.Shipping Shipping module 3.0.X VirtoCommerce.Sitemaps Sitemaps module 3.0.X VirtoCommerce.Store Store module 3.0.X VirtoCommerce.Subscription Subscription module 3.0.X VirtoCommerce.Tax Tax module 3.0.X List of currently released v3 modules till the moment of writing. Additional modules might have been added. Performance benchmark","title":"Whats new"},{"location":"whats-new/#whats-new","text":"","title":"What's new"},{"location":"whats-new/#table-of-contents","text":"What's new Table of contents Welcome to v3.0 What's new Architectural and conceptual changes For developers and architects Technology stack Application & Data DevOps and Utilities Techniques Changes in VC Platform New modules Major changes in modules Removed modules Platform v2 and v3 versions compatibility The list of code breaking changes API Database Current v3 modules Performance benchmark","title":"Table of contents"},{"location":"whats-new/#welcome-to-v30","text":"Meet the new major version of Virto Commerce Platform. Our development efforts were focused on moving to ASP.NET Core, performance, architecture improvements and further enhancements. The changes below are a subset of the larger list of changes in update to ASP.NET Core.","title":"Welcome to v3.0"},{"location":"whats-new/#whats-new_1","text":"","title":"What's new"},{"location":"whats-new/#architectural-and-conceptual-changes","text":"","title":"Architectural and conceptual changes"},{"location":"whats-new/#for-developers-and-architects","text":"Improved extensibility and unification Increase in development speed and decrease in time to market Unified architecture and usage of good architecture practices leads to shorter learning curve for developers who are new to Virto Commerce Cross-Platform Support: run on Windows, Mac or Linux","title":"For developers and architects"},{"location":"whats-new/#technology-stack","text":"","title":"Technology stack"},{"location":"whats-new/#application-data","text":".NET Core 3.1.X ASP.NET Core 3.1.X ASP.NET Core Identity ASP.NET Core SignalR OpenIddict 2.0.X Entity Framework Core 3.1.X HangFire 1.7.X AngularJS 1.4","title":"Application &amp; Data"},{"location":"whats-new/#devops-and-utilities","text":"Docker npm Webpack xUnit Jenkins Nuke -based utility VirtoCommerce.GlobalTool (aka vc-build ) Swagger UI","title":"DevOps and Utilities"},{"location":"whats-new/#techniques","text":"Caching ASP.NET Core in-memory caching is used Strongly typed cache regions and change tokens for cache dependencies Ability to manage cached objects' expiration time and disabling the caching Hybrid caching policy for keeping cached data consistent in multiple Platform instances The dedicated \"VirtoCommerce.Cache\" module was removed; now caching is implemented in place where it is needed Dependency injection (DI) Unity DI replaced by built-in .NET Core DI ( Microsoft.Extensions.DependencyInjection ) Development Virto Commerce developmet switched to GitFlow Workflow model GitVersion tool to ease Semantic Versioning Both Platform and all modules repository structure unified to have build , docs , src , tests folders on the top. The recommended structure of a module solution was updated: Permissions , Settings and other constants should be defined in the .Core project Caching should be defined and done in the .Data project All v3 modules were refactored to follow the recommended structure All methods in search and CRUD services made asynchronous: Returning async Task or async Task<T> The methods renamed to end with \"Async\" All API controller methods made asynchronous: Returning async Task or async Task<T> The endpoint names left unchanged for backward compatibility ( not ending with \"Async\") DevOps Nuke - Build Automation System for C#/.NET aka VirtoCommerce.GlobalTool Dynamic properties Dynamic properties registration logic changed. Now manual registration used instead of reflection Export/Import Export/Import is now streamed for all modules Security Now permissions are defined only in design-time using a special fluent syntax Localization for permissions added Storefront switched to work using barrier token authentication Settings Settings are defined in design-time, using special fluent syntax Localization for settings added Now setting value can be changed using any .NET Core configuration provider Modularity Module.manifest file structure changed (scripts, styles, settings and permissions declarations removed) IModule abstraction changed to have only Initialize and PostInitialize methods; Module.cs structure simplified. Persistency infrastructure Object-relational mapper (ORM) switched to Entity Framework Core (EF Core) New EF Core migrations generated Only Table per Hierarchy (TPH, hierarchy mapping to a single table) inheritance model now supported DbContext defined separately from repository EntityFramework.Triggers for auditing and change logging Calls to DbContext methods refactored to be asynchronous","title":"Techniques"},{"location":"whats-new/#changes-in-vc-platform","text":"Solution code structure Functionality specific implementations were split into dedicated projects (Assets, Modules, etc.) Configuration and Options ASP.NET Core configuration providers used together with the options pattern . Modularity Assembly and dependency loading completely reworked into platform process Security Authentification and authorization fully updated to ASP.NET Core Identity without any extensions OpenIddict used as an OpenID Connect server to support all OAuth flows; it's also used for token based authentication OAuth2 Password and Client credentials flow for Machine to Machine (M2M) applications HMAC and simple key authorization support removed for API calls Logging Built-in .NET Core ILogger abstraction and logic instead of ICommonLogging and NLog Virto Commerce Manager app Webpack + npm instead of Gulp + Bower New make-up for Commerce Manager app UI","title":"Changes in VC Platform"},{"location":"whats-new/#new-modules","text":"Notifications module (written from scratch) Functionality, which was spread across the system, now gathered into a dedicated module Unlimited channel types for notification sending (email, SMS, social networks, etc.): Notification availability management for each store Possibility to activate/deactivate each notification individually for each store New flexible extendibility model Notification template preview with data Support of LIQUID syntax for templates based on Scriban engine New notification messages feed enables to search and preview individual messages Enhanced notifications management UI Tax module Tax calculation functionality, which was spread across the system, now gathered into a dedicated module, responsible for tax settings and calculation The new module is a single integration point for third party software and custom extensions Shipping module Shipping costs calculation functionality, which was spread across the system, now gathered into a dedicated module, responsible for shipping methods, related settings and shipping costs calculation The new module is a single integration point for third party software and custom extensions Payment module Payment methods functionality and integrations, which were spread across the system, now gathered into a dedicated module, responsible for payment methods and related settings The new module is a single point for payment gateways integrations Search module Provides a generic UI and programming components for indexed search The new module is a single point for search engine integrations","title":"New modules"},{"location":"whats-new/#major-changes-in-modules","text":"Commerce core module VirtoCommerce.Domain project removed Now each module self-defines domain model and abstractions in corresponding .Core projects. Multiple packages from corresponding modules will be distributed instead. Nuget package VirtoCommerce.Domain was left unupdated from previous version. There won't be any update to v3, nor any replacement package in v3. Common functionality and model moved from Virto Commerce dynamic expression library module Catalog module support for model extending added VirtoCommerce.CatalogModule.Web.Core project removed. Model from .Core project used in API directly Marketing module \"Dynamic expression\" building refactored to \"compile time\" expressions New serialization logic for expressions. Serialized expression format changed to JSON (backwards compatible)","title":"Major changes in modules"},{"location":"whats-new/#removed-modules","text":"Smart caching module Now caching is implemented in place where it is needed (Platform and modules) Virto Commerce dynamic expression library module Common functionality and model moved to Commerce core module Module specific functionality was split to corresponding modules (Marketing, Pricing, etc.)","title":"Removed modules"},{"location":"whats-new/#platform-v2-and-v3-versions-compatibility","text":"","title":"Platform v2 and v3 versions compatibility"},{"location":"whats-new/#the-list-of-code-breaking-changes","text":"The following list of breaking changes have the potential to break existing solutions when upgrading them to 3.x","title":"The list of code breaking changes"},{"location":"whats-new/#api","text":"Both versions are compatible on API level. API clients should be able to switch between the versions only by changing the Platform endpoint URL and credentials v2 and v3 swagger API specifications comparison generated by swagger-diff tool: v2v3Changelog.html","title":"API"},{"location":"whats-new/#database","text":"The v2 and v3 databases have structural differences; Special migrations were added to upgrade Platform and VC modules from v2 database to v3 automatically ; Any database related extensions made in custom modules, should be upgraded by adding special DB migrations in module code (no manual changes to DB) Any custom existing v2 database should be upgraded before using by Platform v3","title":"Database"},{"location":"whats-new/#current-v3-modules","text":"Id Title Version VirtoCommerce.Core Commerce core module 3.0.X VirtoCommerce.AzureSearch Azure Search module 3.0.X VirtoCommerce.Cart Shopping cart module 3.0.X VirtoCommerce.Catalog Catalog module 3.0.X VirtoCommerce.Content CMS Content module 3.0.X VirtoCommerce.Customer Customer management module 3.0.X VirtoCommerce.ElasticSearch Elastic Search module 3.0.X VirtoCommerce.Export Export module 3.0.X VirtoCommerce.ImageTools Image tools module 3.0.X VirtoCommerce.Inventory Inventory module 3.0.X VirtoCommerce.LuceneSearch Lucene Search module 3.0.X VirtoCommerce.Marketing Marketing module 3.0.X VirtoCommerce.Notifications Notifications module 3.0.X VirtoCommerce.Orders Orders module 3.0.X VirtoCommerce.Payment Payment module 3.0.X VirtoCommerce.Pricing Pricing module 3.0.X VirtoCommerce.Search Search module 3.0.X VirtoCommerce.Shipping Shipping module 3.0.X VirtoCommerce.Sitemaps Sitemaps module 3.0.X VirtoCommerce.Store Store module 3.0.X VirtoCommerce.Subscription Subscription module 3.0.X VirtoCommerce.Tax Tax module 3.0.X List of currently released v3 modules till the moment of writing. Additional modules might have been added.","title":"Current v3 modules"},{"location":"whats-new/#performance-benchmark","text":"","title":"Performance benchmark"},{"location":"lessons/lesson1/","text":"Summary Use this guide to deploy and configure precompiled Virto Commerce Platform (backend) and Virto Commerce Storefront (frontend). Video Part 1. How to deploy and configure Virto Commerce Platform Part 2. How to deploy and configure Virto Commerce Storefront Prerequisites Windows Server 2008 R2 SP1 or later Enable Internet Information Services. You may use PowerShell command: Install-WindowsFeature -name Web-Server -IncludeAllSubFeature Microsoft .NET Framework 4.6.1 Microsoft SQL Server 2008 or later with SQL Management Studio(free MS SQL Express would be enough) Visual C++ Redistributable Packages for Visual Studio Prerequisites for .NET Core on Windows .NET Core Runtime Initial configuration of VirtoCommerce Platform (backend) Navigate to the Releases section of Virto Commerce Platform in GitHub. You will find and download VirtoCommerce.Platform.2.x.x.zip file. Unpack follow zip to the web server in IIS application root directory C:\\inetpub\\wwwroot\\admin . If there is no admin directory inside wwwroot , create it manually or with PowerShell commands: $folder=\"C:\\inetpub\\wwwroot\\admin\" New-Item -ItemType directory -Path $folder -Force Setup of Virto Commerce Platform Configure connection strings Open the C:\\inetpub\\wwwroot\\admin\\Web.config file in a text editor. In the connectionStrings section find the add node: VirtoCommerce : parameters for SQL server database. Change (local) to IP address of your SQL Server. For locally running instance SQL Express set Data Source=.\\SQLEXPRESS . <add name=\"VirtoCommerce\" connectionString=\"Data Source=(local);Initial Catalog=VirtoCommerce2;Persist Security Info=True;User ID=virto;Password=virto;MultipleActiveResultSets=True;Connect Timeout=420\" providerName=\"System.Data.SqlClient\" /> Create virto user in SQL Server Manager Open SQL Server Manager and connect to the local sql server on Database Engine. Add to Security/Logins new login name virto with password virto, give him in Server Roles dbcreator and public roles. Configure permissions for admin folder of VirtoCommerce Platform Open properties for C:\\inetpub\\wwwroot\\admin folder and give permission Modify to IIS_IUSRS user group. The same can be done with PowerShell commands: $acl = Get-Acl $folder $acl.SetAccessRuleProtection($True, $True) Set-Acl -Path $folder -AclObject $acl $permission = \"BUILTIN\\IIS_IUSRS\",\"Modify, Synchronize\", \"ContainerInherit, ObjectInherit\", \"None\", \"Allow\" $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission $acl.SetAccessRule($accessRule) $acl | Set-Acl $folder Configure IIS Open the IIS Manager and create a new application named admin inside an existing Default Web Site . In the Physical path field enter the full path to the platform site data folder C:\\inetpub\\wwwroot\\admin . Select application pool named DefaultAppPool which uses .NET CLR Version 4.0 and Integrated pipeline mode. Inside the admin application add the new virtual directory with alias assets and physical path C:\\inetpub\\wwwroot\\admin\\App_Data\\Assets . If there is no Assets directory inside App_Data , create it manually or with PowerShell commands: $folder=\"C:\\inetpub\\wwwroot\\admin\\App_Data\\Assets\" New-Item -ItemType directory -Path $folder -Force First sign in Open the Virto Commerce Platform application in the browser - in the IIS Manager select admin and click on right column to \"Browse *:80(http)\". On the first request the application will create and initialize Virtocommerce2 database . Wait a minute... After that you should see the sign in page. Use the following credentials: Login: admin . Password: store . Modules auto installation Next step - platform modules auto installation, after that you should click the Restart button. Sample data installation After restart you should see next page with possibillity to sample data installation (you should choose Closing and Electronics option - new products would be added to your Virtocommerce2 database). Change administrator password After Sample data installation step completed user is forced to change the password. Change frontend password In the left menu select More > Configuration > Security . Select Users . Select the frontend user. Click Change password . Enter the new password twice and click OK . Change API credentials for storefront application In the left menu select More > Configuration > Security . Select Users . Select the frontend user. Click the API Keys widget. Select the Frontend Hmac key. Click Generate , then OK , then Save . Initial configuration of VirtoCommerce Storefront (frontend) Navigate to the Releases section of Virto Commerce Storefront in GitHub. You will find and download VirtoCommerce.Storefront.4.x.x.zip file. Create new folder named C:\\vc-storefront-core manually or with PowerShell commands: $folder=\"C:\\vc-storefront-core\" New-Item -ItemType directory -Path $folder -Force and unpack this zip file to this folder of web server. Setup of Virto Commerce Storefront Configuring VirtoCommerce Platform Endpoint Open the C:\\vc-storefront-core\\appsettings.json in a text editor. In the VirtoCommerce section find the node named Endpoint . Make sure that its Url attribute value is http://localhost/admin . Make sure that AppId and SecretKey attributes values is set to the values obtained earlier in the Change API credentials for storefront application step. ... \"VirtoCommerce\": { \"Endpoint\": { //Virto Commerce platform manager url \"Url\": \"http://localhost/admin\", //HMAC authentification user credentials on whose behalf the API calls will be made. \"AppId\": \"Enter your AppId here\", \"SecretKey\": \"Enter your SecretKey here\", } ... Configure CMS content storage Open the appsettings.json in a text editor. In the ConnectionStrings section find the attribute named ContentConnectionString . Make sure that its rootPath value is ~/App_Data/cms-content . ... \"ConnectionStrings\": { //For themes stored in local file system \"ContentConnectionString\": \"provider=LocalStorage;rootPath=~/cms-content\" } ... Platform already contains ~/App_Data/cms-content folder with themes for sample stores it was configured earlier in the Configure IIS step You need to make symbolic link to this folder by this command: mklink /d C:\\vc-storefront-core\\wwwroot\\cms-content C:\\inetpub\\wwwroot\\admin\\App_Data\\cms-content Running the Storefont There are 2 options for launching the application: Running the Storefont by CLI \"dotnet run\". Deploying the Storefont to IIS. Running the Storefont by CLI \"dotnet run\" Open command prompt console. Change working directory to the C:\\vc-storefront-core . cd C:\\vc-storefront-core Run the Storefront by following command: dotnet.exe C:\\vc-storefront-core\\VirtoCommerce.Storefront.dll The output in the console will say something like: Now listening on: http://localhost:5000 Running the Storefont by IIS Restart IIS service. net stop was /y net start w3svc Open IIS Manager and add a new Website named Storefront . Select application pool named DefaultAppPool . In the Physical path field enter the full path to the storefront folder C:\\vc-storefront-core . In the Port field enter the new Web site port binding 8080 . Now you could first open the local VirtoCommerce Storefront instance for the first time. Navigate to: http://localhost:5000 if the application deployed by \"dotnet run\"; or http://localhost:8080 in case IIS.","title":"Lesson 1 - How to deploy and configure Virto Commerce"},{"location":"lessons/lesson1/#summary","text":"Use this guide to deploy and configure precompiled Virto Commerce Platform (backend) and Virto Commerce Storefront (frontend).","title":"Summary"},{"location":"lessons/lesson1/#video","text":"Part 1. How to deploy and configure Virto Commerce Platform Part 2. How to deploy and configure Virto Commerce Storefront","title":"Video"},{"location":"lessons/lesson1/#prerequisites","text":"Windows Server 2008 R2 SP1 or later Enable Internet Information Services. You may use PowerShell command: Install-WindowsFeature -name Web-Server -IncludeAllSubFeature Microsoft .NET Framework 4.6.1 Microsoft SQL Server 2008 or later with SQL Management Studio(free MS SQL Express would be enough) Visual C++ Redistributable Packages for Visual Studio Prerequisites for .NET Core on Windows .NET Core Runtime","title":"Prerequisites"},{"location":"lessons/lesson1/#initial-configuration-of-virtocommerce-platform-backend","text":"Navigate to the Releases section of Virto Commerce Platform in GitHub. You will find and download VirtoCommerce.Platform.2.x.x.zip file. Unpack follow zip to the web server in IIS application root directory C:\\inetpub\\wwwroot\\admin . If there is no admin directory inside wwwroot , create it manually or with PowerShell commands: $folder=\"C:\\inetpub\\wwwroot\\admin\" New-Item -ItemType directory -Path $folder -Force","title":"Initial configuration of VirtoCommerce Platform (backend)"},{"location":"lessons/lesson1/#setup-of-virto-commerce-platform","text":"","title":"Setup of Virto Commerce Platform"},{"location":"lessons/lesson1/#configure-connection-strings","text":"Open the C:\\inetpub\\wwwroot\\admin\\Web.config file in a text editor. In the connectionStrings section find the add node: VirtoCommerce : parameters for SQL server database. Change (local) to IP address of your SQL Server. For locally running instance SQL Express set Data Source=.\\SQLEXPRESS . <add name=\"VirtoCommerce\" connectionString=\"Data Source=(local);Initial Catalog=VirtoCommerce2;Persist Security Info=True;User ID=virto;Password=virto;MultipleActiveResultSets=True;Connect Timeout=420\" providerName=\"System.Data.SqlClient\" />","title":"Configure connection strings"},{"location":"lessons/lesson1/#create-virto-user-in-sql-server-manager","text":"Open SQL Server Manager and connect to the local sql server on Database Engine. Add to Security/Logins new login name virto with password virto, give him in Server Roles dbcreator and public roles.","title":"Create virto user in SQL Server Manager"},{"location":"lessons/lesson1/#configure-permissions-for-admin-folder-of-virtocommerce-platform","text":"Open properties for C:\\inetpub\\wwwroot\\admin folder and give permission Modify to IIS_IUSRS user group. The same can be done with PowerShell commands: $acl = Get-Acl $folder $acl.SetAccessRuleProtection($True, $True) Set-Acl -Path $folder -AclObject $acl $permission = \"BUILTIN\\IIS_IUSRS\",\"Modify, Synchronize\", \"ContainerInherit, ObjectInherit\", \"None\", \"Allow\" $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission $acl.SetAccessRule($accessRule) $acl | Set-Acl $folder","title":"Configure permissions for admin folder of VirtoCommerce Platform"},{"location":"lessons/lesson1/#configure-iis","text":"Open the IIS Manager and create a new application named admin inside an existing Default Web Site . In the Physical path field enter the full path to the platform site data folder C:\\inetpub\\wwwroot\\admin . Select application pool named DefaultAppPool which uses .NET CLR Version 4.0 and Integrated pipeline mode. Inside the admin application add the new virtual directory with alias assets and physical path C:\\inetpub\\wwwroot\\admin\\App_Data\\Assets . If there is no Assets directory inside App_Data , create it manually or with PowerShell commands: $folder=\"C:\\inetpub\\wwwroot\\admin\\App_Data\\Assets\" New-Item -ItemType directory -Path $folder -Force","title":"Configure IIS"},{"location":"lessons/lesson1/#first-sign-in","text":"Open the Virto Commerce Platform application in the browser - in the IIS Manager select admin and click on right column to \"Browse *:80(http)\". On the first request the application will create and initialize Virtocommerce2 database . Wait a minute... After that you should see the sign in page. Use the following credentials: Login: admin . Password: store .","title":"First sign in"},{"location":"lessons/lesson1/#modules-auto-installation","text":"Next step - platform modules auto installation, after that you should click the Restart button.","title":"Modules auto installation"},{"location":"lessons/lesson1/#sample-data-installation","text":"After restart you should see next page with possibillity to sample data installation (you should choose Closing and Electronics option - new products would be added to your Virtocommerce2 database).","title":"Sample data installation"},{"location":"lessons/lesson1/#change-administrator-password","text":"After Sample data installation step completed user is forced to change the password.","title":"Change administrator password"},{"location":"lessons/lesson1/#change-frontend-password","text":"In the left menu select More > Configuration > Security . Select Users . Select the frontend user. Click Change password . Enter the new password twice and click OK .","title":"Change frontend password"},{"location":"lessons/lesson1/#change-api-credentials-for-storefront-application","text":"In the left menu select More > Configuration > Security . Select Users . Select the frontend user. Click the API Keys widget. Select the Frontend Hmac key. Click Generate , then OK , then Save .","title":"Change API credentials for storefront application"},{"location":"lessons/lesson1/#initial-configuration-of-virtocommerce-storefront-frontend","text":"Navigate to the Releases section of Virto Commerce Storefront in GitHub. You will find and download VirtoCommerce.Storefront.4.x.x.zip file. Create new folder named C:\\vc-storefront-core manually or with PowerShell commands: $folder=\"C:\\vc-storefront-core\" New-Item -ItemType directory -Path $folder -Force and unpack this zip file to this folder of web server.","title":"Initial configuration of VirtoCommerce Storefront (frontend)"},{"location":"lessons/lesson1/#setup-of-virto-commerce-storefront","text":"","title":"Setup of Virto Commerce Storefront"},{"location":"lessons/lesson1/#configuring-virtocommerce-platform-endpoint","text":"Open the C:\\vc-storefront-core\\appsettings.json in a text editor. In the VirtoCommerce section find the node named Endpoint . Make sure that its Url attribute value is http://localhost/admin . Make sure that AppId and SecretKey attributes values is set to the values obtained earlier in the Change API credentials for storefront application step. ... \"VirtoCommerce\": { \"Endpoint\": { //Virto Commerce platform manager url \"Url\": \"http://localhost/admin\", //HMAC authentification user credentials on whose behalf the API calls will be made. \"AppId\": \"Enter your AppId here\", \"SecretKey\": \"Enter your SecretKey here\", } ...","title":"Configuring VirtoCommerce Platform Endpoint"},{"location":"lessons/lesson1/#configure-cms-content-storage","text":"Open the appsettings.json in a text editor. In the ConnectionStrings section find the attribute named ContentConnectionString . Make sure that its rootPath value is ~/App_Data/cms-content . ... \"ConnectionStrings\": { //For themes stored in local file system \"ContentConnectionString\": \"provider=LocalStorage;rootPath=~/cms-content\" } ... Platform already contains ~/App_Data/cms-content folder with themes for sample stores it was configured earlier in the Configure IIS step You need to make symbolic link to this folder by this command: mklink /d C:\\vc-storefront-core\\wwwroot\\cms-content C:\\inetpub\\wwwroot\\admin\\App_Data\\cms-content","title":"Configure CMS content storage"},{"location":"lessons/lesson1/#running-the-storefont","text":"There are 2 options for launching the application: Running the Storefont by CLI \"dotnet run\". Deploying the Storefont to IIS.","title":"Running the Storefont"},{"location":"lessons/lesson1/#running-the-storefont-by-cli-dotnet-run","text":"Open command prompt console. Change working directory to the C:\\vc-storefront-core . cd C:\\vc-storefront-core Run the Storefront by following command: dotnet.exe C:\\vc-storefront-core\\VirtoCommerce.Storefront.dll The output in the console will say something like: Now listening on: http://localhost:5000","title":"Running the Storefont by CLI \"dotnet run\""},{"location":"lessons/lesson1/#running-the-storefont-by-iis","text":"Restart IIS service. net stop was /y net start w3svc Open IIS Manager and add a new Website named Storefront . Select application pool named DefaultAppPool . In the Physical path field enter the full path to the storefront folder C:\\vc-storefront-core . In the Port field enter the new Web site port binding 8080 . Now you could first open the local VirtoCommerce Storefront instance for the first time. Navigate to: http://localhost:5000 if the application deployed by \"dotnet run\"; or http://localhost:8080 in case IIS.","title":"Running the Storefont by IIS"},{"location":"lessons/lesson2/","text":"Summary Use this guide to import new products into Virto Commerce Platform (backend) catalog and can observe them locally on Virto Commerce Storefront (frontend). Prerequisites You need to have locally preinstalled Virto Commerce Platform (backend) and Virto Commerce Storefront (frontend) - see how to deploy and open them in Lesson 1 . Download the electronics-new-products-example.csv file with new products. Download the images-example.zip file and extract the content. There will be 15 images of new products. Microsoft Excel, LibreOffice( free ) or any other .csv file editor. Create catalog data file in .csv format In order to have a file with your own products like downloaded electronics-new-products-example.csv , you need to create new .csv file in csv file editor. * In Excel just select the product properties you need from the list and fill in the product properties columns as in our document. Set the PrimaryImage column values to URLs to your images in Assets . * In LibreOffice you need to create table with the number of columns equal to the number of properties of your products and fill it. For a delimiter, select a comma. * Save file in .csv format. Create new Catalog or use an existing one Open Virto Commerce Platform (see how to deploy and open it in Lesson 1 ) There are 2 scenarios for adding new products: adding to a new catalog or to an existing one. Creating new category and subcategory To create new category in Electronics catalog click on More > Catalog > Electronics> click +Add > choose Category > fill category name Laptops and code (optional), click Create button. Click on the Laptops in categories list. To create new subcategory, click +Add > choose Category > add category name Asus-Laptops and code (optional), click Create . By clicking on More > Catalog > Electronics > Laptops > Asus-Laptops you will see all created categories. If you want to get Asus-Laptops CategoryId for using it in .csv file - click on categories list menu, select Id by check box and copy the Id value. Using an existing catalog and category Click on More > Catalog . Select the catalog and category names in which you want to add new products, click on categories list menu, select Id by check box and copy category Id value to use in your .csv file. Upload images for new products You need to add images for products: go to More > Assets > catalog > click on the New folder icon, type ASUS folder name, click Ok button. Click on the Upload icon. An Asset upload blade opens. Select all the previously extracted sample images from images-example.zip in File Explorer and drag&drop onto specified area. Now you should see all images in the ASUS folder uploaded. Importing and mapping your catalog data into Virto Commerce At the top of the Asus-Laptops category blade click the Import icon > VirtoCommerce CSV import > select Semicolon in Csv column delimiter > click on the image and select electronics-new-products-example.csv file to upload. Wait a little... Note: importing new products from the file without specifying either the category id or the category path in it, defaults to the root directory - to the catalog. After uploading your data, click on Map columns . On this blade you will see and configure how the properties of your products will be mapped to the default properties defined in application, just so they will be saved to the database after you click buttons Ok and Start Import . Wait a little... Open new products in Virto Commerce Platform ( backend ) Now you can see and edit all new products by navigating to More > Catalog > Electronics > Laptops > Asus-Laptops : Creating a new menu item in Virto Commerce Storefront ( frontend ) To add new category to menu in Virto Commerce Storefront ( frontend ) open Virto Commerce Platform ( backend ), click on More > Content > Link lists inside Electronics > en-US main-menu > icon +Add link and fill Link Title - Laptops , URL - ~/laptops , Links to - Category , Linked object - Laptops : click on button Select > Electronics , select Laptops via check box and click on icon +Pick selected , save changes. To add new link for subcategory Asus Laptops to menu in Virto Commerce Storefront( frontend ) open Virto Commerce Platform ( backend ), click on More > Content > Link lists in Electronics > icon +Add . Fill Name - Laptops , Language - en-US , Link Title - Asus Laptops , URL - ~/asus-laptops , click Create button. Creating thumbnails for new product images Now you need to generate thumbnails for new images. * Do this step only once: create new task for thumbnails generation: navigate to More > Thumbnails > click on +Add icon, enter Name - catalog images , Path to images - /catalog , click on pen\u0441il icon near Thumbnail settings and on +Add icon. Create and save thumbnail option details: Name - 348x348 , Thumbnail file name suffix - 348x348 , Resize method - FixedSize , Width (pixels) - 348 , Height (pixels) - 348 , Anchor position - Center . Similarly add details for 3 other resolutions: 216x216, 168x168, 64x64 . Can close only Thumbnails settings blade now. Put the cursor in the Thumbnail settings field (in New thumbnails generation task blade), add all the previously created settings, save new thumbnails generation task. Select catalog images task in Thumbnails generation tasks list blade by check box, click on !Run icon, click Regenerate button in pop-up dialog. Wait a little... all done. If you'd add new pictures later, select the Process changes button to generate thumbnails only for them. Build search indexes and reset cache The search indexes are updated by the system every 5 minutes by default. In order to build the indexes for new categories and products immediately, navigate to More > Search index > select all document types via check boxes, click on Build index icon, in pop-up dialog click Build button. You need to reset Storefront cache after building the indexes. Navigate to More > Stores > Electronics > click Reset cache in Store details blade and click Ok button in the dialog. Open new products in Virto Commerce Storefront ( frontend ) Open Virto Commerce Storefront locally (see how to deploy and open it in Lesson 1 ). Now you can see new menu item Laptops , new subitem Asus Laptops and all new products in Virto Commerce Storefront. Appendix 1: Default Product properties in Virto Commerce In order to create a new catalog items .csv file, you need to know which defined product properties you can use: Property Name Data Type Example Name (required) text Asus VivoBook W202NA-DH02 Rugged 11.6-inch Windows 10 Home Laptop Id text Sku text CategoryPath (required if CategoryId is empty) text Laptops/Asus-Laptops CategoryId (required if CategoryPath is empty) text MainProductId text PrimaryImage (image url in app) text http://localhost/admin/assets/catalog/ASUS/99bb9e00c.jpg AltImage text asus-vivobook-w202na-dh02 SeoUrl text asus-vivobook-w202na-dh02 SeoTitle text SeoDescription text SeoLanguage text en-US SeoStore (Id of Store) text Review number (0 or 1) 1 ReviewType text FullReview(or QuickReview) IsActive number (0 or 1) 1 IsBuyable number (0 or 1) 1 TrackInventory number (0 or 1) 1 PriceId text SalePrice number 199.5 ListPrice (required) number 199.5 Currency text USD PriceListId text Quantity (required, 0 and more) number 25 ManufacturerPartNumber text ASDJHG34GH-23 Gtin text MeasureUnit text mm WeightUnit text gram Weight number 125 Height number 125 Length number 125 Width number 125 TaxType text ProductType text Physical(or Digital) ShippingType text Vendor text Asus DownloadType text Standard Product(or Software, or Music) DownloadExpiration date 2018-04-05 21:47 HasUserAgreement number (0 or 1) 1 In order to import your custom product property, you need to define it: in Virto Commerce Platform find the particular category > click on its name by right mouse button and select Manage > Properties > +Add property . Fill Property name, Display name - in English and German, enable Multi language switch, if the property can have multiple values - enable Multivalue switch, select Product in \"Applies to\" and choose Value Type. Set up Validation rules and Attributes if needed. Click Save in Manage property blade and Ok buttons in Properties list of your category. Now you can add column with the same name to .csv file. The property value would be filled with the column value automatically for all products of this category during import.","title":"Lesson 2 - How to import new products into Virto Commerce catalog"},{"location":"lessons/lesson2/#summary","text":"Use this guide to import new products into Virto Commerce Platform (backend) catalog and can observe them locally on Virto Commerce Storefront (frontend).","title":"Summary"},{"location":"lessons/lesson2/#prerequisites","text":"You need to have locally preinstalled Virto Commerce Platform (backend) and Virto Commerce Storefront (frontend) - see how to deploy and open them in Lesson 1 . Download the electronics-new-products-example.csv file with new products. Download the images-example.zip file and extract the content. There will be 15 images of new products. Microsoft Excel, LibreOffice( free ) or any other .csv file editor.","title":"Prerequisites"},{"location":"lessons/lesson2/#create-catalog-data-file-in-csv-format","text":"In order to have a file with your own products like downloaded electronics-new-products-example.csv , you need to create new .csv file in csv file editor. * In Excel just select the product properties you need from the list and fill in the product properties columns as in our document. Set the PrimaryImage column values to URLs to your images in Assets . * In LibreOffice you need to create table with the number of columns equal to the number of properties of your products and fill it. For a delimiter, select a comma. * Save file in .csv format.","title":"Create catalog data file in .csv format"},{"location":"lessons/lesson2/#create-new-catalog-or-use-an-existing-one","text":"Open Virto Commerce Platform (see how to deploy and open it in Lesson 1 ) There are 2 scenarios for adding new products: adding to a new catalog or to an existing one.","title":"Create new Catalog or use an existing one"},{"location":"lessons/lesson2/#creating-new-category-and-subcategory","text":"To create new category in Electronics catalog click on More > Catalog > Electronics> click +Add > choose Category > fill category name Laptops and code (optional), click Create button. Click on the Laptops in categories list. To create new subcategory, click +Add > choose Category > add category name Asus-Laptops and code (optional), click Create . By clicking on More > Catalog > Electronics > Laptops > Asus-Laptops you will see all created categories. If you want to get Asus-Laptops CategoryId for using it in .csv file - click on categories list menu, select Id by check box and copy the Id value.","title":"Creating new category and subcategory"},{"location":"lessons/lesson2/#using-an-existing-catalog-and-category","text":"Click on More > Catalog . Select the catalog and category names in which you want to add new products, click on categories list menu, select Id by check box and copy category Id value to use in your .csv file.","title":"Using an existing catalog and category"},{"location":"lessons/lesson2/#upload-images-for-new-products","text":"You need to add images for products: go to More > Assets > catalog > click on the New folder icon, type ASUS folder name, click Ok button. Click on the Upload icon. An Asset upload blade opens. Select all the previously extracted sample images from images-example.zip in File Explorer and drag&drop onto specified area. Now you should see all images in the ASUS folder uploaded.","title":"Upload images for new products"},{"location":"lessons/lesson2/#importing-and-mapping-your-catalog-data-into-virto-commerce","text":"At the top of the Asus-Laptops category blade click the Import icon > VirtoCommerce CSV import > select Semicolon in Csv column delimiter > click on the image and select electronics-new-products-example.csv file to upload. Wait a little... Note: importing new products from the file without specifying either the category id or the category path in it, defaults to the root directory - to the catalog. After uploading your data, click on Map columns . On this blade you will see and configure how the properties of your products will be mapped to the default properties defined in application, just so they will be saved to the database after you click buttons Ok and Start Import . Wait a little...","title":"Importing and mapping your catalog data into Virto Commerce"},{"location":"lessons/lesson2/#open-new-products-in-virto-commerce-platform-backend","text":"Now you can see and edit all new products by navigating to More > Catalog > Electronics > Laptops > Asus-Laptops :","title":"Open new products in Virto Commerce Platform (backend)"},{"location":"lessons/lesson2/#creating-a-new-menu-item-in-virto-commerce-storefront-frontend","text":"To add new category to menu in Virto Commerce Storefront ( frontend ) open Virto Commerce Platform ( backend ), click on More > Content > Link lists inside Electronics > en-US main-menu > icon +Add link and fill Link Title - Laptops , URL - ~/laptops , Links to - Category , Linked object - Laptops : click on button Select > Electronics , select Laptops via check box and click on icon +Pick selected , save changes. To add new link for subcategory Asus Laptops to menu in Virto Commerce Storefront( frontend ) open Virto Commerce Platform ( backend ), click on More > Content > Link lists in Electronics > icon +Add . Fill Name - Laptops , Language - en-US , Link Title - Asus Laptops , URL - ~/asus-laptops , click Create button.","title":"Creating a new menu item in Virto Commerce Storefront (frontend)"},{"location":"lessons/lesson2/#creating-thumbnails-for-new-product-images","text":"Now you need to generate thumbnails for new images. * Do this step only once: create new task for thumbnails generation: navigate to More > Thumbnails > click on +Add icon, enter Name - catalog images , Path to images - /catalog , click on pen\u0441il icon near Thumbnail settings and on +Add icon. Create and save thumbnail option details: Name - 348x348 , Thumbnail file name suffix - 348x348 , Resize method - FixedSize , Width (pixels) - 348 , Height (pixels) - 348 , Anchor position - Center . Similarly add details for 3 other resolutions: 216x216, 168x168, 64x64 . Can close only Thumbnails settings blade now. Put the cursor in the Thumbnail settings field (in New thumbnails generation task blade), add all the previously created settings, save new thumbnails generation task. Select catalog images task in Thumbnails generation tasks list blade by check box, click on !Run icon, click Regenerate button in pop-up dialog. Wait a little... all done. If you'd add new pictures later, select the Process changes button to generate thumbnails only for them.","title":"Creating thumbnails for new product images"},{"location":"lessons/lesson2/#build-search-indexes-and-reset-cache","text":"The search indexes are updated by the system every 5 minutes by default. In order to build the indexes for new categories and products immediately, navigate to More > Search index > select all document types via check boxes, click on Build index icon, in pop-up dialog click Build button. You need to reset Storefront cache after building the indexes. Navigate to More > Stores > Electronics > click Reset cache in Store details blade and click Ok button in the dialog.","title":"Build search indexes and reset cache"},{"location":"lessons/lesson2/#open-new-products-in-virto-commerce-storefront-frontend","text":"Open Virto Commerce Storefront locally (see how to deploy and open it in Lesson 1 ). Now you can see new menu item Laptops , new subitem Asus Laptops and all new products in Virto Commerce Storefront.","title":"Open new products in Virto Commerce Storefront (frontend)"},{"location":"lessons/lesson2/#appendix-1-default-product-properties-in-virto-commerce","text":"In order to create a new catalog items .csv file, you need to know which defined product properties you can use: Property Name Data Type Example Name (required) text Asus VivoBook W202NA-DH02 Rugged 11.6-inch Windows 10 Home Laptop Id text Sku text CategoryPath (required if CategoryId is empty) text Laptops/Asus-Laptops CategoryId (required if CategoryPath is empty) text MainProductId text PrimaryImage (image url in app) text http://localhost/admin/assets/catalog/ASUS/99bb9e00c.jpg AltImage text asus-vivobook-w202na-dh02 SeoUrl text asus-vivobook-w202na-dh02 SeoTitle text SeoDescription text SeoLanguage text en-US SeoStore (Id of Store) text Review number (0 or 1) 1 ReviewType text FullReview(or QuickReview) IsActive number (0 or 1) 1 IsBuyable number (0 or 1) 1 TrackInventory number (0 or 1) 1 PriceId text SalePrice number 199.5 ListPrice (required) number 199.5 Currency text USD PriceListId text Quantity (required, 0 and more) number 25 ManufacturerPartNumber text ASDJHG34GH-23 Gtin text MeasureUnit text mm WeightUnit text gram Weight number 125 Height number 125 Length number 125 Width number 125 TaxType text ProductType text Physical(or Digital) ShippingType text Vendor text Asus DownloadType text Standard Product(or Software, or Music) DownloadExpiration date 2018-04-05 21:47 HasUserAgreement number (0 or 1) 1 In order to import your custom product property, you need to define it: in Virto Commerce Platform find the particular category > click on its name by right mouse button and select Manage > Properties > +Add property . Fill Property name, Display name - in English and German, enable Multi language switch, if the property can have multiple values - enable Multivalue switch, select Product in \"Applies to\" and choose Value Type. Set up Validation rules and Attributes if needed. Click Save in Manage property blade and Ok buttons in Properties list of your category. Now you can add column with the same name to .csv file. The property value would be filled with the column value automatically for all products of this category during import.","title":"Appendix 1: Default Product properties in Virto Commerce"},{"location":"lessons/lesson3/","text":"How to create Virto commerce module (API) Summary Use this guide to create a custom module for Virto Commerce Platform. There will be an API created for product reviews management: create, update, delete, search. Hereinafter, this module will be called as \"Customer Reviews\" module. After completing this lesson, a new module will be created, including: module API for create, delete, update and search customer reviews; test project for testing module API. Platform Manager UI for the Virto Commerce \"Customer Reviews\" module will be created in Lesson 4 Prerequisites Installed Virto Commerce Platform; Basic C# knowledge; Visual Studio 2019 or higher. Glossary VC \u2013 Virto Commerce; Platform - Virto Commerce Platform; Platform Manager \u2013 Virto Commerce Platform Manager, UI for Platform managing; JS \u2013 JavaScript; VS \u2013 Visual Studio. Create new module New module should be created from a special VC module template in Visual Studio. The template is available as a Visual Studio extension online. Virto Commerce template Open Visual Studio, go to Tools > Extensions and Updates . Search for Virto Commerce 2.x Module Templates . Install it and restart Visual Studio. Now, in Visual Studio click New Project , search for an existing Virto Commerce 2.x Module . Name it, according to the naming convention. For example: \"Name\": CustomerReviewsModule ; \"Solution name\": CustomerReviewsModule . After new module created fill in title, description and authors attributes in module.manifest file: <module> .... <title> Sample Customer reviews module </title> <description> Sample module demonstrating best practices in a real life example. </description> <authors> <author> If you read this text, replace it with your name </author> </authors> .... <module> module.manifest is entry point for a VC module. It entirely defines the module, so that Virto Commerce Platform can install and run the module. Connect new module with the platform Now, need to tell the platform that a new module added. For that, connect newly created solution folder to the Platform ~/Modules via the symbolic link: Run Command Prompt as an administrator; Navigate to the physical location folder of Platform's ~/Modules directory; Run the following command: mklink /d CustomerReviewsModule <full_path_to_CustomerReviewsModule_project> Also, check and set appropriate permissions for the newly created module folder, so that IIS can access it. Here, for the \"IIS_IUSRS\" group the required permission is \"Read & execute\": Compile solution and restart IIS (use iisreset.exe command). After that, CustomerReviews module should appear in Platform Manager. Open it in browser to check how new module looks like. Click on CustomerReviewsModule and you should see \"Hello world\" blade Debugging Debugging C# code To debug C# code at run-time you have to attach debugger to IIS instance. In Visual Studio: Run Studio as an administrator; Click \"Debug\" from the menu bar; Click \"Attach to Process\"; Check the \"Show processes from all users\" checkbox in the bottom left corner; Select aspnet_wp.exe, w3p.exe, or w3wp.exe from the process list; Click \"Attach\". Swagger UI \"REST API documentation\" (Swagger) UI is automatically generated page. It enables to make requests to all the REST API endpoints exposed by Platform and installed modules as well. Browse [localhost/admin/docs/ui/index] URL: Authorization Call Authorize button on the top of the page, enter username and password, submit the form in order to be able to use the secured API methods. Testing module Rest API Endpoints Click on \"Sample Customer reviews module\" to see the available endpoints. When the new module is generated from a template, there is only one endpoint api/CustomerReviewsModule included, returning \"Hello, world!\": The VC module solution structure \"Customer review\" solution consists of 4 logically divided parts (projects): CustomerReviewsModule.Core with following folder structure: Models; Services. CustomerReviewsModule.Data with following folder structure: Migrations; Models; Repositories; Services. CustomerReviewsModule.Web with following folder structure: Controllers: API. Scripts: blades; Resources. Content. CustomerReviewsModule.Tests . In the solution, each project has its own responsibilities. Thus, certain types belong to each project, and you can always find the folders corresponding to these types in the corresponding project. The figure below shows a representation of the layers of architecture. Notice that the solid arrows correspond to the compile-time dependencies, and the dashed arrows to the dependencies that exist only at run time. As part of the current architecture, a Web project works with interfaces that are defined in the Core project at compile time, and ideally should not know anything about the implementation types defined in the Data project. But at run time, these types of implementations are necessary to run the application, so they must exist and be tied to the interfaces of the Core project through dependency injection. .Core Business/Application Model The project must contain a business model, services and interfaces. These interfaces should include abstractions for operations that will be performed using infrastructure, such as data access, file system access, network calls, etc. In addition, services or interfaces defined at this level can work with non-object types. that are independent of the user. interface or infrastructure and are defined as simple data transfer objects (DTO). .Data Data Access Logic The project includes the implementation of data access. Namely, the data access implementation classes (Repositories), any EF Migration objects that have been defined, and EF Entities models. In addition to the data access implementations, the project must contain service implementations that must interact with infrastructure problems. These services must implement the interfaces defined in Core, and therefore the project must have a reference to the Core project. .Web Presentation Logic and Entry Point The user interface level in an ASP.NET MVC application is the entry point for the application. This project must refer to the Core project, and its types must interact with the data layer strictly through the interfaces defined in Core. Direct creation or static calls for user-level data types are not allowed at the user interface level. The Startup class is responsible for setting up the application and connecting the implementation types to the interfaces, which allows you to correctly inject dependencies at runtime. And to enable dependency injection in ConfigureServices in the Startup.cs file of the user interface project, it refers to data projects. .Tests project .Tests project uses for testing the service and repository layer methods with Unit test. This structure sets up automatically when module solution created from Virto Commerce template. Core project All the abstractions are defined in the CustomerReviewsModule.Core project. Typical structure of Core project is: Models - contains domain models that you want to introduce to VirtoCommerce platform and Search Criteria for support search: Entities; Search Criteria. Services - declaration of CRUD and search services without implementations: CRUD service interface; Search interface. Preinstalled NuGet packages After the project is created from the template, the following packages will be automatically installed: VirtoCommerce.Platform.Core ; VirtoCommerce.Domain . Domain models All domain models should be located in CustomerReviewsModule.Core\\Models folder. Entity CustomerReviews entity defined as base domain class: namespace CustomerReviews.Core.Models { public class CustomerReview : AuditableEntity { public string AuthorNickname { get ; set ; } public string Content { get ; set ; } public bool IsActive { get ; set ; } public string ProductId { get ; set ; } } } It contains all the mandatory data related to customer\u2019s review: The author\u2019s nickname, review content, the status(active/inactive) and product ID which user reviewed. Search criteria Define criteria to search for reviews such as CustomerReviewSearchCriteria : public class CustomerReviewSearchCriteria : SearchCriteriaBase { public string [] ProductIds { get ; set ; } public bool? IsActive { get ; set ; } } In this case, the client can search by products and review status. Services In order to use created models, need to create services. In CustomerReviewsModule.Core\\Services folder will define the abstractions for customer\u2019s review services. For example, the ICustomerReviewService interface: public interface ICustomerReviewService { CustomerReview [] GetByIds ( string [] ids ); void SaveCustomerReviews ( CustomerReview [] items ); void DeleteCustomerReviews ( string [] ids ); } Here define methods to get, save and delete customer reviews. And a separate service is for the search. ICustomerReviewSearchService : public interface ICustomerReviewSearchService { GenericSearchResult < CustomerReview > SearchCustomerReviews ( CustomerReviewSearchCriteria criteria ); } Permissions In ModuleConstants.cs declared basic module permissions which describes particular right of action and has a string presentation which is used in permission checks. These permissions will be used below in the description API methods in CustomerReviewsModule.Web project. public static class Security { public static class Permissions { public const string Read = \"CustomerReviewsModule:read\" ; public const string Update = \"CustomerReviewsModule:update\" ; public const string Delete = \"CustomerReviewsModule:delete\" ; } } With them you control the API access allowing to read, update or perform delete operation. These permission checks are also used in frontend part as well. Declaring new permissions in module.manifest Permissions are also declared in module manifest. <module> .... <permissions> <group name= \"CustomerReviewsModule\" > <permission id= \"CustomerReviewsModule:read\" name= \"Read\" /> <permission id= \"CustomerReviewsModule:update\" name= \"Update\" /> <permission id= \"CustomerReviewsModule:delete\" name= \"Delete\" /> </group> </permissions> </module> You can read more about permissions in Working with platform security Data project (Persistence layer) For the persistence or Data Access Layer (DAL) solution has a separate project called Data . Here implemented all the interfaces defined in Core project. Moreover, it contains all the persistence and data access abstractions, and mappings as well. Typical structure of Data project is: Models - separate classes have each of the entities that you created previously in Core project, typically they have the conversion methods from domain model to persistency model {Entity}.ToModel() {Entity}.FromModel() {Entity}.Patch() Repositories - contains classes for making requests to database Migrations - contains code to manage incremental changes and version control to database Services - implementation of services that were previously declared in Core project Preinstalled NuGet packages After the project is created from the template, the following NuGet packages will be automatically installed: VirtoCommerce.Platform.Core ; VirtoCommerce.Platform.Data ; VirtoCommerce.Domain . Project references CustomerReviewsModule.Data project has reference to CustomerReviewsModule.Core project. Entity and mapping Now need to create data access layer models and map it to the base domain class. All data access layer models should be located in CustomerReviewsModule.Data\\Models folder. The example of the CustomerReview data access layer model implementation you can find in sample the repository . Repositories As a new type of abstraction, Data project has repositories defined in it. For example, you can notice ICustomerReviewRepository used in CustomerReviewService . public interface ICustomerReviewRepository : IRepository { IQueryable < CustomerReviewEntity > CustomerReviews { get ; } CustomerReviewEntity [] GetByIds ( string [] ids ); void DeleteCustomerReviews ( string [] ids ); } ICustomerReviewRepository interface contains only the declaration of the methods, properties. Implementation of the interface ICustomerReviewRepository uses Entity Framework under the hood. The Interface and the implementation can find in the sample repository . The interface and its implementation should be located in CustomerReviewsModule.Data\\Repositories folder. Services The implementations of the services that was defined early in CustomerReviewsModule.Core project should be located in CustomerReviewsModule.Data\\Services folder. The example of the services implementation you can find in the sample repository . Migrations In order to define the data access layer based on Entity Framework use the package manager tools in Visual Studio. From the VS top menu chooses Tools>Module Package Manager>Package Manager Console . There is a command to enable migrations: enable-migrations \u2013MigrationsDirectory Migrations In the dropdown menu choose the CustomerReviewsModule.Data project. The command run will create a new migration configuration. Note, that by default the automatic migrations are switched off: AutomaticMigrationsEnabled = false Initial migration For generate the initial migration use this script: Add-Migration Initial -ConnectionString \"Data Source=(local);Initial Catalog=VirtoCommerce2;Persist Security Info=True;User ID=virto;Password=virto;MultipleActiveResultSets=True;Connect Timeout=420\" -ConnectionProviderName \"System.Data.SqlClient\" This will generate the dbo.CustomerReview migration script. Keep in mind, that in case \"Down migration\" developer should take care of removing the module with all its dependencies. Now the Data Access Layer is ready. Web project This is most important project in the solution. Typical structure of Web project is: Controllers - API controllers, all methods defined here wil be available from platform instance; Scripts - entry point for Platform Manager user interface; Module.manifest - the main file containing new module definition; Module.cs - main entry point for module backend, containing database initialization, registration of new repositories, services, model types and overrides. Preinstalled NuGet packages After the project is created from the template, the following NuGet packages will be automatically installed: VirtoCommerce.Platform.Core.Web ; VirtoCommerce.Platform.Data ; VirtoCommerce.Domain . Project references CustomerReviewsModule.Web project has reference to CustomerReviewsModule.Core and CustomerReviewsModule.Data projects. Module.manifest module.manifest contains various attributes describing the module and its contents which is necessary for the Platform to connect the module to the platform. The Platform searches for CustomerReviewModule module.manifest file, gets the entry point and connects the module to the platform. Typical module.manifest structure is: Identifier - a new module identifier for Platform, each modules identifier should be unique: <id> CustomerReviews.Web </id> Versioning - actual version of a new module and required Platform version: <version> 1.0.0 </version> <platformVersion> 2.13.9 </platformVersion> Dependencies - list of modules with versions whose functions will be used in a new module: <dependencies> <dependenci id= \"VirtoCommerce.Core\" version= \"2.25.21\" > </dependencies> Title and description - name and description of a new module that will be displayed in the Platform Manager and Swagger: <title> Sample Customer reviews module </title> <description> Sample module demonstrating best practices in a real life example. </description> Authors - names of programmers who wrote a new module: <authors> <author> Egidijus Mazeika </author> </authors> AssemblyFile and ModuleType - auto generated data witch Platform use under the hood to connect a new module: <assemblyFile> CustomerReviews.Web.dll </assemblyFile> <moduleType> CustomerReviews.Web.Module, CustomerReviews.Web </moduleType> Styles - path for additional styles for a new module user interface: <styles> <directory virtualPath= \"$/Content/css\" searchPattern= \"*.css\" searchSubdirectories= \"true\" /> </styles> Scripts - path for a new module user interface scripts: <scripts> <directory virtualPath= \"$/Scripts\" searchPattern= \"*.js\" searchSubdirectories= \"true\" /> </scripts> Settings - define custom settings for a new module: <settings> <group name= \"Store|General\" > <setting> <name> CustomerReviews.CustomerReviewsEnabled </name> <valueType> boolean </valueType> <defaultValue> false </defaultValue> <title> Customer Reviews enabled </title> <description> Flag to mark that customer reviews functionality is enabled </description> </setting> </group> </settings> Permissions - define custom permissions for a new module: <permissions> <group name= \"Customer Reviews\" > <permission id= \"customerReview:read\" name= \"Read Customer Reviews\" /> <permission id= \"customerReview:update\" name= \"Update Customer Review\" /> <permission id= \"customerReview:delete\" name= \"Delete Customer Review\" /> </group> </permissions> Module.cs and initialization flow Module.cs is the main entry point of managed code, the base class for the entire module. In this case, it\u2019s Customer Reviews module. Module initialization flow contains several steps: Setup Database; Initialization: Services registration; Post initialization: Override registrations; Store dependent settings registration. Setup Database First step is to registry repositories defined in Data project (including migrations) and initialize database. The database is initialized in the SetupDatabase() method: public override void SetupDatabase () { using ( var db = new CustomerReviewRepository ( _connectionString , _container . Resolve < AuditableInterceptor >())) { var initializer = new SetupDatabaseInitializer < CustomerReviewRepository , Data . Migrations . Configuration >(); initializer . InitializeDatabase ( db ); } } Initialization Interfaces are using in services in CustomerReviews module. That\u2019s because a dependency injection always used. Inside of Initialize() method in the Main class register the Service implementations of the module and link them with the interfaces: public override void Initialize () { base . Initialize (); // This method is called for each installed module on the first stage of initialization. // Register implementations: _container . RegisterType < ICustomerReviewRepository >( new InjectionFactory ( c => new CustomerReviewRepository ( _connectionString , new EntityPrimaryKeyGeneratorInterceptor (), _container . Resolve < AuditableInterceptor >()))); _container . RegisterType < ICustomerReviewSearchService , CustomerReviewSearchService >(); _container . RegisterType < ICustomerReviewService , CustomerReviewService >(); } The method registers a specific signature for the type that will be injected for the ICustomerReviewRepository interface with a predefined connection string with the database, Id generator and interceptors (for uniformity of work with the database). By calling this line only a factory method registered to be executed during the DI. This is called a loose coupling mechanism. Post initialization If you need to override existing registrations or register new store dependent settings you can do this in PostInitialize() method. Module settings A setting is a parameter that a module accepts. More details on settings: https://virtocommerce.com/docs/vc2devguide/working-with-platform-manager/extending-functionality/managing-module-settings First of all define CustomerReviews.CustomerReviewsEnabled setting in module.manifest like this: <settings> <group name= \"Store|General\" > <setting> <name> CustomerReviews.CustomerReviewsEnabled </name> <valueType> boolean </valueType> <defaultValue> false </defaultValue> <title> Customer Reviews enabled </title> <description> Flag to mark that customer reviews functionality is enabled </description> </setting> </group> </settings> A new, global module setting is defined. Make the Reviews enabled/disabled setting value configurable for each individual store (scope-bounded): get instance of ISettingsManager ; define a list of settings that will be scope-bounded; get the actual definitions of those settings; register the settings as scope-bounded in \"VirtoCommerce.Store\" module: public override void PostInitialize () { base . PostInitialize (); //Registering settings to store module allows to use individual values in each store var settingManager = _container . Resolve < ISettingsManager >(); var storeSettingsNames = new [] { \"CustomerReviews.CustomerReviewsEnabled\" }; var storeSettings = settingManager . GetModuleSettings ( \"CustomerReviews.Web\" ). Where ( x => storeSettingsNames . Contains ( x . Name )). ToArray (); settingManager . RegisterModuleSettings ( \"VirtoCommerce.Store\" , storeSettings ); } WEB API layer For access and use CustomerReviews module services a WEB API layer defined. Search, CRUD and module specific operations are exposed there. For example, look at searching endpoint: [HttpPost] [Route(\"search\")] [ResponseType(typeof(GenericSearchResult<CustomerReview>))] [CheckPermission(Permission = Permissions.Read)] public IHttpActionResult SearchCustomerReviews ( CustomerReviewSearchCriteria criteria ) { GenericSearchResult < CustomerReviews > result = _customerReviewSearchService . SearchCustomerReviews ( criteria ); return Ok ( result ); } There isn\u2019t much code in the method. The customer reviews search Service calling directly. Of course, here as well, will use the ICustomerReviewRepository abstraction and not the service implementation itself. The API endpoints are all accessed from the JavaScript code written in the CustomerReviewsModule . WEB API endpoints protection Protecting API controller methods with CheckPermission attribute: [CheckPermission(Permission = Permissions.Read)] Testing Rest API Endpoints in Swagger Besides the JavaScript, you can test module API endpoints, with the Swagger. Compile solution and restart IIS (use iisreset.exe command). Open the Swagger interface URL: [localhost//admin/docs/ui/index] and click on \"Customer reviews module\" to see the available endpoints. You can test the search functionality for instance. Under the api/CustomerReviewsModule/search endpoint you can create simple or nested, compound criteria. It accepts the criteria as a simple object. After providing the criteria hit the \"Try it out\" button. Tests project xUnit testing framework used for test project in module solution. Preinstalled NuGet packages After the project is created from the template, the following NuGet packages will be automatically installed: xUnit.Net ; xunit.runner.visualstudio ; Virto Commerce packages referenced in Core and Data projects. Project references CustomerReviewsModule.Tests project has reference to CustomerReviewsModule.Core and CustomerReviewsModule.Data projects. Tests implementation We recommend to use \"Unit testing best practices with .NET Core and .NET Standard\" in tests development. Actual code for CustomerReviewsModule.Tests project you can find in the sample repository . Pack and release/deployment To deploy CustomerReviews module to other platforms use the package manager tool. The command for that is: compress-module After execution, the command will create the .zip module package. You can deploy it to the other environment. Go to Modules>Advanced>Install/update module from file . Upload the .zip file that created with package manager. After checking, the upload details hit the Install button. Restart the application. Under the hood, the application will unzip the file, check the structure, and copy all the required classes to the Modules folder of the current application.","title":"Lesson 3 - How to create Virto commerce module (API)"},{"location":"lessons/lesson3/#how-to-create-virto-commerce-module-api","text":"","title":"How to create Virto commerce module (API)"},{"location":"lessons/lesson3/#summary","text":"Use this guide to create a custom module for Virto Commerce Platform. There will be an API created for product reviews management: create, update, delete, search. Hereinafter, this module will be called as \"Customer Reviews\" module. After completing this lesson, a new module will be created, including: module API for create, delete, update and search customer reviews; test project for testing module API. Platform Manager UI for the Virto Commerce \"Customer Reviews\" module will be created in Lesson 4","title":"Summary"},{"location":"lessons/lesson3/#prerequisites","text":"Installed Virto Commerce Platform; Basic C# knowledge; Visual Studio 2019 or higher.","title":"Prerequisites"},{"location":"lessons/lesson3/#glossary","text":"VC \u2013 Virto Commerce; Platform - Virto Commerce Platform; Platform Manager \u2013 Virto Commerce Platform Manager, UI for Platform managing; JS \u2013 JavaScript; VS \u2013 Visual Studio.","title":"Glossary"},{"location":"lessons/lesson3/#create-new-module","text":"New module should be created from a special VC module template in Visual Studio. The template is available as a Visual Studio extension online.","title":"Create new module"},{"location":"lessons/lesson3/#virto-commerce-template","text":"Open Visual Studio, go to Tools > Extensions and Updates . Search for Virto Commerce 2.x Module Templates . Install it and restart Visual Studio. Now, in Visual Studio click New Project , search for an existing Virto Commerce 2.x Module . Name it, according to the naming convention. For example: \"Name\": CustomerReviewsModule ; \"Solution name\": CustomerReviewsModule . After new module created fill in title, description and authors attributes in module.manifest file: <module> .... <title> Sample Customer reviews module </title> <description> Sample module demonstrating best practices in a real life example. </description> <authors> <author> If you read this text, replace it with your name </author> </authors> .... <module> module.manifest is entry point for a VC module. It entirely defines the module, so that Virto Commerce Platform can install and run the module.","title":"Virto Commerce template"},{"location":"lessons/lesson3/#connect-new-module-with-the-platform","text":"Now, need to tell the platform that a new module added. For that, connect newly created solution folder to the Platform ~/Modules via the symbolic link: Run Command Prompt as an administrator; Navigate to the physical location folder of Platform's ~/Modules directory; Run the following command: mklink /d CustomerReviewsModule <full_path_to_CustomerReviewsModule_project> Also, check and set appropriate permissions for the newly created module folder, so that IIS can access it. Here, for the \"IIS_IUSRS\" group the required permission is \"Read & execute\": Compile solution and restart IIS (use iisreset.exe command). After that, CustomerReviews module should appear in Platform Manager. Open it in browser to check how new module looks like. Click on CustomerReviewsModule and you should see \"Hello world\" blade","title":"Connect new module with the platform"},{"location":"lessons/lesson3/#debugging","text":"","title":"Debugging"},{"location":"lessons/lesson3/#debugging-c-code","text":"To debug C# code at run-time you have to attach debugger to IIS instance. In Visual Studio: Run Studio as an administrator; Click \"Debug\" from the menu bar; Click \"Attach to Process\"; Check the \"Show processes from all users\" checkbox in the bottom left corner; Select aspnet_wp.exe, w3p.exe, or w3wp.exe from the process list; Click \"Attach\".","title":"Debugging C# code"},{"location":"lessons/lesson3/#swagger-ui","text":"\"REST API documentation\" (Swagger) UI is automatically generated page. It enables to make requests to all the REST API endpoints exposed by Platform and installed modules as well. Browse [localhost/admin/docs/ui/index] URL:","title":"Swagger UI"},{"location":"lessons/lesson3/#authorization","text":"Call Authorize button on the top of the page, enter username and password, submit the form in order to be able to use the secured API methods.","title":"Authorization"},{"location":"lessons/lesson3/#testing-module-rest-api-endpoints","text":"Click on \"Sample Customer reviews module\" to see the available endpoints. When the new module is generated from a template, there is only one endpoint api/CustomerReviewsModule included, returning \"Hello, world!\":","title":"Testing module Rest API Endpoints"},{"location":"lessons/lesson3/#the-vc-module-solution-structure","text":"\"Customer review\" solution consists of 4 logically divided parts (projects): CustomerReviewsModule.Core with following folder structure: Models; Services. CustomerReviewsModule.Data with following folder structure: Migrations; Models; Repositories; Services. CustomerReviewsModule.Web with following folder structure: Controllers: API. Scripts: blades; Resources. Content. CustomerReviewsModule.Tests . In the solution, each project has its own responsibilities. Thus, certain types belong to each project, and you can always find the folders corresponding to these types in the corresponding project. The figure below shows a representation of the layers of architecture. Notice that the solid arrows correspond to the compile-time dependencies, and the dashed arrows to the dependencies that exist only at run time. As part of the current architecture, a Web project works with interfaces that are defined in the Core project at compile time, and ideally should not know anything about the implementation types defined in the Data project. But at run time, these types of implementations are necessary to run the application, so they must exist and be tied to the interfaces of the Core project through dependency injection.","title":"The VC module solution structure"},{"location":"lessons/lesson3/#core-businessapplication-model","text":"The project must contain a business model, services and interfaces. These interfaces should include abstractions for operations that will be performed using infrastructure, such as data access, file system access, network calls, etc. In addition, services or interfaces defined at this level can work with non-object types. that are independent of the user. interface or infrastructure and are defined as simple data transfer objects (DTO).","title":".Core Business/Application Model"},{"location":"lessons/lesson3/#data-data-access-logic","text":"The project includes the implementation of data access. Namely, the data access implementation classes (Repositories), any EF Migration objects that have been defined, and EF Entities models. In addition to the data access implementations, the project must contain service implementations that must interact with infrastructure problems. These services must implement the interfaces defined in Core, and therefore the project must have a reference to the Core project.","title":".Data Data Access Logic"},{"location":"lessons/lesson3/#web-presentation-logic-and-entry-point","text":"The user interface level in an ASP.NET MVC application is the entry point for the application. This project must refer to the Core project, and its types must interact with the data layer strictly through the interfaces defined in Core. Direct creation or static calls for user-level data types are not allowed at the user interface level. The Startup class is responsible for setting up the application and connecting the implementation types to the interfaces, which allows you to correctly inject dependencies at runtime. And to enable dependency injection in ConfigureServices in the Startup.cs file of the user interface project, it refers to data projects.","title":".Web Presentation Logic and Entry Point"},{"location":"lessons/lesson3/#tests-project","text":".Tests project uses for testing the service and repository layer methods with Unit test. This structure sets up automatically when module solution created from Virto Commerce template.","title":".Tests project"},{"location":"lessons/lesson3/#core-project","text":"All the abstractions are defined in the CustomerReviewsModule.Core project. Typical structure of Core project is: Models - contains domain models that you want to introduce to VirtoCommerce platform and Search Criteria for support search: Entities; Search Criteria. Services - declaration of CRUD and search services without implementations: CRUD service interface; Search interface.","title":"Core project"},{"location":"lessons/lesson3/#preinstalled-nuget-packages","text":"After the project is created from the template, the following packages will be automatically installed: VirtoCommerce.Platform.Core ; VirtoCommerce.Domain .","title":"Preinstalled NuGet packages"},{"location":"lessons/lesson3/#domain-models","text":"All domain models should be located in CustomerReviewsModule.Core\\Models folder.","title":"Domain models"},{"location":"lessons/lesson3/#entity","text":"CustomerReviews entity defined as base domain class: namespace CustomerReviews.Core.Models { public class CustomerReview : AuditableEntity { public string AuthorNickname { get ; set ; } public string Content { get ; set ; } public bool IsActive { get ; set ; } public string ProductId { get ; set ; } } } It contains all the mandatory data related to customer\u2019s review: The author\u2019s nickname, review content, the status(active/inactive) and product ID which user reviewed.","title":"Entity"},{"location":"lessons/lesson3/#search-criteria","text":"Define criteria to search for reviews such as CustomerReviewSearchCriteria : public class CustomerReviewSearchCriteria : SearchCriteriaBase { public string [] ProductIds { get ; set ; } public bool? IsActive { get ; set ; } } In this case, the client can search by products and review status.","title":"Search criteria"},{"location":"lessons/lesson3/#services","text":"In order to use created models, need to create services. In CustomerReviewsModule.Core\\Services folder will define the abstractions for customer\u2019s review services. For example, the ICustomerReviewService interface: public interface ICustomerReviewService { CustomerReview [] GetByIds ( string [] ids ); void SaveCustomerReviews ( CustomerReview [] items ); void DeleteCustomerReviews ( string [] ids ); } Here define methods to get, save and delete customer reviews. And a separate service is for the search. ICustomerReviewSearchService : public interface ICustomerReviewSearchService { GenericSearchResult < CustomerReview > SearchCustomerReviews ( CustomerReviewSearchCriteria criteria ); }","title":"Services"},{"location":"lessons/lesson3/#permissions","text":"In ModuleConstants.cs declared basic module permissions which describes particular right of action and has a string presentation which is used in permission checks. These permissions will be used below in the description API methods in CustomerReviewsModule.Web project. public static class Security { public static class Permissions { public const string Read = \"CustomerReviewsModule:read\" ; public const string Update = \"CustomerReviewsModule:update\" ; public const string Delete = \"CustomerReviewsModule:delete\" ; } } With them you control the API access allowing to read, update or perform delete operation. These permission checks are also used in frontend part as well.","title":"Permissions"},{"location":"lessons/lesson3/#declaring-new-permissions-in-modulemanifest","text":"Permissions are also declared in module manifest. <module> .... <permissions> <group name= \"CustomerReviewsModule\" > <permission id= \"CustomerReviewsModule:read\" name= \"Read\" /> <permission id= \"CustomerReviewsModule:update\" name= \"Update\" /> <permission id= \"CustomerReviewsModule:delete\" name= \"Delete\" /> </group> </permissions> </module> You can read more about permissions in Working with platform security","title":"Declaring new permissions in module.manifest"},{"location":"lessons/lesson3/#data-project-persistence-layer","text":"For the persistence or Data Access Layer (DAL) solution has a separate project called Data . Here implemented all the interfaces defined in Core project. Moreover, it contains all the persistence and data access abstractions, and mappings as well. Typical structure of Data project is: Models - separate classes have each of the entities that you created previously in Core project, typically they have the conversion methods from domain model to persistency model {Entity}.ToModel() {Entity}.FromModel() {Entity}.Patch() Repositories - contains classes for making requests to database Migrations - contains code to manage incremental changes and version control to database Services - implementation of services that were previously declared in Core project","title":"Data project (Persistence layer)"},{"location":"lessons/lesson3/#preinstalled-nuget-packages_1","text":"After the project is created from the template, the following NuGet packages will be automatically installed: VirtoCommerce.Platform.Core ; VirtoCommerce.Platform.Data ; VirtoCommerce.Domain .","title":"Preinstalled NuGet packages"},{"location":"lessons/lesson3/#project-references","text":"CustomerReviewsModule.Data project has reference to CustomerReviewsModule.Core project.","title":"Project references"},{"location":"lessons/lesson3/#entity-and-mapping","text":"Now need to create data access layer models and map it to the base domain class. All data access layer models should be located in CustomerReviewsModule.Data\\Models folder. The example of the CustomerReview data access layer model implementation you can find in sample the repository .","title":"Entity and mapping"},{"location":"lessons/lesson3/#repositories","text":"As a new type of abstraction, Data project has repositories defined in it. For example, you can notice ICustomerReviewRepository used in CustomerReviewService . public interface ICustomerReviewRepository : IRepository { IQueryable < CustomerReviewEntity > CustomerReviews { get ; } CustomerReviewEntity [] GetByIds ( string [] ids ); void DeleteCustomerReviews ( string [] ids ); } ICustomerReviewRepository interface contains only the declaration of the methods, properties. Implementation of the interface ICustomerReviewRepository uses Entity Framework under the hood. The Interface and the implementation can find in the sample repository . The interface and its implementation should be located in CustomerReviewsModule.Data\\Repositories folder.","title":"Repositories"},{"location":"lessons/lesson3/#services_1","text":"The implementations of the services that was defined early in CustomerReviewsModule.Core project should be located in CustomerReviewsModule.Data\\Services folder. The example of the services implementation you can find in the sample repository .","title":"Services"},{"location":"lessons/lesson3/#migrations","text":"In order to define the data access layer based on Entity Framework use the package manager tools in Visual Studio. From the VS top menu chooses Tools>Module Package Manager>Package Manager Console . There is a command to enable migrations: enable-migrations \u2013MigrationsDirectory Migrations In the dropdown menu choose the CustomerReviewsModule.Data project. The command run will create a new migration configuration. Note, that by default the automatic migrations are switched off: AutomaticMigrationsEnabled = false","title":"Migrations"},{"location":"lessons/lesson3/#initial-migration","text":"For generate the initial migration use this script: Add-Migration Initial -ConnectionString \"Data Source=(local);Initial Catalog=VirtoCommerce2;Persist Security Info=True;User ID=virto;Password=virto;MultipleActiveResultSets=True;Connect Timeout=420\" -ConnectionProviderName \"System.Data.SqlClient\" This will generate the dbo.CustomerReview migration script. Keep in mind, that in case \"Down migration\" developer should take care of removing the module with all its dependencies. Now the Data Access Layer is ready.","title":"Initial migration"},{"location":"lessons/lesson3/#web-project","text":"This is most important project in the solution. Typical structure of Web project is: Controllers - API controllers, all methods defined here wil be available from platform instance; Scripts - entry point for Platform Manager user interface; Module.manifest - the main file containing new module definition; Module.cs - main entry point for module backend, containing database initialization, registration of new repositories, services, model types and overrides.","title":"Web project"},{"location":"lessons/lesson3/#preinstalled-nuget-packages_2","text":"After the project is created from the template, the following NuGet packages will be automatically installed: VirtoCommerce.Platform.Core.Web ; VirtoCommerce.Platform.Data ; VirtoCommerce.Domain .","title":"Preinstalled NuGet packages"},{"location":"lessons/lesson3/#project-references_1","text":"CustomerReviewsModule.Web project has reference to CustomerReviewsModule.Core and CustomerReviewsModule.Data projects.","title":"Project references"},{"location":"lessons/lesson3/#modulemanifest","text":"module.manifest contains various attributes describing the module and its contents which is necessary for the Platform to connect the module to the platform. The Platform searches for CustomerReviewModule module.manifest file, gets the entry point and connects the module to the platform. Typical module.manifest structure is: Identifier - a new module identifier for Platform, each modules identifier should be unique: <id> CustomerReviews.Web </id> Versioning - actual version of a new module and required Platform version: <version> 1.0.0 </version> <platformVersion> 2.13.9 </platformVersion> Dependencies - list of modules with versions whose functions will be used in a new module: <dependencies> <dependenci id= \"VirtoCommerce.Core\" version= \"2.25.21\" > </dependencies> Title and description - name and description of a new module that will be displayed in the Platform Manager and Swagger: <title> Sample Customer reviews module </title> <description> Sample module demonstrating best practices in a real life example. </description> Authors - names of programmers who wrote a new module: <authors> <author> Egidijus Mazeika </author> </authors> AssemblyFile and ModuleType - auto generated data witch Platform use under the hood to connect a new module: <assemblyFile> CustomerReviews.Web.dll </assemblyFile> <moduleType> CustomerReviews.Web.Module, CustomerReviews.Web </moduleType> Styles - path for additional styles for a new module user interface: <styles> <directory virtualPath= \"$/Content/css\" searchPattern= \"*.css\" searchSubdirectories= \"true\" /> </styles> Scripts - path for a new module user interface scripts: <scripts> <directory virtualPath= \"$/Scripts\" searchPattern= \"*.js\" searchSubdirectories= \"true\" /> </scripts> Settings - define custom settings for a new module: <settings> <group name= \"Store|General\" > <setting> <name> CustomerReviews.CustomerReviewsEnabled </name> <valueType> boolean </valueType> <defaultValue> false </defaultValue> <title> Customer Reviews enabled </title> <description> Flag to mark that customer reviews functionality is enabled </description> </setting> </group> </settings> Permissions - define custom permissions for a new module: <permissions> <group name= \"Customer Reviews\" > <permission id= \"customerReview:read\" name= \"Read Customer Reviews\" /> <permission id= \"customerReview:update\" name= \"Update Customer Review\" /> <permission id= \"customerReview:delete\" name= \"Delete Customer Review\" /> </group> </permissions>","title":"Module.manifest"},{"location":"lessons/lesson3/#modulecs-and-initialization-flow","text":"Module.cs is the main entry point of managed code, the base class for the entire module. In this case, it\u2019s Customer Reviews module. Module initialization flow contains several steps: Setup Database; Initialization: Services registration; Post initialization: Override registrations; Store dependent settings registration.","title":"Module.cs and initialization flow"},{"location":"lessons/lesson3/#setup-database","text":"First step is to registry repositories defined in Data project (including migrations) and initialize database. The database is initialized in the SetupDatabase() method: public override void SetupDatabase () { using ( var db = new CustomerReviewRepository ( _connectionString , _container . Resolve < AuditableInterceptor >())) { var initializer = new SetupDatabaseInitializer < CustomerReviewRepository , Data . Migrations . Configuration >(); initializer . InitializeDatabase ( db ); } }","title":"Setup Database"},{"location":"lessons/lesson3/#initialization","text":"Interfaces are using in services in CustomerReviews module. That\u2019s because a dependency injection always used. Inside of Initialize() method in the Main class register the Service implementations of the module and link them with the interfaces: public override void Initialize () { base . Initialize (); // This method is called for each installed module on the first stage of initialization. // Register implementations: _container . RegisterType < ICustomerReviewRepository >( new InjectionFactory ( c => new CustomerReviewRepository ( _connectionString , new EntityPrimaryKeyGeneratorInterceptor (), _container . Resolve < AuditableInterceptor >()))); _container . RegisterType < ICustomerReviewSearchService , CustomerReviewSearchService >(); _container . RegisterType < ICustomerReviewService , CustomerReviewService >(); } The method registers a specific signature for the type that will be injected for the ICustomerReviewRepository interface with a predefined connection string with the database, Id generator and interceptors (for uniformity of work with the database). By calling this line only a factory method registered to be executed during the DI. This is called a loose coupling mechanism.","title":"Initialization"},{"location":"lessons/lesson3/#post-initialization","text":"If you need to override existing registrations or register new store dependent settings you can do this in PostInitialize() method.","title":"Post initialization"},{"location":"lessons/lesson3/#module-settings","text":"A setting is a parameter that a module accepts. More details on settings: https://virtocommerce.com/docs/vc2devguide/working-with-platform-manager/extending-functionality/managing-module-settings First of all define CustomerReviews.CustomerReviewsEnabled setting in module.manifest like this: <settings> <group name= \"Store|General\" > <setting> <name> CustomerReviews.CustomerReviewsEnabled </name> <valueType> boolean </valueType> <defaultValue> false </defaultValue> <title> Customer Reviews enabled </title> <description> Flag to mark that customer reviews functionality is enabled </description> </setting> </group> </settings> A new, global module setting is defined. Make the Reviews enabled/disabled setting value configurable for each individual store (scope-bounded): get instance of ISettingsManager ; define a list of settings that will be scope-bounded; get the actual definitions of those settings; register the settings as scope-bounded in \"VirtoCommerce.Store\" module: public override void PostInitialize () { base . PostInitialize (); //Registering settings to store module allows to use individual values in each store var settingManager = _container . Resolve < ISettingsManager >(); var storeSettingsNames = new [] { \"CustomerReviews.CustomerReviewsEnabled\" }; var storeSettings = settingManager . GetModuleSettings ( \"CustomerReviews.Web\" ). Where ( x => storeSettingsNames . Contains ( x . Name )). ToArray (); settingManager . RegisterModuleSettings ( \"VirtoCommerce.Store\" , storeSettings ); }","title":"Module settings"},{"location":"lessons/lesson3/#web-api-layer","text":"For access and use CustomerReviews module services a WEB API layer defined. Search, CRUD and module specific operations are exposed there. For example, look at searching endpoint: [HttpPost] [Route(\"search\")] [ResponseType(typeof(GenericSearchResult<CustomerReview>))] [CheckPermission(Permission = Permissions.Read)] public IHttpActionResult SearchCustomerReviews ( CustomerReviewSearchCriteria criteria ) { GenericSearchResult < CustomerReviews > result = _customerReviewSearchService . SearchCustomerReviews ( criteria ); return Ok ( result ); } There isn\u2019t much code in the method. The customer reviews search Service calling directly. Of course, here as well, will use the ICustomerReviewRepository abstraction and not the service implementation itself. The API endpoints are all accessed from the JavaScript code written in the CustomerReviewsModule .","title":"WEB API layer"},{"location":"lessons/lesson3/#web-api-endpoints-protection","text":"Protecting API controller methods with CheckPermission attribute: [CheckPermission(Permission = Permissions.Read)]","title":"WEB API endpoints protection"},{"location":"lessons/lesson3/#testing-rest-api-endpoints-in-swagger","text":"Besides the JavaScript, you can test module API endpoints, with the Swagger. Compile solution and restart IIS (use iisreset.exe command). Open the Swagger interface URL: [localhost//admin/docs/ui/index] and click on \"Customer reviews module\" to see the available endpoints. You can test the search functionality for instance. Under the api/CustomerReviewsModule/search endpoint you can create simple or nested, compound criteria. It accepts the criteria as a simple object. After providing the criteria hit the \"Try it out\" button.","title":"Testing Rest API Endpoints in Swagger"},{"location":"lessons/lesson3/#tests-project_1","text":"xUnit testing framework used for test project in module solution.","title":"Tests project"},{"location":"lessons/lesson3/#preinstalled-nuget-packages_3","text":"After the project is created from the template, the following NuGet packages will be automatically installed: xUnit.Net ; xunit.runner.visualstudio ; Virto Commerce packages referenced in Core and Data projects.","title":"Preinstalled NuGet packages"},{"location":"lessons/lesson3/#project-references_2","text":"CustomerReviewsModule.Tests project has reference to CustomerReviewsModule.Core and CustomerReviewsModule.Data projects.","title":"Project references"},{"location":"lessons/lesson3/#tests-implementation","text":"We recommend to use \"Unit testing best practices with .NET Core and .NET Standard\" in tests development. Actual code for CustomerReviewsModule.Tests project you can find in the sample repository .","title":"Tests implementation"},{"location":"lessons/lesson3/#pack-and-releasedeployment","text":"To deploy CustomerReviews module to other platforms use the package manager tool. The command for that is: compress-module After execution, the command will create the .zip module package. You can deploy it to the other environment. Go to Modules>Advanced>Install/update module from file . Upload the .zip file that created with package manager. After checking, the upload details hit the Install button. Restart the application. Under the hood, the application will unzip the file, check the structure, and copy all the required classes to the Modules folder of the current application.","title":"Pack and release/deployment"},{"location":"lessons/lesson4/","text":"How to build and customize Platform Manager Web UI (AngularJS) Summary Use this guide to create Platform Manager UI for the Virto Commerce \"Customer Reviews\" module (created in the Lesson 3 ). After completing this lesson, a Platform Manager UI for the Virto Commerce \"Customer Reviews\" module will be created, including: blade with the customer reviews list for products; widget on the product page to view the number of reviews and open the new reviews blade for the product. Prerequisites Installed Virto Commerce Platform Manager Visual Studio 2019 or higher Basic JavaScript (AngularJS) knowledge Passed Lesson 3 Glossary JS \u2013 JavaScript; Platform - Virto Commerce Platform; Platform Manager \u2013 Virto Commerce Platform Manager, UI for Platform managing; VC \u2013 Virto Commerce; VS \u2013 Visual Studio; UI \u2013 User Interface. Platform Manager UI elements The most common extension points for Platform Manager UI are: * Blade * Toolbar * Metaform * Widget Review these UI elements carefully before you start creating the UI for \"Customer Reviews\" module. Blade Blade is the main UI element of the Platform Manager. Every blade has basic parts such as Maximize, Close buttons on the top and the title, toolbar, main content placeholders following down. You can find out all the blade features on the Blade constructor . Read more in the Blades and navigation article. Toolbar A blade toolbar is a dedicated area inside blade for adding commands. Hereinafter, the toolbar commands shall be referenced to as toolbar items. Read more in the Blade toolbar article. Metaform A metaform is a placeholder (container) control that renders UI content based on provided metadata. Read more in the Metaform article. Widget A widget is a relatively simple and intuitive web UI component in Platform Manager. It has the role of a transient or auxiliary tile, meaning that: it occupies just a portion of a blade; provides some useful information displayed in place; usually enables opening additional blade with extra information and functionality; is reusable and can be added to many blades (widget containers) in various places. A widget container is a placeholder control for individual widgets. Read more in the Widgets article. Scripts debugging In order to enable JS debugging in the Platform, set app setting VirtoCommerce:EnableBundlesOptimizations* value to false*** in platform's Web.config: <add key= \"VirtoCommerce:EnableBundlesOptimizations\" value= \"false\" /> Use the developer tools inside your browser, to actually debug the JS code. You can read more in Debugging in Chrome article. Build \"Customer reviews\" module Web UI Platform Manager UI elements should be placed in CustomerReviewsModule.Web\\ Scripts folder. Typical structure of this folder: Scripts - the root folder for Platform Manager UI related content: blades - folder containing AngularJS controllers and templates for the module blades; resources - folder containing AngularJS definitions of the resources (API endpoints) exposed (and used) by this module; widgets - folder containing AngularJS controllers and templates for the module widgets; module.js - the main entry point for the module UI, containing AngularJS module definition, registrations for menus, widgets, etc. The Platform Manager also allows localizing UI elements. The localization is based on resources (translation files) placed in CustomerReviewsModule.Web\\ Localizations folder. Read more in the Localization implementation article. Create localization for \"Customer reviews\" module First of all define the following names for blade and widget: blade title; blade labels (column names, \"no-review\" title); widget title. In order to localize defined names, you need to create the translation file \\Localizations\\en.CustomerReviewsModule.json . { \"customerReviewsModule\" : { \"blades\" : { \"title\" : \"Customer Reviews\" , \"review-list\" : { \"labels\" : { \"content\" : \"Content\" , \"modifiedDate\" : \"Last updated\" , \"no-review\" : \"No Customer Reviews found\" } } }, \"widgets\" : { \"item-detail\" : { \"title\" : \"Customer reviews\" } } } } These translations will be used in blade and widget to label titles and field names in Platform Manager UI. Define API controller for \"Customer reviews\" module To get data from backend, define search API controller method in \\CustomerReviewsModule.Web\\Scripts\\resources\\ customer-reviews-module-api.js file: angular . module ( 'customerReviewsModule' ) . factory ( 'customerReviewsModule.webApi' , [ '$resource' , function ( $resource ) { return $resource ( 'api/CustomerReviewsModule' , {}, { search : { method : 'POST' , url : 'api/customerReviewsModule/search' } }); }]); More info in AngularJS $resource article . Define blade for \"Customer reviews\" list Create a new reviews-list.js blade JS file in \\Scripts\\blades folder and define customerReviewsModule.reviewsListController by adding code to the file: angular . module ( 'customerReviewsModule' ) . controller ( 'customerReviewsModule.reviewsListController' , [ '$scope' , 'customerReviewsModule.webApi' , 'platformWebApp.bladeUtils' , 'uiGridConstants' , 'platformWebApp.uiGridHelper' , function ( $scope , reviewsApi , bladeUtils , uiGridConstants , uiGridHelper ) { $scope . uiGridConstants = uiGridConstants ; var blade = $scope . blade ; var bladeNavigationService = bladeUtils . bladeNavigationService ; blade . getSearchCriteria = function () { return angular . extend ( filter , { searchPhrase : filter . keyword ? filter . keyword : undefined , sort : uiGridHelper . getSortExpression ( $scope ), skip : ( $scope . pageSettings . currentPage - 1 ) * $scope . pageSettings . itemsPerPageCount , take : $scope . pageSettings . itemsPerPageCount }); }; blade . refresh = function () { blade . isLoading = true ; reviewsApi . search ( blade . getSearchCriteria (), function ( data ) { blade . isLoading = false ; $scope . pageSettings . totalItems = data . totalCount ; blade . currentEntities = data . results ; }); }; blade . headIcon = 'fa-comments' ; blade . toolbarCommands = [ { name : \"platform.commands.refresh\" , icon : 'fa fa-refresh' , executeMethod : blade . refresh , canExecuteMethod : function () { return true ; } } ]; // simple and advanced filtering var filter = $scope . filter = blade . filter || {}; filter . criteriaChanged = function () { if ( $scope . pageSettings . currentPage > 1 ) { $scope . pageSettings . currentPage = 1 ; } else { blade . refresh (); } }; // ui-grid $scope . setGridOptions = function ( gridOptions ) { uiGridHelper . initialize ( $scope , gridOptions , function ( gridApi ) { uiGridHelper . bindRefreshOnSortChanged ( $scope ); }); bladeUtils . initializePagination ( $scope . $parent ); }; }]); To show a Customer reviews list in a blade create a new reviews-list.tpl.html blade template file in the same folder: < div class = \"blade-static\" > < div class = \"form-group\" > < div class = \"form-input __search\" > < input placeholder = \"{{'platform.placeholders.search-keyword' | translate}}\" ng-model = \"filter.keyword\" ng-keyup = \"$event.which === 13 && filter.criteriaChanged()\" /> < button class = \"btn __other\" style = \"position: relative;right: 45px;\" > < i class = \"btn-ico fa fa-times-circle\" title = \"Clear\" ng-click = \"filter.keyword=null;filter.criteriaChanged()\" ></ i > </ button > </ div > < p class = \"form-count\" > {{ 'platform.list.count' | translate }}: < span class = \"count\" > {{pageSettings.totalItems | number:0}} </ span ></ p > </ div > </ div > < div class = \"blade-static __bottom\" ng-if = \"pageSettings.itemsPerPageCount < pageSettings.totalItems\" ng-include = \"'pagerTemplate.html'\" ></ div > < div class = \"blade-content\" > < div class = \"blade-inner\" > < div class = \"inner-block\" > < div class = \"table-wrapper\" ng-init = \"setGridOptions({ useExternalSorting: true, rowTemplate: 'list.row.html', columnDefs: [ { name: 'content', displayName: 'customerReviewsModule.blades.review-list.labels.content' }, { name: 'modifiedDate', displayName: 'customerReviewsModule.blades.review-list.labels.modifiedDate', sort: { direction: uiGridConstants.DESC }} ]})\" > < div ui-grid = \"gridOptions\" ui-grid-auto-resize ui-grid-save-state ui-grid-resize-columns ui-grid-move-columns ui-grid-pinning ui-grid-height ></ div > </ div > < p class = \"note\" ng-if = \"!blade.currentEntities.length\" > {{ 'customerReviewsModule.blades.review-list.labels.no-review' | translate }} </ p > </ div > </ div > </ div > < script type = \"text/ng-template\" id = \"list.row.html\" > < div ng - click = \"grid.appScope.blade.selectNode(row.entity)\" ng - repeat = \"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui - grid - one - bind - id - grid = \"rowRenderIndex + '-' + col.uid + '-cell'\" class = \"ui-grid-cell\" ng - class = \"{'ui-grid-row-header-cell': col.isRowHeader, '__hovered': grid.appScope.contextMenuEntity === row.entity, '__selected': row.entity.id===grid.appScope.selectedNodeId }\" role = \"{{col.isRowHeader ? 'rowheader' : 'gridcell' }}\" ui - grid - cell >< /div> </ script > Update the blade shown on activating the workspace.customerReviewsModuleState state in the AngularJS module by editing \\Scripts\\module.js : ~~~ angular . module ( moduleName , []) . config ([ '$stateProvider' , '$urlRouterProvider' , function ( $stateProvider , $urlRouterProvider ) { $stateProvider . state ( 'workspace.customerReviewsModuleState' , { url : '/customerReviewsModule' , templateUrl : '$(Platform)/Scripts/common/templates/home.tpl.html' , controller : [ '$scope' , 'platformWebApp.bladeNavigationService' , function ( $scope , bladeNavigationService ) { var newBlade = { id : 'reviewsList' , title : 'customerReviewsModule.blades.review-list.title' , controller : 'customerReviewsModule.reviewsListController' , template : 'Modules/$(CustomerReviewsModule)/Scripts/blades/reviews-list.tpl.html' , isClosingDisabled : true }; bladeNavigationService . showBlade ( newBlade ); } ] }); } ]) ~~~ When the state is \"activated\", the blade's controller is bound to its template and the new blade is shown. Add a new menu item in main menu for the blade and define menu item permissions by editing \\CustomerReviewsModule.Web\\Scripts\\module.js : ~~~ . run ([ 'platformWebApp.mainMenuService' , 'platformWebApp.widgetService' , '$state' , function ( mainMenuService , widgetService , $state ) { //Register module in main menu var menuItem = { path : 'browse/customerReviewsModule' , icon : 'fa fa-comments' , title : 'Customer Reviews' , priority : 100 , action : function () { $state . go ( 'workspace.customerReviewsModuleState' ) }, permission : 'CustomerReviewsModule:read' }; mainMenuService . addMenuItem ( menuItem ); } ]); ~~~ Delete \\CustomerReviewsModule.Web\\Scripts\\blades\\hello-world.html and \\CustomerReviewsModule.Web\\Scripts\\blades\\hello-world.js files, that were created in the Lesson 3 from Visual Studio template. Save all changes, restart the Platform application and open blade in main menu. You should see existing Customer reviews list: Define widget for \"Customer reviews\" module Add new widgets subfolder inside Scripts folder. Create a new customerReviewWidget.js widget JS file in widgets folder and define customerReviewsModule.customerReviewWidgetController by adding code to the file: angular . module ( 'customerReviewsModule' ) . controller ( 'customerReviewsModule.customerReviewWidgetController' , [ '$scope' , 'customerReviewsModule.webApi' , 'platformWebApp.bladeNavigationService' , function ( $scope , reviewsApi , bladeNavigationService ) { var blade = $scope . blade ; var filter = { take : 0 }; function refresh () { $scope . loading = true ; reviewsApi . search ( filter , function ( data ) { $scope . loading = false ; $scope . totalCount = data . totalCount ; }); } $scope . openBlade = function () { if ( $scope . loading || ! $scope . totalCount ) return ; var newBlade = { id : \"reviewsList\" , filter : filter , title : 'Customer reviews for \"' + blade . title + '\"' , controller : 'customerReviewsModule.reviewsListController' , template : 'Modules/$(CustomerReviewsModule)/Scripts/blades/reviews-list.tpl.html' }; bladeNavigationService . showBlade ( newBlade , blade ); }; $scope . $watch ( \"blade.itemId\" , function ( id ) { filter . productIds = [ id ]; if ( id ) refresh (); }); }]); Create a new customerReviewWidget.tpl.html widget template file in the same folder: < div class = \"gridster-cnt\" ng-click = \"openBlade()\" > < div class = \"cnt-inner\" > < div class = \"list-count\" ng-if = \"loading\" > ... </ div > < div class = \"list-count\" ng-if = \"!loading\" > {{ totalCount }} </ div > < div class = \"list-t\" ng-if = \"!loading\" > {{ 'customerReviews.widgets.item-detail.title' | translate }} </ div > </ div > </ div > \"Inject\" the new widget into the Product detail UI, by registering it in module.js : ~~~ . run ([ 'platformWebApp.mainMenuService' , 'platformWebApp.widgetService' , '$state' , function ( mainMenuService , widgetService , $state ) { //Register module in main menu var menuItem = { path : 'browse/customerReviews' , icon : 'fa fa-comments' , title : 'Customer Reviews' , priority : 100 , action : function () { $state . go ( 'workspace.customerReviews' ) }, permission : 'customerReview:read' }; mainMenuService . addMenuItem ( menuItem ); //Register reviews widget inside product blade var itemReviewsWidget = { controller : 'customerReviewsModule.customerReviewWidgetController' , template : 'Modules/$(CustomerReviewsModule)/Scripts/widgets/customerReviewWidget.tpl.html' }; widgetService . registerWidget ( itemReviewsWidget , 'itemDetail' ); } ]); ~~~ Save all changes, restart application and open Product detail blade. You should see the new widget added and showing actual number of existing reviews for the product. If you click the widget, a new blade should appear, showing with the list of Customer reviews for the product.","title":"Lessons 4 - How to build and customize platform manager Web UI (AngularJS)"},{"location":"lessons/lesson4/#how-to-build-and-customize-platform-manager-web-ui-angularjs","text":"","title":"How to build and customize Platform Manager Web UI (AngularJS)"},{"location":"lessons/lesson4/#summary","text":"Use this guide to create Platform Manager UI for the Virto Commerce \"Customer Reviews\" module (created in the Lesson 3 ). After completing this lesson, a Platform Manager UI for the Virto Commerce \"Customer Reviews\" module will be created, including: blade with the customer reviews list for products; widget on the product page to view the number of reviews and open the new reviews blade for the product.","title":"Summary"},{"location":"lessons/lesson4/#prerequisites","text":"Installed Virto Commerce Platform Manager Visual Studio 2019 or higher Basic JavaScript (AngularJS) knowledge Passed Lesson 3","title":"Prerequisites"},{"location":"lessons/lesson4/#glossary","text":"JS \u2013 JavaScript; Platform - Virto Commerce Platform; Platform Manager \u2013 Virto Commerce Platform Manager, UI for Platform managing; VC \u2013 Virto Commerce; VS \u2013 Visual Studio; UI \u2013 User Interface.","title":"Glossary"},{"location":"lessons/lesson4/#platform-manager-ui-elements","text":"The most common extension points for Platform Manager UI are: * Blade * Toolbar * Metaform * Widget Review these UI elements carefully before you start creating the UI for \"Customer Reviews\" module.","title":"Platform Manager UI elements"},{"location":"lessons/lesson4/#blade","text":"Blade is the main UI element of the Platform Manager. Every blade has basic parts such as Maximize, Close buttons on the top and the title, toolbar, main content placeholders following down. You can find out all the blade features on the Blade constructor . Read more in the Blades and navigation article.","title":"Blade"},{"location":"lessons/lesson4/#toolbar","text":"A blade toolbar is a dedicated area inside blade for adding commands. Hereinafter, the toolbar commands shall be referenced to as toolbar items. Read more in the Blade toolbar article.","title":"Toolbar"},{"location":"lessons/lesson4/#metaform","text":"A metaform is a placeholder (container) control that renders UI content based on provided metadata. Read more in the Metaform article.","title":"Metaform"},{"location":"lessons/lesson4/#widget","text":"A widget is a relatively simple and intuitive web UI component in Platform Manager. It has the role of a transient or auxiliary tile, meaning that: it occupies just a portion of a blade; provides some useful information displayed in place; usually enables opening additional blade with extra information and functionality; is reusable and can be added to many blades (widget containers) in various places. A widget container is a placeholder control for individual widgets. Read more in the Widgets article.","title":"Widget"},{"location":"lessons/lesson4/#scripts-debugging","text":"In order to enable JS debugging in the Platform, set app setting VirtoCommerce:EnableBundlesOptimizations* value to false*** in platform's Web.config: <add key= \"VirtoCommerce:EnableBundlesOptimizations\" value= \"false\" /> Use the developer tools inside your browser, to actually debug the JS code. You can read more in Debugging in Chrome article.","title":"Scripts debugging"},{"location":"lessons/lesson4/#build-customer-reviews-module-web-ui","text":"Platform Manager UI elements should be placed in CustomerReviewsModule.Web\\ Scripts folder. Typical structure of this folder: Scripts - the root folder for Platform Manager UI related content: blades - folder containing AngularJS controllers and templates for the module blades; resources - folder containing AngularJS definitions of the resources (API endpoints) exposed (and used) by this module; widgets - folder containing AngularJS controllers and templates for the module widgets; module.js - the main entry point for the module UI, containing AngularJS module definition, registrations for menus, widgets, etc. The Platform Manager also allows localizing UI elements. The localization is based on resources (translation files) placed in CustomerReviewsModule.Web\\ Localizations folder. Read more in the Localization implementation article.","title":"Build \"Customer reviews\" module Web UI"},{"location":"lessons/lesson4/#create-localization-for-customer-reviews-module","text":"First of all define the following names for blade and widget: blade title; blade labels (column names, \"no-review\" title); widget title. In order to localize defined names, you need to create the translation file \\Localizations\\en.CustomerReviewsModule.json . { \"customerReviewsModule\" : { \"blades\" : { \"title\" : \"Customer Reviews\" , \"review-list\" : { \"labels\" : { \"content\" : \"Content\" , \"modifiedDate\" : \"Last updated\" , \"no-review\" : \"No Customer Reviews found\" } } }, \"widgets\" : { \"item-detail\" : { \"title\" : \"Customer reviews\" } } } } These translations will be used in blade and widget to label titles and field names in Platform Manager UI.","title":"Create localization for \"Customer reviews\" module"},{"location":"lessons/lesson4/#define-api-controller-for-customer-reviews-module","text":"To get data from backend, define search API controller method in \\CustomerReviewsModule.Web\\Scripts\\resources\\ customer-reviews-module-api.js file: angular . module ( 'customerReviewsModule' ) . factory ( 'customerReviewsModule.webApi' , [ '$resource' , function ( $resource ) { return $resource ( 'api/CustomerReviewsModule' , {}, { search : { method : 'POST' , url : 'api/customerReviewsModule/search' } }); }]); More info in AngularJS $resource article .","title":"Define API controller for \"Customer reviews\" module"},{"location":"lessons/lesson4/#define-blade-for-customer-reviews-list","text":"Create a new reviews-list.js blade JS file in \\Scripts\\blades folder and define customerReviewsModule.reviewsListController by adding code to the file: angular . module ( 'customerReviewsModule' ) . controller ( 'customerReviewsModule.reviewsListController' , [ '$scope' , 'customerReviewsModule.webApi' , 'platformWebApp.bladeUtils' , 'uiGridConstants' , 'platformWebApp.uiGridHelper' , function ( $scope , reviewsApi , bladeUtils , uiGridConstants , uiGridHelper ) { $scope . uiGridConstants = uiGridConstants ; var blade = $scope . blade ; var bladeNavigationService = bladeUtils . bladeNavigationService ; blade . getSearchCriteria = function () { return angular . extend ( filter , { searchPhrase : filter . keyword ? filter . keyword : undefined , sort : uiGridHelper . getSortExpression ( $scope ), skip : ( $scope . pageSettings . currentPage - 1 ) * $scope . pageSettings . itemsPerPageCount , take : $scope . pageSettings . itemsPerPageCount }); }; blade . refresh = function () { blade . isLoading = true ; reviewsApi . search ( blade . getSearchCriteria (), function ( data ) { blade . isLoading = false ; $scope . pageSettings . totalItems = data . totalCount ; blade . currentEntities = data . results ; }); }; blade . headIcon = 'fa-comments' ; blade . toolbarCommands = [ { name : \"platform.commands.refresh\" , icon : 'fa fa-refresh' , executeMethod : blade . refresh , canExecuteMethod : function () { return true ; } } ]; // simple and advanced filtering var filter = $scope . filter = blade . filter || {}; filter . criteriaChanged = function () { if ( $scope . pageSettings . currentPage > 1 ) { $scope . pageSettings . currentPage = 1 ; } else { blade . refresh (); } }; // ui-grid $scope . setGridOptions = function ( gridOptions ) { uiGridHelper . initialize ( $scope , gridOptions , function ( gridApi ) { uiGridHelper . bindRefreshOnSortChanged ( $scope ); }); bladeUtils . initializePagination ( $scope . $parent ); }; }]); To show a Customer reviews list in a blade create a new reviews-list.tpl.html blade template file in the same folder: < div class = \"blade-static\" > < div class = \"form-group\" > < div class = \"form-input __search\" > < input placeholder = \"{{'platform.placeholders.search-keyword' | translate}}\" ng-model = \"filter.keyword\" ng-keyup = \"$event.which === 13 && filter.criteriaChanged()\" /> < button class = \"btn __other\" style = \"position: relative;right: 45px;\" > < i class = \"btn-ico fa fa-times-circle\" title = \"Clear\" ng-click = \"filter.keyword=null;filter.criteriaChanged()\" ></ i > </ button > </ div > < p class = \"form-count\" > {{ 'platform.list.count' | translate }}: < span class = \"count\" > {{pageSettings.totalItems | number:0}} </ span ></ p > </ div > </ div > < div class = \"blade-static __bottom\" ng-if = \"pageSettings.itemsPerPageCount < pageSettings.totalItems\" ng-include = \"'pagerTemplate.html'\" ></ div > < div class = \"blade-content\" > < div class = \"blade-inner\" > < div class = \"inner-block\" > < div class = \"table-wrapper\" ng-init = \"setGridOptions({ useExternalSorting: true, rowTemplate: 'list.row.html', columnDefs: [ { name: 'content', displayName: 'customerReviewsModule.blades.review-list.labels.content' }, { name: 'modifiedDate', displayName: 'customerReviewsModule.blades.review-list.labels.modifiedDate', sort: { direction: uiGridConstants.DESC }} ]})\" > < div ui-grid = \"gridOptions\" ui-grid-auto-resize ui-grid-save-state ui-grid-resize-columns ui-grid-move-columns ui-grid-pinning ui-grid-height ></ div > </ div > < p class = \"note\" ng-if = \"!blade.currentEntities.length\" > {{ 'customerReviewsModule.blades.review-list.labels.no-review' | translate }} </ p > </ div > </ div > </ div > < script type = \"text/ng-template\" id = \"list.row.html\" > < div ng - click = \"grid.appScope.blade.selectNode(row.entity)\" ng - repeat = \"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui - grid - one - bind - id - grid = \"rowRenderIndex + '-' + col.uid + '-cell'\" class = \"ui-grid-cell\" ng - class = \"{'ui-grid-row-header-cell': col.isRowHeader, '__hovered': grid.appScope.contextMenuEntity === row.entity, '__selected': row.entity.id===grid.appScope.selectedNodeId }\" role = \"{{col.isRowHeader ? 'rowheader' : 'gridcell' }}\" ui - grid - cell >< /div> </ script > Update the blade shown on activating the workspace.customerReviewsModuleState state in the AngularJS module by editing \\Scripts\\module.js : ~~~ angular . module ( moduleName , []) . config ([ '$stateProvider' , '$urlRouterProvider' , function ( $stateProvider , $urlRouterProvider ) { $stateProvider . state ( 'workspace.customerReviewsModuleState' , { url : '/customerReviewsModule' , templateUrl : '$(Platform)/Scripts/common/templates/home.tpl.html' , controller : [ '$scope' , 'platformWebApp.bladeNavigationService' , function ( $scope , bladeNavigationService ) { var newBlade = { id : 'reviewsList' , title : 'customerReviewsModule.blades.review-list.title' , controller : 'customerReviewsModule.reviewsListController' , template : 'Modules/$(CustomerReviewsModule)/Scripts/blades/reviews-list.tpl.html' , isClosingDisabled : true }; bladeNavigationService . showBlade ( newBlade ); } ] }); } ]) ~~~ When the state is \"activated\", the blade's controller is bound to its template and the new blade is shown. Add a new menu item in main menu for the blade and define menu item permissions by editing \\CustomerReviewsModule.Web\\Scripts\\module.js : ~~~ . run ([ 'platformWebApp.mainMenuService' , 'platformWebApp.widgetService' , '$state' , function ( mainMenuService , widgetService , $state ) { //Register module in main menu var menuItem = { path : 'browse/customerReviewsModule' , icon : 'fa fa-comments' , title : 'Customer Reviews' , priority : 100 , action : function () { $state . go ( 'workspace.customerReviewsModuleState' ) }, permission : 'CustomerReviewsModule:read' }; mainMenuService . addMenuItem ( menuItem ); } ]); ~~~ Delete \\CustomerReviewsModule.Web\\Scripts\\blades\\hello-world.html and \\CustomerReviewsModule.Web\\Scripts\\blades\\hello-world.js files, that were created in the Lesson 3 from Visual Studio template. Save all changes, restart the Platform application and open blade in main menu. You should see existing Customer reviews list:","title":"Define blade for \"Customer reviews\" list"},{"location":"lessons/lesson4/#define-widget-for-customer-reviews-module","text":"Add new widgets subfolder inside Scripts folder. Create a new customerReviewWidget.js widget JS file in widgets folder and define customerReviewsModule.customerReviewWidgetController by adding code to the file: angular . module ( 'customerReviewsModule' ) . controller ( 'customerReviewsModule.customerReviewWidgetController' , [ '$scope' , 'customerReviewsModule.webApi' , 'platformWebApp.bladeNavigationService' , function ( $scope , reviewsApi , bladeNavigationService ) { var blade = $scope . blade ; var filter = { take : 0 }; function refresh () { $scope . loading = true ; reviewsApi . search ( filter , function ( data ) { $scope . loading = false ; $scope . totalCount = data . totalCount ; }); } $scope . openBlade = function () { if ( $scope . loading || ! $scope . totalCount ) return ; var newBlade = { id : \"reviewsList\" , filter : filter , title : 'Customer reviews for \"' + blade . title + '\"' , controller : 'customerReviewsModule.reviewsListController' , template : 'Modules/$(CustomerReviewsModule)/Scripts/blades/reviews-list.tpl.html' }; bladeNavigationService . showBlade ( newBlade , blade ); }; $scope . $watch ( \"blade.itemId\" , function ( id ) { filter . productIds = [ id ]; if ( id ) refresh (); }); }]); Create a new customerReviewWidget.tpl.html widget template file in the same folder: < div class = \"gridster-cnt\" ng-click = \"openBlade()\" > < div class = \"cnt-inner\" > < div class = \"list-count\" ng-if = \"loading\" > ... </ div > < div class = \"list-count\" ng-if = \"!loading\" > {{ totalCount }} </ div > < div class = \"list-t\" ng-if = \"!loading\" > {{ 'customerReviews.widgets.item-detail.title' | translate }} </ div > </ div > </ div > \"Inject\" the new widget into the Product detail UI, by registering it in module.js : ~~~ . run ([ 'platformWebApp.mainMenuService' , 'platformWebApp.widgetService' , '$state' , function ( mainMenuService , widgetService , $state ) { //Register module in main menu var menuItem = { path : 'browse/customerReviews' , icon : 'fa fa-comments' , title : 'Customer Reviews' , priority : 100 , action : function () { $state . go ( 'workspace.customerReviews' ) }, permission : 'customerReview:read' }; mainMenuService . addMenuItem ( menuItem ); //Register reviews widget inside product blade var itemReviewsWidget = { controller : 'customerReviewsModule.customerReviewWidgetController' , template : 'Modules/$(CustomerReviewsModule)/Scripts/widgets/customerReviewWidget.tpl.html' }; widgetService . registerWidget ( itemReviewsWidget , 'itemDetail' ); } ]); ~~~ Save all changes, restart application and open Product detail blade. You should see the new widget added and showing actual number of existing reviews for the product. If you click the widget, a new blade should appear, showing with the list of Customer reviews for the product.","title":"Define widget for \"Customer reviews\" module"},{"location":"modules/catalog/","text":"","title":"Index"},{"location":"vc2devguide/introduction/","text":"Overview Virto Commerce 2 is a major release and has been in development for over a year. It consists of Virto Commerce Platform and Virto Commerce Modules. Technology Stack Used Our decision to use these technologies was the consequence of our extensive experience with Microsoft products. We decided to use the following stack of technologies: ASP.NET MVC 5 - as a web hosting technology ASP.NET Web API 2 - to implement REST services Entity Framework 6.1 - ORM EF Migrations - for managing database schema changes and data ASP.NET Identity - tasks related to authorization and authentication AngularJS - for SPA user interface. One of the major decisions for picking it is due to its popularity and quality documentation. We didn\u2019t have any prior experience working with AngularJS. Looking back, we never had any regrets with our decision to do so. Architecture Platform and modules are written using DDD , SOLID , Test Driven Development methodologies. For a presentation layer, we use MVVM (thanks to AngularJS - the transition from WPF didn\u2019t create any complications). Platform Capabilities Now let's look at a list of core platform capabilities. It is important to understand that this list contains platform capabilities. These platform capabilities are not add-on features developed on top of an ecommerce application. Style Guide We created our own theme for an application using MCSS methodology. We also created a style guide and visual constructor for navigation elements (blades), allowing you to easily create an HTML markup that can then be used in extension modules. Navigation Here, we present a unified navigation concept for user interfaces. We really liked the navigation idea used in the new portal.azure.com portal with horizontal scrolling, and we decided to take it as a base. The main navigation elements are: blade - analog of Windows in classic interface widget container which contains widget main menu - global navigation menu for all the modules Modularity Platform allows extending system function in runtime by installing extension modules. Considering that each module can provide its own user interface and REST API services , the platform can be customized to serve many specific business needs. Modularity is one of the most difficult problems we encountered. To solve it, we had to adopt Microsoft PRISM from WPF and make it work in ASP.NET MVC. Modules contain information about versions and dependencies which are used by the system during module initialization and installation. Besides extending user interface and API, each module can use its own Database Schema with support for data migration during version updates. It can also extend or overwrite functionality from other modules using Unity - IoC and Dependency injection container. We won\u2019t list all the user interface extensibility points, but here are just a few of them: main menu, toolbars, widgets, notifications, etc. Import/Export Platform comes with advanced import/export functionality that allows each module to specify (through API interface) how the data can be imported and exported from that module and platform provides a unified UI to export and import data as shown below. View of platform export/import UI: This feature can then be used for various scenarios including: Publishing content from Staging to Production environment Creating starter e-commerce stores with all themes, catalogs, products, properties, promotions, marketing banners etc as preconfigured","title":"Introduction"},{"location":"vc2devguide/introduction/#overview","text":"Virto Commerce 2 is a major release and has been in development for over a year. It consists of Virto Commerce Platform and Virto Commerce Modules.","title":"Overview"},{"location":"vc2devguide/introduction/#technology-stack-used","text":"Our decision to use these technologies was the consequence of our extensive experience with Microsoft products. We decided to use the following stack of technologies: ASP.NET MVC 5 - as a web hosting technology ASP.NET Web API 2 - to implement REST services Entity Framework 6.1 - ORM EF Migrations - for managing database schema changes and data ASP.NET Identity - tasks related to authorization and authentication AngularJS - for SPA user interface. One of the major decisions for picking it is due to its popularity and quality documentation. We didn\u2019t have any prior experience working with AngularJS. Looking back, we never had any regrets with our decision to do so.","title":"Technology Stack Used"},{"location":"vc2devguide/introduction/#architecture","text":"Platform and modules are written using DDD , SOLID , Test Driven Development methodologies. For a presentation layer, we use MVVM (thanks to AngularJS - the transition from WPF didn\u2019t create any complications).","title":"Architecture"},{"location":"vc2devguide/introduction/#platform-capabilities","text":"Now let's look at a list of core platform capabilities. It is important to understand that this list contains platform capabilities. These platform capabilities are not add-on features developed on top of an ecommerce application.","title":"Platform Capabilities"},{"location":"vc2devguide/introduction/#style-guide","text":"We created our own theme for an application using MCSS methodology. We also created a style guide and visual constructor for navigation elements (blades), allowing you to easily create an HTML markup that can then be used in extension modules.","title":"Style Guide"},{"location":"vc2devguide/introduction/#navigation","text":"Here, we present a unified navigation concept for user interfaces. We really liked the navigation idea used in the new portal.azure.com portal with horizontal scrolling, and we decided to take it as a base. The main navigation elements are: blade - analog of Windows in classic interface widget container which contains widget main menu - global navigation menu for all the modules","title":"Navigation"},{"location":"vc2devguide/introduction/#modularity","text":"Platform allows extending system function in runtime by installing extension modules. Considering that each module can provide its own user interface and REST API services , the platform can be customized to serve many specific business needs. Modularity is one of the most difficult problems we encountered. To solve it, we had to adopt Microsoft PRISM from WPF and make it work in ASP.NET MVC. Modules contain information about versions and dependencies which are used by the system during module initialization and installation. Besides extending user interface and API, each module can use its own Database Schema with support for data migration during version updates. It can also extend or overwrite functionality from other modules using Unity - IoC and Dependency injection container. We won\u2019t list all the user interface extensibility points, but here are just a few of them: main menu, toolbars, widgets, notifications, etc.","title":"Modularity"},{"location":"vc2devguide/introduction/#importexport","text":"Platform comes with advanced import/export functionality that allows each module to specify (through API interface) how the data can be imported and exported from that module and platform provides a unified UI to export and import data as shown below. View of platform export/import UI: This feature can then be used for various scenarios including: Publishing content from Staging to Production environment Creating starter e-commerce stores with all themes, catalogs, products, properties, promotions, marketing banners etc as preconfigured","title":"Import/Export"},{"location":"vc2devguide/system-requirements/","text":"Software requirements Windows Server 2008 or later (IIS 7 or later) Microsoft .NET Framework 4.6.1 Visual C++ Redistributable Packages for Visual Studio 2013 (for storefront) Microsoft SQL Server 2008 or later Storage requirements Precompiled Virto Commerce Manager with storefront take about 130 MB. When using the Deploy to Azure button on GitHub, the Azure web app downloads the source code and compiles it on the Azure web app - this takes about 800 MB.This means even the F1 (free) service plan is enough to host both web applications. S2 has 50 GB of storage, which is more than enough for both applications and product assets (images) of very large catalog. So when choosing between S2 and P2 you should only consider the performance of these instances. Also it is advisable to store product assets in a separate blob storage (Azure Storage Account).","title":"System Requirements - Virto Commerce 2 Developer Guide"},{"location":"vc2devguide/system-requirements/#software-requirements","text":"Windows Server 2008 or later (IIS 7 or later) Microsoft .NET Framework 4.6.1 Visual C++ Redistributable Packages for Visual Studio 2013 (for storefront) Microsoft SQL Server 2008 or later","title":"Software requirements"},{"location":"vc2devguide/system-requirements/#storage-requirements","text":"Precompiled Virto Commerce Manager with storefront take about 130 MB. When using the Deploy to Azure button on GitHub, the Azure web app downloads the source code and compiles it on the Azure web app - this takes about 800 MB.This means even the F1 (free) service plan is enough to host both web applications. S2 has 50 GB of storage, which is more than enough for both applications and product assets (images) of very large catalog. So when choosing between S2 and P2 you should only consider the performance of these instances. Also it is advisable to store product assets in a separate blob storage (Azure Storage Account).","title":"Storage requirements"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/","text":"Platform API authentication configuration Virto Commerce platform supports 2 types of authentication for API calls: Simple - when user id passed in url for each API request. Example: http://demo.virtocommerce.com/admin/api/catalog/catalogs?api_key=a348fa7508d342f6a32f8bf6c6681a2a%20 HMAC - Hash-based message authentication code (HMAC) is used to identify a client and ensure the request integrity. In order to enable using platform API, first of all you should create user account in Commerce Manager and generate API key of appropriate type (simple or HMAC). Create user You need to create a new user for impersonating the API requests. Login to Commerce Manager with administrator permissions. Navigate to Configuration -> Security -> Users . Create a new account and assign Use api role (comprising of single permission security:call_api ) to it. More details on permissions: Working with platform security . After the permissions has been set, click \"Create\". The new user will be created and account details blade will open. Generate HMAC API key Open Configuration > Security > Users Select a user Click API Keys widget Click Add button in the toolbar Select Hmac as Key type Click Ok button in the API key blade Click Save button in the User details blade Generate Simple API key Repeat 1-5 steps as above Select Simple as Key type Click Ok button in the API key blade Click Save button in the User details blade. Using platform API from managed C# code An API client has to be generated before using API. Refer How to generate module API C# client using AutoRest for instructions. Next you should install special VirtoCommerce.Platform.Client.Security NuGet package which allows to use both (HMAC and SImple) API authentication protocols. Using API with HMAC authentication // HMAC credentials // that is the App ID generated while creating HMACkey for the user . var apiAppId = \"your API id\" ; // that is the Secret key generated while creating HMAC key for the user . var apiSecretKey = \"your API secret key\" ; // Create handler which will add HMAC authorization to each request var requestHandler = new VirtoCommerceApiRequestHandler ( new HmacCredentials ( apiAppId , apiSecretKey ), new WorkContext ()) // Create rest client var catalogClient = new CatalogModuleApiClient ( \"platform API url\" , requestHandler , new System . Net . Http . HttpClientHandler { AutomaticDecompression = DecompressionMethods . GZip | DecompressionMethods . Deflate } ); // get all catalogs var catalogs = catalogClient . CatalogModuleCatalogs . GetCatalogs (); Using API with Simple authentication // Simple auth key // that is the authentication key generated for user var apiKey = \"your API key\" ; // Create simple headers handler which will add query string ? api_key parameter to each request var requestHandler = new SimpleKeyRestRequestHandler ( apiKey ); // Create rest client var catalogClient = new CatalogModuleApiClient ( \"platform API url\" , requestHandler , new System . Net . Http . HttpClientHandler { AutomaticDecompression = DecompressionMethods . GZip | DecompressionMethods . Deflate } ); // get all catalogs var catalogs = catalogClient . CatalogModuleCatalogs . GetCatalogs (); Using platform API from JavaScript Using API with Simple authentication Nothing special, just add ?api_key='Your API key' to each API request. Example Using API with HMAC authentication Constructing the request When using HMAC authentication each request to the API should include the following HTTP header: Name Value Authorization HMACSHA256 AppId;Timestamp;Signature Example: Authorization : HMACSHA256 27 e0d789f12641049bd0e939185b4fd2 ; 2016 - 02 - 09 T13 : 24 : 20.837 Z ; e82bbded532a80bf744f70a86506ddbe94e0e8653304ad67819d8e280e52282f HMACSHA256 Authorization type AppId The client ID Timestamp Date and time when the request has been constructed (in ISO 8601 format) Signature The HEX string representing the hash of the AppId and Timestamp calculated with HMACSHA256 algorithm Calculating the signature Though the following code examples are written in JavaScript, the steps are the same for any language. Include the HMAC implementation from Google Code: <script src= \"http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js\" ></script> * Build the timestamp string by converting current date and time to string in the ISO 8601 format: var timestampString = new Date().toISOString(); Build the message string by concatenating the AppId and timestamp string and separating them with the ampersand character: var message = appId + '&' + timestampString; Calculate the message hash by using the HMACSHA256 algorithm with your secretKey: var hash = CryptoJS.HmacSHA256(message, CryptoJS.enc.Hex.parse(secretKey)); Build the authorization header value by concatenating the AppId, timestamp and hash and separating them with the semicolon character: var headerValue = 'HMACSHA256 ' + appId + ';' + timestampString + ';' + hash; Add authorization header to the request: $.ajax({ url: 'http://localhost/admin/api/platform/security/currentuser', headers: { Authorization: headerValue } }) JavaScript test client <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > Using HMAC authentication for Virto Commerce in JavaScript </ title > < style > . label { margin-top : 1 em ; font-weight : bold ; } . text-input { width : 30 em ; } </ style > < script src = \"https://code.jquery.com/jquery-2.2.0.min.js\" ></ script > < script src = \"http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js\" ></ script > < script type = \"text/javascript\" > $ ( function () { $ ( '#button' ). click ( sendRequest ); var progress = $ ( \"#progress\" ); progress . hide (); function sendRequest () { var appId = $ ( \"#app-id\" ); var secretKey = $ ( \"#secret-key\" ); var api = $ ( \"#api\" ); var header = $ ( \"#header\" ); var response = $ ( \"#response\" ); var headerValue = generateAuthorizationHeaderValue ( appId . val (), secretKey . val ()); header . text ( headerValue ); progress . show (); $ . ajax ({ url : api . val (), headers : { Authorization : headerValue } }). done ( function ( data ) { response . text ( JSON . stringify ( data )); }). fail ( function ( jqXhr , textStatus , errorThrown ) { response . text ( 'ERROR: ' + errorThrown ); }). always ( function () { progress . hide (); }); } function generateAuthorizationHeaderValue ( appId , secretKey ) { var timestampString = new Date (). toISOString (); var message = appId + '&' + timestampString ; var hash = CryptoJS . HmacSHA256 ( message , CryptoJS . enc . Hex . parse ( secretKey )); var headerValue = 'HMACSHA256 ' + appId + ';' + timestampString + ';' + hash ; return headerValue ; } }); </ script > </ head > < body > < div class = \"label\" > App ID </ div > < input id = \"app-id\" class = \"text-input\" type = \"text\" value = \"27e0d789f12641049bd0e939185b4fd2\" /> < div class = \"label\" > Secret Key </ div > < input id = \"secret-key\" class = \"text-input\" type = \"text\" value = \"34f0a3c12c9dbb59b63b5fece955b7b2b9a3b20f84370cba1524dd5c53503a2e2cb733536ecf7ea1e77319a47084a3a2c9d94d36069a432ecc73b72aeba6ea78\" /> < div class = \"label\" > URL </ div > < input id = \"api\" class = \"text-input\" type = \"text\" value = \"http://localhost/admin/api/platform/security/currentuser\" /> < input id = \"button\" type = \"button\" value = \"Send Request\" /> < span id = \"progress\" > Sending request... </ span > < div class = \"label\" > Authorization header value </ div > < div id = \"header\" ></ div > < div class = \"label\" > Response </ div > < div id = \"response\" ></ div > </ body > </ html >","title":"Working with platform API"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#platform-api-authentication-configuration","text":"Virto Commerce platform supports 2 types of authentication for API calls: Simple - when user id passed in url for each API request. Example: http://demo.virtocommerce.com/admin/api/catalog/catalogs?api_key=a348fa7508d342f6a32f8bf6c6681a2a%20 HMAC - Hash-based message authentication code (HMAC) is used to identify a client and ensure the request integrity. In order to enable using platform API, first of all you should create user account in Commerce Manager and generate API key of appropriate type (simple or HMAC).","title":"Platform API authentication configuration"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#create-user","text":"You need to create a new user for impersonating the API requests. Login to Commerce Manager with administrator permissions. Navigate to Configuration -> Security -> Users . Create a new account and assign Use api role (comprising of single permission security:call_api ) to it. More details on permissions: Working with platform security . After the permissions has been set, click \"Create\". The new user will be created and account details blade will open.","title":"Create user"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#generate-hmac-api-key","text":"Open Configuration > Security > Users Select a user Click API Keys widget Click Add button in the toolbar Select Hmac as Key type Click Ok button in the API key blade Click Save button in the User details blade","title":"Generate HMAC API key"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#generate-simple-api-key","text":"Repeat 1-5 steps as above Select Simple as Key type Click Ok button in the API key blade Click Save button in the User details blade.","title":"Generate Simple API key"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#using-platform-api-from-managed-c-code","text":"An API client has to be generated before using API. Refer How to generate module API C# client using AutoRest for instructions. Next you should install special VirtoCommerce.Platform.Client.Security NuGet package which allows to use both (HMAC and SImple) API authentication protocols.","title":"Using platform API from managed C# code"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#using-api-with-hmac-authentication","text":"// HMAC credentials // that is the App ID generated while creating HMACkey for the user . var apiAppId = \"your API id\" ; // that is the Secret key generated while creating HMAC key for the user . var apiSecretKey = \"your API secret key\" ; // Create handler which will add HMAC authorization to each request var requestHandler = new VirtoCommerceApiRequestHandler ( new HmacCredentials ( apiAppId , apiSecretKey ), new WorkContext ()) // Create rest client var catalogClient = new CatalogModuleApiClient ( \"platform API url\" , requestHandler , new System . Net . Http . HttpClientHandler { AutomaticDecompression = DecompressionMethods . GZip | DecompressionMethods . Deflate } ); // get all catalogs var catalogs = catalogClient . CatalogModuleCatalogs . GetCatalogs ();","title":"Using API with HMAC authentication"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#using-api-with-simple-authentication","text":"// Simple auth key // that is the authentication key generated for user var apiKey = \"your API key\" ; // Create simple headers handler which will add query string ? api_key parameter to each request var requestHandler = new SimpleKeyRestRequestHandler ( apiKey ); // Create rest client var catalogClient = new CatalogModuleApiClient ( \"platform API url\" , requestHandler , new System . Net . Http . HttpClientHandler { AutomaticDecompression = DecompressionMethods . GZip | DecompressionMethods . Deflate } ); // get all catalogs var catalogs = catalogClient . CatalogModuleCatalogs . GetCatalogs ();","title":"Using API with Simple authentication"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#using-platform-api-from-javascript","text":"","title":"Using platform API from JavaScript"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#using-api-with-simple-authentication_1","text":"Nothing special, just add ?api_key='Your API key' to each API request. Example","title":"Using API with Simple authentication"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#using-api-with-hmac-authentication_1","text":"","title":"Using API with HMAC authentication"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#constructing-the-request","text":"When using HMAC authentication each request to the API should include the following HTTP header: Name Value Authorization HMACSHA256 AppId;Timestamp;Signature Example: Authorization : HMACSHA256 27 e0d789f12641049bd0e939185b4fd2 ; 2016 - 02 - 09 T13 : 24 : 20.837 Z ; e82bbded532a80bf744f70a86506ddbe94e0e8653304ad67819d8e280e52282f HMACSHA256 Authorization type AppId The client ID Timestamp Date and time when the request has been constructed (in ISO 8601 format) Signature The HEX string representing the hash of the AppId and Timestamp calculated with HMACSHA256 algorithm","title":"Constructing the request"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#calculating-the-signature","text":"Though the following code examples are written in JavaScript, the steps are the same for any language. Include the HMAC implementation from Google Code: <script src= \"http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js\" ></script> * Build the timestamp string by converting current date and time to string in the ISO 8601 format: var timestampString = new Date().toISOString(); Build the message string by concatenating the AppId and timestamp string and separating them with the ampersand character: var message = appId + '&' + timestampString; Calculate the message hash by using the HMACSHA256 algorithm with your secretKey: var hash = CryptoJS.HmacSHA256(message, CryptoJS.enc.Hex.parse(secretKey)); Build the authorization header value by concatenating the AppId, timestamp and hash and separating them with the semicolon character: var headerValue = 'HMACSHA256 ' + appId + ';' + timestampString + ';' + hash; Add authorization header to the request: $.ajax({ url: 'http://localhost/admin/api/platform/security/currentuser', headers: { Authorization: headerValue } })","title":"Calculating the signature"},{"location":"vc2devguide/development-scenarios/working-with-platform-api/#javascript-test-client","text":"<!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > Using HMAC authentication for Virto Commerce in JavaScript </ title > < style > . label { margin-top : 1 em ; font-weight : bold ; } . text-input { width : 30 em ; } </ style > < script src = \"https://code.jquery.com/jquery-2.2.0.min.js\" ></ script > < script src = \"http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js\" ></ script > < script type = \"text/javascript\" > $ ( function () { $ ( '#button' ). click ( sendRequest ); var progress = $ ( \"#progress\" ); progress . hide (); function sendRequest () { var appId = $ ( \"#app-id\" ); var secretKey = $ ( \"#secret-key\" ); var api = $ ( \"#api\" ); var header = $ ( \"#header\" ); var response = $ ( \"#response\" ); var headerValue = generateAuthorizationHeaderValue ( appId . val (), secretKey . val ()); header . text ( headerValue ); progress . show (); $ . ajax ({ url : api . val (), headers : { Authorization : headerValue } }). done ( function ( data ) { response . text ( JSON . stringify ( data )); }). fail ( function ( jqXhr , textStatus , errorThrown ) { response . text ( 'ERROR: ' + errorThrown ); }). always ( function () { progress . hide (); }); } function generateAuthorizationHeaderValue ( appId , secretKey ) { var timestampString = new Date (). toISOString (); var message = appId + '&' + timestampString ; var hash = CryptoJS . HmacSHA256 ( message , CryptoJS . enc . Hex . parse ( secretKey )); var headerValue = 'HMACSHA256 ' + appId + ';' + timestampString + ';' + hash ; return headerValue ; } }); </ script > </ head > < body > < div class = \"label\" > App ID </ div > < input id = \"app-id\" class = \"text-input\" type = \"text\" value = \"27e0d789f12641049bd0e939185b4fd2\" /> < div class = \"label\" > Secret Key </ div > < input id = \"secret-key\" class = \"text-input\" type = \"text\" value = \"34f0a3c12c9dbb59b63b5fece955b7b2b9a3b20f84370cba1524dd5c53503a2e2cb733536ecf7ea1e77319a47084a3a2c9d94d36069a432ecc73b72aeba6ea78\" /> < div class = \"label\" > URL </ div > < input id = \"api\" class = \"text-input\" type = \"text\" value = \"http://localhost/admin/api/platform/security/currentuser\" /> < input id = \"button\" type = \"button\" value = \"Send Request\" /> < span id = \"progress\" > Sending request... </ span > < div class = \"label\" > Authorization header value </ div > < div id = \"header\" ></ div > < div class = \"label\" > Response </ div > < div id = \"response\" ></ div > </ body > </ html >","title":"JavaScript test client"}]}